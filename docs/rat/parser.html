<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.0.1" />
    <title>rat.parser API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>

<script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    /* Re-invoke MathJax when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => MathJax.typeset()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script>
<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../rat.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;rat</a>


                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#PrefixOps">PrefixOps</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PrefixOps.__init__">PrefixOps</a>
                        </li>
                        <li>
                                <a class="variable" href="#PrefixOps.ops">ops</a>
                        </li>
                        <li>
                                <a class="variable" href="#PrefixOps.precedence">precedence</a>
                        </li>
                        <li>
                                <a class="function" href="#PrefixOps.check">check</a>
                        </li>
                        <li>
                                <a class="function" href="#PrefixOps.generate">generate</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PostfixOps">PostfixOps</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PostfixOps.__init__">PostfixOps</a>
                        </li>
                        <li>
                                <a class="variable" href="#PostfixOps.ops">ops</a>
                        </li>
                        <li>
                                <a class="function" href="#PostfixOps.check">check</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#InfixOps">InfixOps</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#InfixOps.__init__">InfixOps</a>
                        </li>
                        <li>
                                <a class="variable" href="#InfixOps.ops">ops</a>
                        </li>
                        <li>
                                <a class="variable" href="#InfixOps.precedence">precedence</a>
                        </li>
                        <li>
                                <a class="function" href="#InfixOps.check">check</a>
                        </li>
                        <li>
                                <a class="function" href="#InfixOps.generate">generate</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#AssignmentOps">AssignmentOps</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#AssignmentOps.__init__">AssignmentOps</a>
                        </li>
                        <li>
                                <a class="variable" href="#AssignmentOps.ops">ops</a>
                        </li>
                        <li>
                                <a class="function" href="#AssignmentOps.check">check</a>
                        </li>
                        <li>
                                <a class="function" href="#AssignmentOps.generate">generate</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#UnaryFunctions">UnaryFunctions</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#UnaryFunctions.__init__">UnaryFunctions</a>
                        </li>
                        <li>
                                <a class="variable" href="#UnaryFunctions.names">names</a>
                        </li>
                        <li>
                                <a class="variable" href="#UnaryFunctions.precedence">precedence</a>
                        </li>
                        <li>
                                <a class="function" href="#UnaryFunctions.check">check</a>
                        </li>
                        <li>
                                <a class="function" href="#UnaryFunctions.generate">generate</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Distributions">Distributions</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Distributions.__init__">Distributions</a>
                        </li>
                        <li>
                                <a class="variable" href="#Distributions.names">names</a>
                        </li>
                        <li>
                                <a class="function" href="#Distributions.check">check</a>
                        </li>
                        <li>
                                <a class="function" href="#Distributions.generate">generate</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#ParseError">ParseError</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ParseError.__init__">ParseError</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Parser">Parser</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Parser.__init__">Parser</a>
                        </li>
                        <li>
                                <a class="function" href="#Parser.check_bracket_stack">check_bracket_stack</a>
                        </li>
                        <li>
                                <a class="function" href="#Parser.peek">peek</a>
                        </li>
                        <li>
                                <a class="function" href="#Parser.remove">remove</a>
                        </li>
                        <li>
                                <a class="function" href="#Parser.expect_token">expect_token</a>
                        </li>
                        <li>
                                <a class="function" href="#Parser.expressions">expressions</a>
                        </li>
                        <li>
                                <a class="function" href="#Parser.parse_nud">parse_nud</a>
                        </li>
                        <li>
                                <a class="function" href="#Parser.parse_param">parse_param</a>
                        </li>
                        <li>
                                <a class="function" href="#Parser.expression">expression</a>
                        </li>
                        <li>
                                <a class="function" href="#Parser.statement">statement</a>
                        </li>
                </ul>

            </li>
    </ul>



                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../rat.html">rat</a><wbr>.parser    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.scanner</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Token</span><span class="p">,</span>
    <span class="n">Identifier</span><span class="p">,</span>
    <span class="n">Operator</span><span class="p">,</span>
    <span class="n">RealLiteral</span><span class="p">,</span>
    <span class="n">IntLiteral</span><span class="p">,</span>
    <span class="n">Special</span><span class="p">,</span>
    <span class="n">NullToken</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.ops</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">jax.numpy</span>

<span class="c1"># https://mc-stan.org/docs/2_18/reference-manual/bnf-grammars.html</span>
<span class="c1"># https://mc-stan.org/docs/2_28/reference-manual/arithmetic-expressions.html</span>


<span class="c1"># define group parsing rules for operators</span>
<span class="k">class</span> <span class="nc">PrefixOps</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build prefix-operation expressions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;!&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">]</span>
    <span class="n">precedence</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;!&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Token</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">tok</span><span class="p">:</span> <span class="n">Operator</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;!&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PrefixLogicalNegation</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PrefixNegation</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PostfixOps</span><span class="p">:</span>  <span class="c1"># not used atm</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&#39;&quot;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Token</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">PostfixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">InfixOps</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build binary operation expressions.</span>
<span class="sd">    Currently supported operations are:</span>
<span class="sd">    `ops.Sum`, `ops.Diff`, `ops.Mul`, `ops.Pow`, `ops.Mod`, `ops.Div`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;%&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">]</span>
    <span class="n">precedence</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Diff</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Div</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mod</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LessThan</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GreaterThan</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;InfixOps: Unknown operator type </span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="c1"># group parsing rules for statements</span>


<span class="k">class</span> <span class="nc">AssignmentOps</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build assignments in statements.</span>
<span class="sd">    Currently supports the following assignment types:</span>
<span class="sd">    `ops.Assignment`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;=&quot;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">AssignmentOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="c1"># check() has been ran for operator</span>
        <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;=&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Assignment</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">UnaryFunctions</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build unary functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="s2">&quot;abs&quot;</span><span class="p">,</span> <span class="s2">&quot;floor&quot;</span><span class="p">,</span> <span class="s2">&quot;ceil&quot;</span><span class="p">,</span> <span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="s2">&quot;sin&quot;</span><span class="p">,</span> <span class="s2">&quot;cos&quot;</span><span class="p">,</span> <span class="s2">&quot;tan&quot;</span><span class="p">,</span> <span class="s2">&quot;arcsin&quot;</span><span class="p">,</span> <span class="s2">&quot;arccos&quot;</span><span class="p">,</span> <span class="s2">&quot;arctan&quot;</span><span class="p">,</span> <span class="s2">&quot;logit&quot;</span><span class="p">,</span> <span class="s2">&quot;inverse_logit&quot;</span><span class="p">]</span>
    <span class="n">precedence</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;log&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;abs&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;floor&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;ceil&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;round&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;sin&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;cos&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;tan&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;arcsin&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;arccos&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;arctan&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;logit&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;inverse_logit&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">subexpr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">func_type</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;exp&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Log</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Abs</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;floor&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Floor</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;ceil&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Ceil</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;round&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Round</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;sin&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Sin</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;cos&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Cos</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;tan&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tan</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;arcsin&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Arcsin</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;arccos&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Arccos</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;arctan&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Arctan</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;logit&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Logit</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;inverse_logit&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">InverseLogit</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Distributions</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build distributions.</span>
<span class="sd">    Currently supported distributions are:</span>
<span class="sd">    `ops.Normal`, `ops.BernoulliLogit`, `ops.LogNormal`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="s2">&quot;bernoulli_logit&quot;</span><span class="p">,</span> <span class="s2">&quot;log_normal&quot;</span><span class="p">,</span> <span class="s2">&quot;cauchy&quot;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">dist_type</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">expressions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;normal distribution needs 2 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Normal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;bernoulli_logit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bernoulli_logit distribution needs 1 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BernoulliLogit</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;log_normal&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;log_normal distribution needs 2 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">LogNormal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;cauchy&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cauchy distribution needs 2 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Cauchy</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">ParseError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">code_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">line_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">column_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">code_string</span> <span class="o">=</span> <span class="n">code_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="n">line_num</span><span class="p">]</span>
        <span class="n">exception_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;An error occured while parsing the following line(</span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">column_num</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="si">{</span><span class="n">code_string</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">column_num</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exception_message</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Parser</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The parser for rat is a modified Pratt parser.</span>
<span class="sd">    Since rat programs are defined within the context of data, the parser needs to know</span>
<span class="sd">    the column names of the data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span> <span class="n">data_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">model_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the parser</span>
<span class="sd">        :param tokens: A list of `scanner.Token`. This should be the output format of `scanner.scanner`</span>
<span class="sd">        :param data_names: A list of data column names</span>
<span class="sd">        :param model_string: Optional. The original model code string. If supplied, used to generate detailed errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_tree</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span> <span class="o">=</span> <span class="n">data_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span> <span class="o">=</span> <span class="n">model_string</span>

    <span class="k">def</span> <span class="nf">check_bracket_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bracket_stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span><span class="p">):</span>
                <span class="n">bracket_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bracket_stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Found unmatching brackets!!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">bracket_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;{&quot;</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Found unmatching brackets!!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bracket_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">bracket_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Found unmatching brackets!!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        k-token lookahead. Returns `scanner.NullToken` if there are no tokens in the token stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">NullToken</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expect_token</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">token_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]]],</span>
        <span class="n">token_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">remove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lookahead</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the next token in the token stack is of designated type and value. If not, raise an Exception.</span>
<span class="sd">        :param token_types: A list of `scanner.Token` types or a single `scanner.Token` type that&#39;s allowed.</span>
<span class="sd">        :param token_value: A single or a list of allowed token value strings</span>
<span class="sd">        :param remove: Boolean, whether to remove the token after checking or not. Defaults to False</span>
<span class="sd">        :param lookahead: lookahead. Defaults to 0(immediate token)</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">lookahead</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">token_value</span><span class="p">:</span>
            <span class="n">token_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">next_token</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">token_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">token_value</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token_types</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">token_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">token_types</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">token_type</span> <span class="ow">in</span> <span class="n">token_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_token</span><span class="p">,</span> <span class="n">token_type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">token_value</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">remove</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected token type(s) </span><span class="si">{</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">token_types</span><span class="p">]</span><span class="si">}</span><span class="s2"> with value in </span><span class="si">{</span><span class="n">token_value</span><span class="si">}</span><span class="s2">, but received </span><span class="si">{</span><span class="n">next_token</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with value &#39;</span><span class="si">{</span><span class="n">next_token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;!&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
            <span class="n">next_token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
            <span class="n">next_token</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry_token_value</span><span class="p">,</span> <span class="n">allow_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        expressions are used to evaluate repeated, comma-separeted expressions in the form &quot;expr, expr, expr&quot;</span>
<span class="sd">        It&#39;s primarily used to evaluate subscripts or function arguments. In the case it&#39;s evaluating subscripts, it</span>
<span class="sd">        will also return the shift amounts of each subscript.</span>
<span class="sd">        :param entry_token_value: A single character which denotes the boundary token that starts the expression</span>
<span class="sd">        sequence. For example, &quot;myFunc(expr1, expr2, expr3)&quot; would mean the 3-expression sequence is present between the</span>
<span class="sd">        parantheses. So the entry token would be &quot;(&quot; and exit token &quot;)&quot;.</span>
<span class="sd">        For subscripts, it would be something like &quot;my_variable[sub_1, shift(sub_2, 1)]. That would mean entry token</span>
<span class="sd">        &quot;[&quot; and exit token &quot;]&quot;.</span>
<span class="sd">        :param allow_shift: This is for a quick sanity check that checks whether shift() is allowed to be used within</span>
<span class="sd">        the expression sequence.</span>
<span class="sd">        :return: A Tuple of length 2, with the first value being a list of expressions, and second value being a Tuple</span>
<span class="sd">        of integers denoting shift amounts, if any.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">entry_token_value</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span>
            <span class="n">exit_value</span> <span class="o">=</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">elif</span> <span class="n">entry_token_value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
            <span class="n">exit_value</span> <span class="o">=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expresions() received invalid entry token value with value </span><span class="si">{</span><span class="n">entry_token_value</span><span class="si">}</span><span class="s2">, but expected &#39;[&#39; or &#39;]&#39;&quot;</span><span class="p">)</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shift_amounts</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># integer specifying the amount to shift for each index</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="n">shift_amount</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="p">(</span><span class="n">exit_value</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">exit_value</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character ,</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;shift&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_shift</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                        <span class="s2">&quot;shift() has been used in a position that is not allowed.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span>
                    <span class="p">)</span>
                <span class="c1"># parse lag(index, integer)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># identifier &quot;shift&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Identifier</span><span class="p">)</span>  <span class="c1"># index name</span>
                <span class="n">subscript_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">subscript_name</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                        <span class="s2">&quot;Index specified with shift() must be in data columns.&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
                        <span class="n">subscript_name</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                        <span class="n">subscript_name</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">subscript_name</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># index name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character ,</span>
                <span class="n">shift_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="n">shift_amount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">shift_amount</span><span class="o">.</span><span class="n">code</span><span class="p">()))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character )</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
            <span class="n">expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
            <span class="n">shift_amounts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift_amount</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expressions</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shift_amounts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_nud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_lhs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">RealLiteral</span><span class="p">):</span>  <span class="c1"># if just a real number, return it</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">RealConstant</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># real</span>
            <span class="k">return</span> <span class="n">exp</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>  <span class="c1"># if just an integer, return it</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">IntegerConstant</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># integer</span>
            <span class="k">return</span> <span class="n">exp</span>

        <span class="k">elif</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># prefixOp expression</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>  <span class="c1"># operator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

            <span class="n">next_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">(</span><span class="n">PrefixOps</span><span class="o">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">next_expression</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">exp</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># unaryFunction &#39;(&#39; expression &#39;)&#39;</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="n">token</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># functionName</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">exp</span>

            <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span><span class="p">:</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># identifier</span>
            <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;A distribution has been found in an expressions&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_param</span><span class="p">(</span><span class="n">is_lhs</span><span class="o">=</span><span class="n">is_lhs</span><span class="p">)</span>

            <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span>
                <span class="c1"># identifier &#39;[&#39; subscript_expressions &#39;]&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># [</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Parser: subscripts are assumed to be a single literal, not expression.&quot;</span><span class="p">)</span>
                <span class="n">expressions</span><span class="p">,</span> <span class="n">shift_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expressions</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="n">allow_shift</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># list of expression</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># ]</span>
                <span class="c1"># Assume index is a single identifier - this is NOT GOOD</span>
                <span class="n">exp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span>
                    <span class="n">names</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">),</span>
                    <span class="n">shifts</span><span class="o">=</span><span class="n">shift_amount</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">exp</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>  <span class="c1"># ( expression )</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
            <span class="k">return</span> <span class="n">exp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> can&#39;t be in the beginning of a construct!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_lhs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Identifier</span><span class="p">)</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># identifier</span>

        <span class="c1"># check for constraints  param&lt;lower = 0.0, upper = 1.0&gt;</span>
        <span class="c1"># 3-token lookahead: &quot;&lt;&quot; + &quot;lower&quot; or &quot;upper&quot;</span>
        <span class="n">lookahead_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>  <span class="c1"># &lt;</span>
        <span class="n">lookahead_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># lower, upper</span>
        <span class="k">if</span> <span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span> <span class="ow">and</span> <span class="n">lookahead_2</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;lower&quot;</span><span class="p">,</span>
            <span class="s2">&quot;upper&quot;</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_lhs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                    <span class="s2">&quot;Constraints for parameters/variables are only allowed on LHS.&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
                    <span class="n">lookahead_1</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                    <span class="n">lookahead_1</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &lt;</span>
            <span class="c1"># the problem is that &quot;&gt;&quot; is considered as an operator, but in the case of constraints, it is</span>
            <span class="c1"># not an operator, but a delimeter denoting the end of the constraint region.</span>
            <span class="c1"># Therefore, we need to find the matching &quot;&gt;&quot; and change it from operator type to special, so</span>
            <span class="c1"># the expression parser does not think of it as a &quot;greater than&quot; operator. This goes away from</span>
            <span class="c1"># the ll(k) approach and therefore is a very hacky way to fix the issue.</span>
            <span class="n">n_openbrackets</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
                    <span class="n">n_openbrackets</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n_openbrackets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># switch from Operator to Special</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Special</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">n_openbrackets</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># now actually parse the constraints</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">RealConstant</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">))</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">RealConstant</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="c1"># loop at max 2 times, once for lower, once for upper</span>
                <span class="k">if</span> <span class="n">lookahead_2</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &quot;lower&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">token_value</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># =</span>
                    <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">lookahead_2</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &quot;upper&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">token_value</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># =</span>
                    <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>

                <span class="n">lookahead_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="c1"># can be either &quot;,&quot;, which means loop again, or &quot;&gt;&quot;, which breaks</span>
                <span class="n">lookahead_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># either &quot;lower&quot;, or &quot;upper&quot; if lookahead_1 == &quot;,&quot;</span>
                <span class="k">if</span> <span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># ,</span>
                <span class="k">elif</span> <span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &gt;</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Found unknown token with value </span><span class="si">{</span><span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> when evaluating constraints&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
                        <span class="n">lookahead_1</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                        <span class="n">lookahead_1</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># the for loop takes of the portion &quot;&lt;lower= ... &gt;</span>
            <span class="c1"># this means the constraint part of been processed and</span>
            <span class="c1"># removed from the token queue at this point</span>
            <span class="n">exp</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span>
            <span class="n">exp</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span>

        <span class="k">return</span> <span class="n">exp</span>

    <span class="k">def</span> <span class="nf">expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_precedence</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_lhs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to evaluate an expression. Please refer to the BNF grammer to see what types of</span>
<span class="sd">        rules are being applied.</span>
<span class="sd">        :param min_precedence: Minimum precedence value to evaluate</span>
<span class="sd">        :return: An `ops.Expr` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_nud</span><span class="p">(</span><span class="n">is_lhs</span><span class="o">=</span><span class="n">is_lhs</span><span class="p">)</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">NullToken</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>  <span class="c1"># &#39;(&#39; expression &#39;)&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                <span class="n">next_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>  <span class="c1"># )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">next_expression</span>  <span class="c1"># expression</span>

            <span class="k">elif</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># expression infixOps expression</span>
                <span class="k">if</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">min_precedence</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># op</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">(</span><span class="n">InfixOps</span><span class="o">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># unaryFunction &#39;(&#39; expression &#39;)&#39;</span>
                    <span class="n">func_name</span> <span class="o">=</span> <span class="n">token</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># functionName</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                    <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown token &#39;</span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">exp</span>

        <span class="k">return</span> <span class="n">left</span>

    <span class="k">def</span> <span class="nf">statement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates a single statement. Statements in rat are either assignments or sampling statements. They will get</span>
<span class="sd">        resolved into an `ops.Assignment` or an `ops.Distr` object.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_bracket_stack</span><span class="p">()</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Cannot assign to a distribution.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

        <span class="c1"># Step 1. evaluate lhs, assume it&#39;s expression</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_nud</span><span class="p">(</span><span class="n">is_lhs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># if isinstance(lhs, Param) or isinstance(lhs, Data):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">AssignmentOps</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># assignment operator</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">AssignmentOps</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;~&quot;</span><span class="p">:</span>
                <span class="c1"># distribution declaration</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;~&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># ~</span>
                <span class="n">distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Identifier</span><span class="p">,</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># distribution</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                <span class="n">expressions</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expressions</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span>  <span class="c1"># list of expression</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                <span class="k">return</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown operator &#39;</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; in statement&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Expr</span><span class="p">()</span>
</pre></div>

        </details>

            </section>
                <section id="PrefixOps">
                                <div class="attr class">
        <a class="headerlink" href="#PrefixOps">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PrefixOps</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PrefixOps</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build prefix-operation expressions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;!&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">]</span>
    <span class="n">precedence</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;!&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Token</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">tok</span><span class="p">:</span> <span class="n">Operator</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;!&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PrefixLogicalNegation</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PrefixNegation</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A utility class that's used to identify and build prefix-operation expressions.</p>
</div>


                            <div id="PrefixOps.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PrefixOps.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PrefixOps</span><span class="signature">()</span>
    </div>

        
    

                            </div>
                            <div id="PrefixOps.ops" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#PrefixOps.ops">#&nbsp;&nbsp</a>

        <span class="name">ops</span><span class="default_value"> = [&#39;!&#39;, &#39;-&#39;]</span>
    </div>

    

                            </div>
                            <div id="PrefixOps.precedence" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#PrefixOps.precedence">#&nbsp;&nbsp</a>

        <span class="name">precedence</span><span class="default_value"> = {&#39;!&#39;: 50, &#39;-&#39;: 50}</span>
    </div>

    

                            </div>
                            <div id="PrefixOps.check" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PrefixOps.check">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">check</span><span class="signature">(tok: <a href="scanner.html#Token">rat.scanner.Token</a>)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Token</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PrefixOps.generate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PrefixOps.generate">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate</span><span class="signature">(expr: <a href="ops.html#Expr">rat.ops.Expr</a>, tok: <a href="scanner.html#Operator">rat.scanner.Operator</a>)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">tok</span><span class="p">:</span> <span class="n">Operator</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;!&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PrefixLogicalNegation</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PrefixNegation</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="PostfixOps">
                                <div class="attr class">
        <a class="headerlink" href="#PostfixOps">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PostfixOps</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PostfixOps</span><span class="p">:</span>  <span class="c1"># not used atm</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&#39;&quot;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Token</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">PostfixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

        </details>

    

                            <div id="PostfixOps.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PostfixOps.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PostfixOps</span><span class="signature">()</span>
    </div>

        
    

                            </div>
                            <div id="PostfixOps.ops" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#PostfixOps.ops">#&nbsp;&nbsp</a>

        <span class="name">ops</span><span class="default_value"> = [&#34;&#39;&#34;]</span>
    </div>

    

                            </div>
                            <div id="PostfixOps.check" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PostfixOps.check">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">check</span><span class="signature">(tok: <a href="scanner.html#Token">rat.scanner.Token</a>)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Token</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">PostfixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="InfixOps">
                                <div class="attr class">
        <a class="headerlink" href="#InfixOps">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">InfixOps</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">InfixOps</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build binary operation expressions.</span>
<span class="sd">    Currently supported operations are:</span>
<span class="sd">    `ops.Sum`, `ops.Diff`, `ops.Mul`, `ops.Pow`, `ops.Mod`, `ops.Div`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;%&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">]</span>
    <span class="n">precedence</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Diff</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Div</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mod</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LessThan</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GreaterThan</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;InfixOps: Unknown operator type </span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A utility class that's used to identify and build binary operation expressions.
Currently supported operations are:
<code>ops.Sum</code>, <code>ops.Diff</code>, <code>ops.Mul</code>, <code>ops.Pow</code>, <code>ops.Mod</code>, <code>ops.Div</code></p>
</div>


                            <div id="InfixOps.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#InfixOps.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">InfixOps</span><span class="signature">()</span>
    </div>

        
    

                            </div>
                            <div id="InfixOps.ops" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#InfixOps.ops">#&nbsp;&nbsp</a>

        <span class="name">ops</span><span class="default_value"> = [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;^&#39;, &#39;/&#39;, &#39;%&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;]</span>
    </div>

    

                            </div>
                            <div id="InfixOps.precedence" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#InfixOps.precedence">#&nbsp;&nbsp</a>

        <span class="name">precedence</span><span class="default_value"> = {&#39;+&#39;: 10, &#39;-&#39;: 10, &#39;*&#39;: 30, &#39;/&#39;: 30, &#39;^&#39;: 40, &#39;%&#39;: 30, &#39;&lt;&#39;: 5, &#39;&gt;&#39;: 5}</span>
    </div>

    

                            </div>
                            <div id="InfixOps.check" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#InfixOps.check">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">check</span><span class="signature">(tok: Type[<a href="scanner.html#Token">rat.scanner.Token</a>])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="InfixOps.generate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#InfixOps.generate">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate</span><span class="signature">(lhs: <a href="ops.html#Expr">rat.ops.Expr</a>, rhs: <a href="ops.html#Expr">rat.ops.Expr</a>, token: Type[<a href="scanner.html#Token">rat.scanner.Token</a>])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Diff</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Div</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mod</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LessThan</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GreaterThan</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;InfixOps: Unknown operator type </span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="AssignmentOps">
                                <div class="attr class">
        <a class="headerlink" href="#AssignmentOps">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">AssignmentOps</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">AssignmentOps</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build assignments in statements.</span>
<span class="sd">    Currently supports the following assignment types:</span>
<span class="sd">    `ops.Assignment`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;=&quot;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">AssignmentOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="c1"># check() has been ran for operator</span>
        <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;=&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Assignment</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A utility class that's used to identify and build assignments in statements.
Currently supports the following assignment types:
<code>ops.Assignment</code></p>
</div>


                            <div id="AssignmentOps.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#AssignmentOps.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">AssignmentOps</span><span class="signature">()</span>
    </div>

        
    

                            </div>
                            <div id="AssignmentOps.ops" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#AssignmentOps.ops">#&nbsp;&nbsp</a>

        <span class="name">ops</span><span class="default_value"> = [&#39;=&#39;]</span>
    </div>

    

                            </div>
                            <div id="AssignmentOps.check" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#AssignmentOps.check">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">check</span><span class="signature">(tok: Type[<a href="scanner.html#Token">rat.scanner.Token</a>])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">AssignmentOps</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="AssignmentOps.generate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#AssignmentOps.generate">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate</span><span class="signature">(lhs: <a href="ops.html#Expr">rat.ops.Expr</a>, operator: <a href="scanner.html#Operator">rat.scanner.Operator</a>, rhs: <a href="ops.html#Expr">rat.ops.Expr</a>)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="c1"># check() has been ran for operator</span>
        <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;=&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Assignment</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="UnaryFunctions">
                                <div class="attr class">
        <a class="headerlink" href="#UnaryFunctions">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">UnaryFunctions</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">UnaryFunctions</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build unary functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="s2">&quot;abs&quot;</span><span class="p">,</span> <span class="s2">&quot;floor&quot;</span><span class="p">,</span> <span class="s2">&quot;ceil&quot;</span><span class="p">,</span> <span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="s2">&quot;sin&quot;</span><span class="p">,</span> <span class="s2">&quot;cos&quot;</span><span class="p">,</span> <span class="s2">&quot;tan&quot;</span><span class="p">,</span> <span class="s2">&quot;arcsin&quot;</span><span class="p">,</span> <span class="s2">&quot;arccos&quot;</span><span class="p">,</span> <span class="s2">&quot;arctan&quot;</span><span class="p">,</span> <span class="s2">&quot;logit&quot;</span><span class="p">,</span> <span class="s2">&quot;inverse_logit&quot;</span><span class="p">]</span>
    <span class="n">precedence</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;log&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;abs&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;floor&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;ceil&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;round&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;sin&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;cos&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;tan&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;arcsin&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;arccos&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;arctan&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;logit&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;inverse_logit&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">subexpr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">func_type</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;exp&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Log</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Abs</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;floor&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Floor</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;ceil&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Ceil</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;round&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Round</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;sin&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Sin</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;cos&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Cos</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;tan&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tan</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;arcsin&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Arcsin</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;arccos&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Arccos</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;arctan&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Arctan</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;logit&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Logit</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;inverse_logit&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">InverseLogit</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A utility class that's used to identify and build unary functions.</p>
</div>


                            <div id="UnaryFunctions.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#UnaryFunctions.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">UnaryFunctions</span><span class="signature">()</span>
    </div>

        
    

                            </div>
                            <div id="UnaryFunctions.names" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#UnaryFunctions.names">#&nbsp;&nbsp</a>

        <span class="name">names</span><span class="default_value"> = [&#39;exp&#39;, &#39;log&#39;, &#39;abs&#39;, &#39;floor&#39;, &#39;ceil&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;cos&#39;, &#39;tan&#39;, &#39;arcsin&#39;, &#39;arccos&#39;, &#39;arctan&#39;, &#39;logit&#39;, &#39;inverse_logit&#39;]</span>
    </div>

    

                            </div>
                            <div id="UnaryFunctions.precedence" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#UnaryFunctions.precedence">#&nbsp;&nbsp</a>

        <span class="name">precedence</span><span class="default_value"> = {&#39;exp&#39;: 100, &#39;log&#39;: 100, &#39;abs&#39;: 100, &#39;floor&#39;: 100, &#39;ceil&#39;: 100, &#39;round&#39;: 100, &#39;sin&#39;: 100, &#39;cos&#39;: 100, &#39;tan&#39;: 100, &#39;arcsin&#39;: 100, &#39;arccos&#39;: 100, &#39;arctan&#39;: 100, &#39;logit&#39;: 100, &#39;inverse_logit&#39;: 100}</span>
    </div>

    

                            </div>
                            <div id="UnaryFunctions.check" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#UnaryFunctions.check">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">check</span><span class="signature">(tok: Type[<a href="scanner.html#Token">rat.scanner.Token</a>])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="UnaryFunctions.generate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#UnaryFunctions.generate">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate</span><span class="signature">(subexpr: <a href="ops.html#Expr">rat.ops.Expr</a>, func_type: <a href="scanner.html#Identifier">rat.scanner.Identifier</a>)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">subexpr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">func_type</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;exp&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Log</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Abs</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;floor&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Floor</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;ceil&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Ceil</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;round&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Round</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;sin&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Sin</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;cos&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Cos</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;tan&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tan</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;arcsin&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Arcsin</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;arccos&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Arccos</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;arctan&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Arctan</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;logit&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Logit</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">func_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;inverse_logit&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">InverseLogit</span><span class="p">(</span><span class="n">subexpr</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="Distributions">
                                <div class="attr class">
        <a class="headerlink" href="#Distributions">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Distributions</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Distributions</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class that&#39;s used to identify and build distributions.</span>
<span class="sd">    Currently supported distributions are:</span>
<span class="sd">    `ops.Normal`, `ops.BernoulliLogit`, `ops.LogNormal`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="s2">&quot;bernoulli_logit&quot;</span><span class="p">,</span> <span class="s2">&quot;log_normal&quot;</span><span class="p">,</span> <span class="s2">&quot;cauchy&quot;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">dist_type</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">expressions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;normal distribution needs 2 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Normal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;bernoulli_logit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bernoulli_logit distribution needs 1 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BernoulliLogit</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;log_normal&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;log_normal distribution needs 2 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">LogNormal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;cauchy&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cauchy distribution needs 2 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Cauchy</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>A utility class that's used to identify and build distributions.
Currently supported distributions are:
<code>ops.Normal</code>, <code>ops.BernoulliLogit</code>, <code>ops.LogNormal</code></p>
</div>


                            <div id="Distributions.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Distributions.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Distributions</span><span class="signature">()</span>
    </div>

        
    

                            </div>
                            <div id="Distributions.names" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Distributions.names">#&nbsp;&nbsp</a>

        <span class="name">names</span><span class="default_value"> = [&#39;normal&#39;, &#39;bernoulli_logit&#39;, &#39;log_normal&#39;, &#39;cauchy&#39;]</span>
    </div>

    

                            </div>
                            <div id="Distributions.check" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Distributions.check">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">check</span><span class="signature">(tok: Type[<a href="scanner.html#Token">rat.scanner.Token</a>])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">tok</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Distributions.generate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Distributions.generate">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate</span><span class="signature">(
    dist_type: <a href="scanner.html#Identifier">rat.scanner.Identifier</a>,
    lhs: <a href="ops.html#Expr">rat.ops.Expr</a>,
    expressions: List[<a href="ops.html#Expr">rat.ops.Expr</a>]
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">dist_type</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">expressions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;normal distribution needs 2 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Normal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;bernoulli_logit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bernoulli_logit distribution needs 1 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BernoulliLogit</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;log_normal&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;log_normal distribution needs 2 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">LogNormal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">dist_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;cauchy&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cauchy distribution needs 2 parameters, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Cauchy</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="ParseError">
                                <div class="attr class">
        <a class="headerlink" href="#ParseError">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ParseError</span><wbr>(<span class="base">builtins.Exception</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ParseError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">code_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">line_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">column_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">code_string</span> <span class="o">=</span> <span class="n">code_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="n">line_num</span><span class="p">]</span>
        <span class="n">exception_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;An error occured while parsing the following line(</span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">column_num</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="si">{</span><span class="n">code_string</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">column_num</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exception_message</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Common base class for all non-exit exceptions.</p>
</div>


                            <div id="ParseError.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ParseError.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ParseError</span><span class="signature">(message, code_string: str, line_num: int, column_num: int)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">code_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">line_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">column_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">code_string</span> <span class="o">=</span> <span class="n">code_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="n">line_num</span><span class="p">]</span>
        <span class="n">exception_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;An error occured while parsing the following line(</span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">column_num</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="si">{</span><span class="n">code_string</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">column_num</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exception_message</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.BaseException</dt>
                                <dd id="ParseError.with_traceback" class="function">with_traceback</dd>
                <dd id="ParseError.args" class="variable">args</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="Parser">
                                <div class="attr class">
        <a class="headerlink" href="#Parser">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Parser</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Parser</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The parser for rat is a modified Pratt parser.</span>
<span class="sd">    Since rat programs are defined within the context of data, the parser needs to know</span>
<span class="sd">    the column names of the data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span> <span class="n">data_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">model_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the parser</span>
<span class="sd">        :param tokens: A list of `scanner.Token`. This should be the output format of `scanner.scanner`</span>
<span class="sd">        :param data_names: A list of data column names</span>
<span class="sd">        :param model_string: Optional. The original model code string. If supplied, used to generate detailed errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_tree</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span> <span class="o">=</span> <span class="n">data_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span> <span class="o">=</span> <span class="n">model_string</span>

    <span class="k">def</span> <span class="nf">check_bracket_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bracket_stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span><span class="p">):</span>
                <span class="n">bracket_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bracket_stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Found unmatching brackets!!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">bracket_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;{&quot;</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Found unmatching brackets!!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bracket_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">bracket_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Found unmatching brackets!!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        k-token lookahead. Returns `scanner.NullToken` if there are no tokens in the token stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">NullToken</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expect_token</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">token_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]]],</span>
        <span class="n">token_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">remove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lookahead</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the next token in the token stack is of designated type and value. If not, raise an Exception.</span>
<span class="sd">        :param token_types: A list of `scanner.Token` types or a single `scanner.Token` type that&#39;s allowed.</span>
<span class="sd">        :param token_value: A single or a list of allowed token value strings</span>
<span class="sd">        :param remove: Boolean, whether to remove the token after checking or not. Defaults to False</span>
<span class="sd">        :param lookahead: lookahead. Defaults to 0(immediate token)</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">lookahead</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">token_value</span><span class="p">:</span>
            <span class="n">token_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">next_token</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">token_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">token_value</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token_types</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">token_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">token_types</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">token_type</span> <span class="ow">in</span> <span class="n">token_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_token</span><span class="p">,</span> <span class="n">token_type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">token_value</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">remove</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected token type(s) </span><span class="si">{</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">token_types</span><span class="p">]</span><span class="si">}</span><span class="s2"> with value in </span><span class="si">{</span><span class="n">token_value</span><span class="si">}</span><span class="s2">, but received </span><span class="si">{</span><span class="n">next_token</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with value &#39;</span><span class="si">{</span><span class="n">next_token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;!&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
            <span class="n">next_token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
            <span class="n">next_token</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry_token_value</span><span class="p">,</span> <span class="n">allow_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        expressions are used to evaluate repeated, comma-separeted expressions in the form &quot;expr, expr, expr&quot;</span>
<span class="sd">        It&#39;s primarily used to evaluate subscripts or function arguments. In the case it&#39;s evaluating subscripts, it</span>
<span class="sd">        will also return the shift amounts of each subscript.</span>
<span class="sd">        :param entry_token_value: A single character which denotes the boundary token that starts the expression</span>
<span class="sd">        sequence. For example, &quot;myFunc(expr1, expr2, expr3)&quot; would mean the 3-expression sequence is present between the</span>
<span class="sd">        parantheses. So the entry token would be &quot;(&quot; and exit token &quot;)&quot;.</span>
<span class="sd">        For subscripts, it would be something like &quot;my_variable[sub_1, shift(sub_2, 1)]. That would mean entry token</span>
<span class="sd">        &quot;[&quot; and exit token &quot;]&quot;.</span>
<span class="sd">        :param allow_shift: This is for a quick sanity check that checks whether shift() is allowed to be used within</span>
<span class="sd">        the expression sequence.</span>
<span class="sd">        :return: A Tuple of length 2, with the first value being a list of expressions, and second value being a Tuple</span>
<span class="sd">        of integers denoting shift amounts, if any.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">entry_token_value</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span>
            <span class="n">exit_value</span> <span class="o">=</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">elif</span> <span class="n">entry_token_value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
            <span class="n">exit_value</span> <span class="o">=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expresions() received invalid entry token value with value </span><span class="si">{</span><span class="n">entry_token_value</span><span class="si">}</span><span class="s2">, but expected &#39;[&#39; or &#39;]&#39;&quot;</span><span class="p">)</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shift_amounts</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># integer specifying the amount to shift for each index</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="n">shift_amount</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="p">(</span><span class="n">exit_value</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">exit_value</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character ,</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;shift&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_shift</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                        <span class="s2">&quot;shift() has been used in a position that is not allowed.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span>
                    <span class="p">)</span>
                <span class="c1"># parse lag(index, integer)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># identifier &quot;shift&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Identifier</span><span class="p">)</span>  <span class="c1"># index name</span>
                <span class="n">subscript_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">subscript_name</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                        <span class="s2">&quot;Index specified with shift() must be in data columns.&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
                        <span class="n">subscript_name</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                        <span class="n">subscript_name</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">subscript_name</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># index name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character ,</span>
                <span class="n">shift_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="n">shift_amount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">shift_amount</span><span class="o">.</span><span class="n">code</span><span class="p">()))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character )</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
            <span class="n">expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
            <span class="n">shift_amounts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift_amount</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expressions</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shift_amounts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_nud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_lhs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">RealLiteral</span><span class="p">):</span>  <span class="c1"># if just a real number, return it</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">RealConstant</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># real</span>
            <span class="k">return</span> <span class="n">exp</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>  <span class="c1"># if just an integer, return it</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">IntegerConstant</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># integer</span>
            <span class="k">return</span> <span class="n">exp</span>

        <span class="k">elif</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># prefixOp expression</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>  <span class="c1"># operator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

            <span class="n">next_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">(</span><span class="n">PrefixOps</span><span class="o">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">next_expression</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">exp</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># unaryFunction &#39;(&#39; expression &#39;)&#39;</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="n">token</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># functionName</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">exp</span>

            <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span><span class="p">:</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># identifier</span>
            <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;A distribution has been found in an expressions&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_param</span><span class="p">(</span><span class="n">is_lhs</span><span class="o">=</span><span class="n">is_lhs</span><span class="p">)</span>

            <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span>
                <span class="c1"># identifier &#39;[&#39; subscript_expressions &#39;]&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># [</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Parser: subscripts are assumed to be a single literal, not expression.&quot;</span><span class="p">)</span>
                <span class="n">expressions</span><span class="p">,</span> <span class="n">shift_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expressions</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="n">allow_shift</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># list of expression</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># ]</span>
                <span class="c1"># Assume index is a single identifier - this is NOT GOOD</span>
                <span class="n">exp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span>
                    <span class="n">names</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">),</span>
                    <span class="n">shifts</span><span class="o">=</span><span class="n">shift_amount</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">exp</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>  <span class="c1"># ( expression )</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
            <span class="k">return</span> <span class="n">exp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> can&#39;t be in the beginning of a construct!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_lhs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Identifier</span><span class="p">)</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># identifier</span>

        <span class="c1"># check for constraints  param&lt;lower = 0.0, upper = 1.0&gt;</span>
        <span class="c1"># 3-token lookahead: &quot;&lt;&quot; + &quot;lower&quot; or &quot;upper&quot;</span>
        <span class="n">lookahead_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>  <span class="c1"># &lt;</span>
        <span class="n">lookahead_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># lower, upper</span>
        <span class="k">if</span> <span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span> <span class="ow">and</span> <span class="n">lookahead_2</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;lower&quot;</span><span class="p">,</span>
            <span class="s2">&quot;upper&quot;</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_lhs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                    <span class="s2">&quot;Constraints for parameters/variables are only allowed on LHS.&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
                    <span class="n">lookahead_1</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                    <span class="n">lookahead_1</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &lt;</span>
            <span class="c1"># the problem is that &quot;&gt;&quot; is considered as an operator, but in the case of constraints, it is</span>
            <span class="c1"># not an operator, but a delimeter denoting the end of the constraint region.</span>
            <span class="c1"># Therefore, we need to find the matching &quot;&gt;&quot; and change it from operator type to special, so</span>
            <span class="c1"># the expression parser does not think of it as a &quot;greater than&quot; operator. This goes away from</span>
            <span class="c1"># the ll(k) approach and therefore is a very hacky way to fix the issue.</span>
            <span class="n">n_openbrackets</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
                    <span class="n">n_openbrackets</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n_openbrackets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># switch from Operator to Special</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Special</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">n_openbrackets</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># now actually parse the constraints</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">RealConstant</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">))</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">RealConstant</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="c1"># loop at max 2 times, once for lower, once for upper</span>
                <span class="k">if</span> <span class="n">lookahead_2</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &quot;lower&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">token_value</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># =</span>
                    <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">lookahead_2</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &quot;upper&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">token_value</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># =</span>
                    <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>

                <span class="n">lookahead_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="c1"># can be either &quot;,&quot;, which means loop again, or &quot;&gt;&quot;, which breaks</span>
                <span class="n">lookahead_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># either &quot;lower&quot;, or &quot;upper&quot; if lookahead_1 == &quot;,&quot;</span>
                <span class="k">if</span> <span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># ,</span>
                <span class="k">elif</span> <span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &gt;</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Found unknown token with value </span><span class="si">{</span><span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> when evaluating constraints&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
                        <span class="n">lookahead_1</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                        <span class="n">lookahead_1</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># the for loop takes of the portion &quot;&lt;lower= ... &gt;</span>
            <span class="c1"># this means the constraint part of been processed and</span>
            <span class="c1"># removed from the token queue at this point</span>
            <span class="n">exp</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span>
            <span class="n">exp</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span>

        <span class="k">return</span> <span class="n">exp</span>

    <span class="k">def</span> <span class="nf">expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_precedence</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_lhs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to evaluate an expression. Please refer to the BNF grammer to see what types of</span>
<span class="sd">        rules are being applied.</span>
<span class="sd">        :param min_precedence: Minimum precedence value to evaluate</span>
<span class="sd">        :return: An `ops.Expr` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_nud</span><span class="p">(</span><span class="n">is_lhs</span><span class="o">=</span><span class="n">is_lhs</span><span class="p">)</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">NullToken</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>  <span class="c1"># &#39;(&#39; expression &#39;)&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                <span class="n">next_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>  <span class="c1"># )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">next_expression</span>  <span class="c1"># expression</span>

            <span class="k">elif</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># expression infixOps expression</span>
                <span class="k">if</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">min_precedence</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># op</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">(</span><span class="n">InfixOps</span><span class="o">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># unaryFunction &#39;(&#39; expression &#39;)&#39;</span>
                    <span class="n">func_name</span> <span class="o">=</span> <span class="n">token</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># functionName</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                    <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown token &#39;</span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">exp</span>

        <span class="k">return</span> <span class="n">left</span>

    <span class="k">def</span> <span class="nf">statement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates a single statement. Statements in rat are either assignments or sampling statements. They will get</span>
<span class="sd">        resolved into an `ops.Assignment` or an `ops.Distr` object.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_bracket_stack</span><span class="p">()</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Cannot assign to a distribution.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

        <span class="c1"># Step 1. evaluate lhs, assume it&#39;s expression</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_nud</span><span class="p">(</span><span class="n">is_lhs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># if isinstance(lhs, Param) or isinstance(lhs, Data):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">AssignmentOps</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># assignment operator</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">AssignmentOps</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;~&quot;</span><span class="p">:</span>
                <span class="c1"># distribution declaration</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;~&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># ~</span>
                <span class="n">distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Identifier</span><span class="p">,</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># distribution</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                <span class="n">expressions</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expressions</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span>  <span class="c1"># list of expression</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                <span class="k">return</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown operator &#39;</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; in statement&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Expr</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>The parser for rat is a modified Pratt parser.
Since rat programs are defined within the context of data, the parser needs to know
the column names of the data.</p>
</div>


                            <div id="Parser.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Parser</span><span class="signature">(
    tokens: List[<a href="scanner.html#Token">rat.scanner.Token</a>],
    data_names: List[str],
    model_string: str = &#39;&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span> <span class="n">data_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">model_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the parser</span>
<span class="sd">        :param tokens: A list of `scanner.Token`. This should be the output format of `scanner.scanner`</span>
<span class="sd">        :param data_names: A list of data column names</span>
<span class="sd">        :param model_string: Optional. The original model code string. If supplied, used to generate detailed errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_tree</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span> <span class="o">=</span> <span class="n">data_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span> <span class="o">=</span> <span class="n">model_string</span>
</pre></div>

        </details>

            <div class="docstring"><p>Initialize the parser
:param tokens: A list of <code>scanner.Token</code>. This should be the output format of <code>scanner.scanner</code>
:param data_names: A list of data column names
:param model_string: Optional. The original model code string. If supplied, used to generate detailed errors.</p>
</div>


                            </div>
                            <div id="Parser.check_bracket_stack" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.check_bracket_stack">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">check_bracket_stack</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">check_bracket_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bracket_stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span><span class="p">):</span>
                <span class="n">bracket_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bracket_stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Found unmatching brackets!!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">bracket_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;{&quot;</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span> <span class="ow">and</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Found unmatching brackets!!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bracket_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">bracket_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Found unmatching brackets!!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Parser.peek" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.peek">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">peek</span><span class="signature">(self, k=0) -&gt; Type[<a href="scanner.html#Token">rat.scanner.Token</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        k-token lookahead. Returns `scanner.NullToken` if there are no tokens in the token stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">NullToken</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>k-token lookahead. Returns <code>scanner.NullToken</code> if there are no tokens in the token stack.</p>
</div>


                            </div>
                            <div id="Parser.remove" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.remove">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove</span><span class="signature">(self, index=0)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Parser.expect_token" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.expect_token">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">expect_token</span><span class="signature">(
    self,
    token_types: Union[Type[<a href="scanner.html#Token">rat.scanner.Token</a>], List[Type[<a href="scanner.html#Token">rat.scanner.Token</a>]]],
    token_value=None,
    remove=False,
    lookahead=0
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">expect_token</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">token_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Token</span><span class="p">]]],</span>
        <span class="n">token_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">remove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lookahead</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the next token in the token stack is of designated type and value. If not, raise an Exception.</span>
<span class="sd">        :param token_types: A list of `scanner.Token` types or a single `scanner.Token` type that&#39;s allowed.</span>
<span class="sd">        :param token_value: A single or a list of allowed token value strings</span>
<span class="sd">        :param remove: Boolean, whether to remove the token after checking or not. Defaults to False</span>
<span class="sd">        :param lookahead: lookahead. Defaults to 0(immediate token)</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">lookahead</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">token_value</span><span class="p">:</span>
            <span class="n">token_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">next_token</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">token_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">token_value</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token_types</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">token_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">token_types</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">token_type</span> <span class="ow">in</span> <span class="n">token_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_token</span><span class="p">,</span> <span class="n">token_type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">token_value</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">remove</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected token type(s) </span><span class="si">{</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">token_types</span><span class="p">]</span><span class="si">}</span><span class="s2"> with value in </span><span class="si">{</span><span class="n">token_value</span><span class="si">}</span><span class="s2">, but received </span><span class="si">{</span><span class="n">next_token</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with value &#39;</span><span class="si">{</span><span class="n">next_token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;!&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
            <span class="n">next_token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
            <span class="n">next_token</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Checks if the next token in the token stack is of designated type and value. If not, raise an Exception.
:param token_types: A list of <code>scanner.Token</code> types or a single <code>scanner.Token</code> type that's allowed.
:param token_value: A single or a list of allowed token value strings
:param remove: Boolean, whether to remove the token after checking or not. Defaults to False
:param lookahead: lookahead. Defaults to 0(immediate token)
:return: None</p>
</div>


                            </div>
                            <div id="Parser.expressions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.expressions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">expressions</span><span class="signature">(
    self,
    entry_token_value,
    allow_shift=False
) -&gt; Tuple[List[<a href="ops.html#Expr">rat.ops.Expr</a>], Tuple[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry_token_value</span><span class="p">,</span> <span class="n">allow_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        expressions are used to evaluate repeated, comma-separeted expressions in the form &quot;expr, expr, expr&quot;</span>
<span class="sd">        It&#39;s primarily used to evaluate subscripts or function arguments. In the case it&#39;s evaluating subscripts, it</span>
<span class="sd">        will also return the shift amounts of each subscript.</span>
<span class="sd">        :param entry_token_value: A single character which denotes the boundary token that starts the expression</span>
<span class="sd">        sequence. For example, &quot;myFunc(expr1, expr2, expr3)&quot; would mean the 3-expression sequence is present between the</span>
<span class="sd">        parantheses. So the entry token would be &quot;(&quot; and exit token &quot;)&quot;.</span>
<span class="sd">        For subscripts, it would be something like &quot;my_variable[sub_1, shift(sub_2, 1)]. That would mean entry token</span>
<span class="sd">        &quot;[&quot; and exit token &quot;]&quot;.</span>
<span class="sd">        :param allow_shift: This is for a quick sanity check that checks whether shift() is allowed to be used within</span>
<span class="sd">        the expression sequence.</span>
<span class="sd">        :return: A Tuple of length 2, with the first value being a list of expressions, and second value being a Tuple</span>
<span class="sd">        of integers denoting shift amounts, if any.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">entry_token_value</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span>
            <span class="n">exit_value</span> <span class="o">=</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">elif</span> <span class="n">entry_token_value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
            <span class="n">exit_value</span> <span class="o">=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expresions() received invalid entry token value with value </span><span class="si">{</span><span class="n">entry_token_value</span><span class="si">}</span><span class="s2">, but expected &#39;[&#39; or &#39;]&#39;&quot;</span><span class="p">)</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shift_amounts</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># integer specifying the amount to shift for each index</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="n">shift_amount</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="p">(</span><span class="n">exit_value</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">exit_value</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character ,</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;shift&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_shift</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                        <span class="s2">&quot;shift() has been used in a position that is not allowed.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span>
                    <span class="p">)</span>
                <span class="c1"># parse lag(index, integer)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># identifier &quot;shift&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Identifier</span><span class="p">)</span>  <span class="c1"># index name</span>
                <span class="n">subscript_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">subscript_name</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                        <span class="s2">&quot;Index specified with shift() must be in data columns.&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
                        <span class="n">subscript_name</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                        <span class="n">subscript_name</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">subscript_name</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># index name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character ,</span>
                <span class="n">shift_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="n">shift_amount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">shift_amount</span><span class="o">.</span><span class="n">code</span><span class="p">()))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># character )</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
            <span class="n">expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
            <span class="n">shift_amounts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift_amount</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expressions</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shift_amounts</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>expressions are used to evaluate repeated, comma-separeted expressions in the form "expr, expr, expr"
It's primarily used to evaluate subscripts or function arguments. In the case it's evaluating subscripts, it
will also return the shift amounts of each subscript.
:param entry_token_value: A single character which denotes the boundary token that starts the expression
sequence. For example, "myFunc(expr1, expr2, expr3)" would mean the 3-expression sequence is present between the
parantheses. So the entry token would be "(" and exit token ")".
For subscripts, it would be something like "my_variable[sub_1, shift(sub_2, 1)]. That would mean entry token
"[" and exit token "]".
:param allow_shift: This is for a quick sanity check that checks whether shift() is allowed to be used within
the expression sequence.
:return: A Tuple of length 2, with the first value being a list of expressions, and second value being a Tuple
of integers denoting shift amounts, if any.</p>
</div>


                            </div>
                            <div id="Parser.parse_nud" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.parse_nud">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">parse_nud</span><span class="signature">(self, is_lhs=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_nud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_lhs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">RealLiteral</span><span class="p">):</span>  <span class="c1"># if just a real number, return it</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">RealConstant</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># real</span>
            <span class="k">return</span> <span class="n">exp</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>  <span class="c1"># if just an integer, return it</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">IntegerConstant</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># integer</span>
            <span class="k">return</span> <span class="n">exp</span>

        <span class="k">elif</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># prefixOp expression</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>  <span class="c1"># operator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

            <span class="n">next_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">(</span><span class="n">PrefixOps</span><span class="o">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">PrefixOps</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">next_expression</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">exp</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># unaryFunction &#39;(&#39; expression &#39;)&#39;</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="n">token</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># functionName</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">exp</span>

            <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span><span class="p">:</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># identifier</span>
            <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;A distribution has been found in an expressions&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_param</span><span class="p">(</span><span class="n">is_lhs</span><span class="o">=</span><span class="n">is_lhs</span><span class="p">)</span>

            <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span>
                <span class="c1"># identifier &#39;[&#39; subscript_expressions &#39;]&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># [</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Parser: subscripts are assumed to be a single literal, not expression.&quot;</span><span class="p">)</span>
                <span class="n">expressions</span><span class="p">,</span> <span class="n">shift_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expressions</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="n">allow_shift</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># list of expression</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># ]</span>
                <span class="c1"># Assume index is a single identifier - this is NOT GOOD</span>
                <span class="n">exp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span>
                    <span class="n">names</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">),</span>
                    <span class="n">shifts</span><span class="o">=</span><span class="n">shift_amount</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">exp</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>  <span class="c1"># ( expression )</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
            <span class="k">return</span> <span class="n">exp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> can&#39;t be in the beginning of a construct!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span>
            <span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Parser.parse_param" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.parse_param">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">parse_param</span><span class="signature">(self, is_lhs=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_lhs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Identifier</span><span class="p">)</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># identifier</span>

        <span class="c1"># check for constraints  param&lt;lower = 0.0, upper = 1.0&gt;</span>
        <span class="c1"># 3-token lookahead: &quot;&lt;&quot; + &quot;lower&quot; or &quot;upper&quot;</span>
        <span class="n">lookahead_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>  <span class="c1"># &lt;</span>
        <span class="n">lookahead_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># lower, upper</span>
        <span class="k">if</span> <span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span> <span class="ow">and</span> <span class="n">lookahead_2</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;lower&quot;</span><span class="p">,</span>
            <span class="s2">&quot;upper&quot;</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_lhs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                    <span class="s2">&quot;Constraints for parameters/variables are only allowed on LHS.&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
                    <span class="n">lookahead_1</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                    <span class="n">lookahead_1</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &lt;</span>
            <span class="c1"># the problem is that &quot;&gt;&quot; is considered as an operator, but in the case of constraints, it is</span>
            <span class="c1"># not an operator, but a delimeter denoting the end of the constraint region.</span>
            <span class="c1"># Therefore, we need to find the matching &quot;&gt;&quot; and change it from operator type to special, so</span>
            <span class="c1"># the expression parser does not think of it as a &quot;greater than&quot; operator. This goes away from</span>
            <span class="c1"># the ll(k) approach and therefore is a very hacky way to fix the issue.</span>
            <span class="n">n_openbrackets</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
                    <span class="n">n_openbrackets</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n_openbrackets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># switch from Operator to Special</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Special</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">n_openbrackets</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># now actually parse the constraints</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">RealConstant</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">))</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">RealConstant</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="c1"># loop at max 2 times, once for lower, once for upper</span>
                <span class="k">if</span> <span class="n">lookahead_2</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &quot;lower&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">token_value</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># =</span>
                    <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">lookahead_2</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &quot;upper&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">token_value</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># =</span>
                    <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>

                <span class="n">lookahead_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="c1"># can be either &quot;,&quot;, which means loop again, or &quot;&gt;&quot;, which breaks</span>
                <span class="n">lookahead_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># either &quot;lower&quot;, or &quot;upper&quot; if lookahead_1 == &quot;,&quot;</span>
                <span class="k">if</span> <span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># ,</span>
                <span class="k">elif</span> <span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># &gt;</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Found unknown token with value </span><span class="si">{</span><span class="n">lookahead_1</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> when evaluating constraints&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span>
                        <span class="n">lookahead_1</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                        <span class="n">lookahead_1</span><span class="o">.</span><span class="n">column_index</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># the for loop takes of the portion &quot;&lt;lower= ... &gt;</span>
            <span class="c1"># this means the constraint part of been processed and</span>
            <span class="c1"># removed from the token queue at this point</span>
            <span class="n">exp</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span>
            <span class="n">exp</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span>

        <span class="k">return</span> <span class="n">exp</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Parser.expression" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.expression">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">expression</span><span class="signature">(self, min_precedence=0, is_lhs=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_precedence</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_lhs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to evaluate an expression. Please refer to the BNF grammer to see what types of</span>
<span class="sd">        rules are being applied.</span>
<span class="sd">        :param min_precedence: Minimum precedence value to evaluate</span>
<span class="sd">        :return: An `ops.Expr` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_nud</span><span class="p">(</span><span class="n">is_lhs</span><span class="o">=</span><span class="n">is_lhs</span><span class="p">)</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">NullToken</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>  <span class="c1"># &#39;(&#39; expression &#39;)&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                <span class="n">next_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>  <span class="c1"># )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">next_expression</span>  <span class="c1"># expression</span>

            <span class="k">elif</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># expression infixOps expression</span>
                <span class="k">if</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">min_precedence</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># op</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">(</span><span class="n">InfixOps</span><span class="o">.</span><span class="n">precedence</span><span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">InfixOps</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>  <span class="c1"># unaryFunction &#39;(&#39; expression &#39;)&#39;</span>
                    <span class="n">func_name</span> <span class="o">=</span> <span class="n">token</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># functionName</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                    <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="n">UnaryFunctions</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown token &#39;</span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">exp</span>

        <span class="k">return</span> <span class="n">left</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function is used to evaluate an expression. Please refer to the BNF grammer to see what types of
rules are being applied.
:param min_precedence: Minimum precedence value to evaluate
:return: An <code>ops.Expr</code> object.</p>
</div>


                            </div>
                            <div id="Parser.statement" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Parser.statement">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">statement</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">statement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates a single statement. Statements in rat are either assignments or sampling statements. They will get</span>
<span class="sd">        resolved into an `ops.Assignment` or an `ops.Distr` object.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_bracket_stack</span><span class="p">()</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s2">&quot;Cannot assign to a distribution.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

        <span class="c1"># Step 1. evaluate lhs, assume it&#39;s expression</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_nud</span><span class="p">(</span><span class="n">is_lhs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># if isinstance(lhs, Param) or isinstance(lhs, Data):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">AssignmentOps</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># assignment operator</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">AssignmentOps</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Special</span><span class="p">)</span> <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;~&quot;</span><span class="p">:</span>
                <span class="c1"># distribution declaration</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;~&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># ~</span>
                <span class="n">distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Identifier</span><span class="p">,</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># distribution</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># (</span>
                <span class="n">expressions</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expressions</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span>  <span class="c1"># list of expression</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expect_token</span><span class="p">(</span><span class="n">Special</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>  <span class="c1"># )</span>
                <span class="k">return</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">expressions</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown operator &#39;</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; in statement&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_string</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">column_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Expr</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Evaluates a single statement. Statements in rat are either assignments or sampling statements. They will get
resolved into an <code>ops.Assignment</code> or an <code>ops.Distr</code> object.
:return:</p>
</div>


                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>