window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "rat", "modulename": "rat", "qualname": "", "type": "module", "doc": "<p>If you want to see a list of supported math functions/distributions, skip to <a href=\"#language-function-reference\">here</a></p>\n\n<hr />\n\n<h2 id=\"subscripts\">Subscripts</h2>\n\n<p>Subscripts are the core feature that enables concise expressions. They can be seen as extensions of groups/factors in <code>lme4</code> syntax.</p>\n\n<p>Say we have the following data dataframe:</p>\n\n<pre><code>    game_id  home_score  away_score home_team away_team  score_diff  year\n0         1         117          88       CLE       NYK        29.0  2016\n1         2         113         104       POR       UTA         9.0  2016\n2         3         100         129       GSW       SAS       -29.0  2016\n3         4          96         108       ORL       MIA       -12.0  2016\n4         5         130         121       IND       DAL         9.0  2016\n5         6         122         117       BOS       BKN         5.0  2016\n6         7         109          91       TOR       DET        18.0  2016\n7         8          96         107       MIL       CHA       -11.0  2016\n8         9         102          98       MEM       MIN         4.0  2016\n9        10         102         107       NOP       DEN        -5.0  2016\n10       11          97         103       PHI       CLE        -6.0  2016\n</code></pre>\n\n<p>and we're trying to estimate some hidden skill parameter for each team. We can write the following model:</p>\n\n<pre><code>score_diff ~ normal(skills[home_team, year] - skills[away_team, year], sigma);\nskills[team, year] ~ normal(skills_mu[year], tau);\nskills_mu[year] ~ normal(0.0, 1.0);\ntau&lt;lower=0.0&gt; ~ normal(0.0, 1.0);\nsigma&lt;lower=0.0&gt; ~ normal(0.0, 10.0);\n</code></pre>\n\n<p>The simple way to think about how rat works is that it works on a row-by-row basis. Let's take a look at the first line:</p>\n\n<pre><code>score_diff ~ normal(skills[home_team, year] - skills[away_team, year],sigma);\n</code></pre>\n\n<p>This line of rat code states <code>score_diff</code> which is observed data follows a normal distribution with its mean defined as the difference between the home team and away team's <code>skills</code> parameter. Through <code>skills</code>'s subscript syntax using brackets(they are not your standard indexing syntax), rat identifies that each unique team-year combination from the data dataframe would have its own <code>skills</code> parameter.\nIn general, subscripts are resolved and generated when found on the <strong>right-hand-side of a statement that has a left-hand-side with resolved subscripts</strong>. However since rat topologically sorts before evaluation accordingly, the user just has to make sure parameters that they have declared/assigned with subscripts must be resolvable by checking they are present as right-hand-side.</p>\n\n<p>However, take a look at the second line:</p>\n\n<pre><code>skills[team, year] ~ normal(skills_mu[year], tau);\n</code></pre>\n\n<p>Now parameter <code>skills</code> is on the left-hand-side of a statement with some new subscript <code>team</code> which isn't present on the dataframe. However, we know from the first line that skills was subscripted with <code>[home_team, year]</code> and <code>away_team, year</code>. And thus, we can infer that this new new subscript <code>team</code> would be an alias for $home\\_team \\bigcup away\\_team$. And right-hand-side evaluation works the same as the first line; <code>skills_mu</code>'s <code>year</code> subscript would be referenced from <code>skills</code>'s.</p>\n\n<h2 id=\"assignments\">Assignments</h2>\n\n<p>Rat supports variable transformations by assigning values of expressions to variables we internally call <code>assigned_param</code>. <code>assigned_param</code> are not subject to inference but their definition expressions are evaluated at each inference iteration. They are functionally equivalent to Stan's <code>transformed parameters</code>. Let's use another example to demonstrate. We'll be implementing the non-centered version of the <a href=\"https://github.com/stan-dev/posteriordb/blob/master/posterior_database/models/stan/eight_schools_noncentered.stan\">eightschools model</a>.</p>\n\n<p>Again we provide the data dataframe:</p>\n\n<pre><code>    y  sigma  school\n0  28     15       1\n1   8     10       2\n2  -3     16       3\n3   7     11       4\n4  -1      9       5\n5   1     11       6\n6  18     10       7\n7  12     18       8\n</code></pre>\n\n<p>The rat code for the eightschools model is the following:</p>\n\n<pre><code>y ~ normal(theta[school], sigma[school]);\ntheta[school] = mu + z[school] * tau;\nz[school] ~ normal(0, 1);\nmu ~ normal(0, 5);\ntau&lt;lower = 0.0&gt; ~ lognormal(0, 1);\n</code></pre>\n\n<p>The only new line of code is line 2, which uses assignment to declare <code>theta</code> with subscript <code>school</code>. However the subscript resolving scenario is exactly the same as the previous example: <code>school</code> is resolved at line 1 from the dataframe. <code>z</code>, the unit normal parameter's subscript <code>school</code> is resolved from <code>theta[school]</code>.</p>\n\n<hr />\n\n<h2 id=\"internals-ratvariables-ratops-ratvariablesindex-and-ratvariablesindexuse\">Internals - <code>rat.variables</code>, <code>rat.ops</code>, <code>rat.variables.Index</code>, and <code>rat.variables.IndexUse</code></h2>\n\n<p>(This portion is for people who want to dig into rat's source)</p>\n\n<p>If you look closely at rat's source, you might notice something weird: There's a <code>rat.ops.Param</code> class and a <code>rat.variables.Param</code>. This also goes for <code>rat.ops.Data</code>, <code>rat.ops.Index</code>. <code>rat.ops</code> is designated as elements for the nodes of the parse tree that's generated by the parser. Since rat uses the parse tree to transpile to Python, we need to inject additional information regarding subscripts to the parse tree. This is where <code>rat.variables</code> comes into play: they are used to hold information regarding subscripts for a given parameter. I'll use the <a href=\"#subscripts\">skill model</a> example to explain:</p>\n\n<p>The parser converts the skill model above into the following parse tree representations:</p>\n\n<pre><code>ops.Normal(\n    ops.Data(\"score_diff\"),\n    ops.Diff(\n        ops.Param(\"skills\", ops.Index((\"home_team\", \"year\"))),\n        ops.Param(\"skills\", ops.Index((\"away_team\", \"year\"))),\n    ),\n    ops.Param(\"sigma\"),\n),\nops.Normal(\n    ops.Param(\"skills\", ops.Index((\"team\", \"year\"))),\n    ops.Param(\"skills_mu\", ops.Index((\"year\",))),\n    ops.Param(\"tau\"),\n),\nops.Normal(\n    ops.Param(\"skills_mu\", ops.Index((\"year\",))),\n    ops.RealConstant(0.0),\n    ops.RealConstant(1.0),\n),\nops.Normal(\n    ops.Param(\"tau\", lower=ops.RealConstant(0.0)),\n    ops.RealConstant(0.0),\n    ops.RealConstant(1.0),\n),\nops.Normal(\n    ops.Param(\"sigma\", lower=ops.RealConstant(0.0)),\n    ops.RealConstant(0.0),\n    ops.RealConstant(1.0),\n)\n</code></pre>\n\n<p>For each parameter we create a <code>rat.variables.Index</code> object which in essence hold the factors of the subscript. Recall <code>skills[team, year]</code> was in fact <code>skills[union(home_team, away_team), year]</code>. So we need a parameter for each team-year combination. <code>rat.variables.Index</code> internally stores a dataframe with columns <code>team</code> and <code>year</code>, which hold these unique combinations as reference subscripts.</p>\n\n<p>But we might want to just subscript <code>home_team</code> from <code>team</code>. That is, we might only want a portion of the subscript. <code>rat.variables.IndexUse</code> is the object that maps a variable's subscripts to another variable's reference subscript(its <code>rat.variables.Index</code> object). If we just wanted to index <code>home_team</code> from <code>team</code>, it will compare the <code>home_team</code> dataframe with <code>team</code>'s reference dataframe, and only select the combinations that are necessary.</p>\n\n<hr />\n\n<h2 id=\"language-function-reference\">Language function reference</h2>\n\n<p>Below are individual links to supported math functions and distributions</p>\n\n<ul>\n<li><strong>Distributions</strong>\n<ul>\n<li><code>rat.ops.Normal</code> : <code>normal(mu, sigma)</code></li>\n<li><code>rat.ops.BernoulliLogit</code>, <code>rat.compiler.bernoulli_logit</code> : <code>bernoulli_logit(p)</code></li>\n<li><code>rat.ops.LogNormal</code>, <code>rat.compiler.log_normal</code>  : <code>log_normal(mu, sigma)</code></li>\n<li><code>rat.ops.Cauchy</code>  : <code>cauchy(location, scale)</code></li>\n<li><code>rat.ops.Exponential</code>  :  <code>exponential(scale)</code></li>\n</ul></li>\n<li><strong>Functions</strong>\n<ul>\n<li><code>rat.ops.Log</code>: <code>log(x)</code></li>\n<li><code>rat.ops.Exp</code> : <code>exp(x)</code></li>\n<li><code>rat.ops.Abs</code> : <code>abs(x)</code></li>\n<li><code>rat.ops.Floor</code> : <code>floor(x)</code></li>\n<li><code>rat.ops.Ceil</code> : <code>ceil(x)</code></li>\n<li><code>rat.ops.Round</code> : <code>round(x)</code></li>\n<li><code>rat.ops.Sin</code> : <code>sin(x)</code></li>\n<li><code>rat.ops.Cos</code> : <code>cos(x)</code></li>\n<li><code>rat.ops.Tan</code> : <code>tan(x)</code></li>\n<li><code>rat.ops.Arcsin</code> : <code>arcsin(x)</code></li>\n<li><code>rat.ops.Arccos</code> : <code>arccos(x)</code></li>\n<li><code>rat.ops.Arctan</code> : <code>arctan(x)</code></li>\n<li><code>rat.ops.Logit</code> : <code>logit(x)</code></li>\n<li><code>rat.ops.InverseLogit</code> : <code>inverse_logit(x)</code></li>\n</ul></li>\n</ul>\n\n<h3 id=\"precedence-table\">Precedence Table</h3>\n\n<table>\n<thead>\n<tr>\n  <th>Operator</th>\n  <th style=\"text-align:center;\">Precedence</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>function calls(<code>exp</code>, <code>log</code>, etc.)</td>\n  <td style=\"text-align:center;\">100, leftmost derivative</td>\n</tr>\n<tr>\n  <td>prefix negation(<code>-10</code>, <code>-(1+2)</code>, etc.)</td>\n  <td style=\"text-align:center;\">50</td>\n</tr>\n<tr>\n  <td><code>^</code></td>\n  <td style=\"text-align:center;\">40</td>\n</tr>\n<tr>\n  <td><code>*</code>, <code>/</code>, <code>%</code></td>\n  <td style=\"text-align:center;\">30</td>\n</tr>\n<tr>\n  <td><code>+</code>, <code>-</code></td>\n  <td style=\"text-align:center;\">10</td>\n</tr>\n</tbody>\n</table>\n"}, {"fullname": "rat.compiler", "modulename": "rat.compiler", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "rat.compiler.bernoulli_logit", "modulename": "rat.compiler", "qualname": "bernoulli_logit", "type": "function", "doc": "<p></p>\n", "parameters": ["y", "logit_p"], "funcdef": "def"}, {"fullname": "rat.compiler.log_normal", "modulename": "rat.compiler", "qualname": "log_normal", "type": "function", "doc": "<p></p>\n", "parameters": ["y", "mu", "sigma"], "funcdef": "def"}, {"fullname": "rat.compiler.LineFunction", "modulename": "rat.compiler", "qualname": "LineFunction", "type": "class", "doc": "<p></p>\n"}, {"fullname": "rat.compiler.LineFunction.__init__", "modulename": "rat.compiler", "qualname": "LineFunction.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_variables", "parameter_variables", "assigned_parameter_variables", "index_use_variables", "line"], "funcdef": "def"}, {"fullname": "rat.compiler.LineFunction.code", "modulename": "rat.compiler", "qualname": "LineFunction.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.compiler.LineFunction.compiled_function_sum", "modulename": "rat.compiler", "qualname": "LineFunction.compiled_function_sum", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args"], "funcdef": "def"}, {"fullname": "rat.compiler.AssignLineFunction", "modulename": "rat.compiler", "qualname": "AssignLineFunction", "type": "class", "doc": "<p></p>\n"}, {"fullname": "rat.compiler.AssignLineFunction.__init__", "modulename": "rat.compiler", "qualname": "AssignLineFunction.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "name", "data_variables", "parameter_variables", "assigned_parameter_variables", "index_use_variables", "line"], "funcdef": "def"}, {"fullname": "rat.compiler.AssignLineFunction.code", "modulename": "rat.compiler", "qualname": "AssignLineFunction.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.compiler.generate_dependency_graph", "modulename": "rat.compiler", "qualname": "generate_dependency_graph", "type": "function", "doc": "<p></p>\n", "parameters": ["parsed_lines", "reversed"], "funcdef": "def"}, {"fullname": "rat.compiler.topological_sort", "modulename": "rat.compiler", "qualname": "topological_sort", "type": "function", "doc": "<p></p>\n", "parameters": ["graph"], "funcdef": "def"}, {"fullname": "rat.compiler.compile", "modulename": "rat.compiler", "qualname": "compile", "type": "function", "doc": "<p></p>\n", "parameters": ["data_df", "parsed_lines"], "funcdef": "def"}, {"fullname": "rat.constraints", "modulename": "rat.constraints", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "rat.constraints.lower", "modulename": "rat.constraints", "qualname": "lower", "type": "function", "doc": "<p></p>\n", "parameters": ["y", "lower"], "funcdef": "def"}, {"fullname": "rat.constraints.upper", "modulename": "rat.constraints", "qualname": "upper", "type": "function", "doc": "<p></p>\n", "parameters": ["y", "upper"], "funcdef": "def"}, {"fullname": "rat.constraints.finite", "modulename": "rat.constraints", "qualname": "finite", "type": "function", "doc": "<p></p>\n", "parameters": ["y", "upper", "lower"], "funcdef": "def"}, {"fullname": "rat.constraints.offset_multiply", "modulename": "rat.constraints", "qualname": "offset_multiply", "type": "function", "doc": "<p></p>\n", "parameters": ["y", "offset", "multiplier"], "funcdef": "def"}, {"fullname": "rat.fit", "modulename": "rat.fit", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "rat.fit.Fit", "modulename": "rat.fit", "qualname": "Fit", "type": "class", "doc": "<p>Parent class for optimization/MCMC results</p>\n"}, {"fullname": "rat.fit.Fit.__init__", "modulename": "rat.fit", "qualname": "Fit.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "rat.fit.Fit.draws", "modulename": "rat.fit", "qualname": "Fit.draws", "type": "function", "doc": "<p>Get the draws for given parameter(s) with columns for the\nsubscripts.</p>\n\n<p>If multiple parameter names given, outer join the tables for\neach name and return that result.</p>\n\n<p>For optimizations there will only ever be one draw in the\nresults (the optimum).</p>\n", "parameters": ["self", "parameter_names"], "funcdef": "def"}, {"fullname": "rat.fit.Fit.save", "modulename": "rat.fit", "qualname": "Fit.save", "type": "function", "doc": "<p>Save results to a folder. If overwrite is true, overwrite\nexisting files and folders</p>\n", "parameters": ["self", "folder", "overwrite"], "funcdef": "def"}, {"fullname": "rat.fit.OptimizationFit", "modulename": "rat.fit", "qualname": "OptimizationFit", "type": "class", "doc": "<p>Stores optimization results</p>\n"}, {"fullname": "rat.fit.OptimizationFit.__init__", "modulename": "rat.fit", "qualname": "OptimizationFit.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "draw_dfs"], "funcdef": "def"}, {"fullname": "rat.fit.SampleFit", "modulename": "rat.fit", "qualname": "SampleFit", "type": "class", "doc": "<p>Stores draws from an MCMC calculation</p>\n"}, {"fullname": "rat.fit.SampleFit.__init__", "modulename": "rat.fit", "qualname": "SampleFit.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "draw_dfs", "diag_dfs"], "funcdef": "def"}, {"fullname": "rat.fit.SampleFit.diag", "modulename": "rat.fit", "qualname": "SampleFit.diag", "type": "function", "doc": "<p>Get diagnostic dataframe for a given parameter. Diagnostics are currently\neffective sample size and rhat</p>\n", "parameters": ["self", "parameter_name"], "funcdef": "def"}, {"fullname": "rat.fit.SampleFit.save", "modulename": "rat.fit", "qualname": "SampleFit.save", "type": "function", "doc": "<p>Save the SampleFit object to a folder. If overwrite is true, then overwrite\nexisting files and use existing folders</p>\n", "parameters": ["self", "folder", "overwrite"], "funcdef": "def"}, {"fullname": "rat.fit.load", "modulename": "rat.fit", "qualname": "load", "type": "function", "doc": "<p>Load an OptimizationFit/SampleFit from the folder in which\nit was saved</p>\n", "parameters": ["folder"], "funcdef": "def"}, {"fullname": "rat.model", "modulename": "rat.model", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "rat.model.Model", "modulename": "rat.model", "qualname": "Model", "type": "class", "doc": "<p></p>\n"}, {"fullname": "rat.model.Model.__init__", "modulename": "rat.model", "qualname": "Model.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data_df", "parsed_lines", "model_string"], "funcdef": "def"}, {"fullname": "rat.model.Model.constrain", "modulename": "rat.model", "qualname": "Model.constrain", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "unconstrained_parameter_vector", "pad"], "funcdef": "def"}, {"fullname": "rat.model.Model.evaluate_program", "modulename": "rat.model", "qualname": "Model.evaluate_program", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "device_variables"], "funcdef": "def"}, {"fullname": "rat.model.Model.log_density", "modulename": "rat.model", "qualname": "Model.log_density", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "include_jacobian", "unconstrained_parameter_vector"], "funcdef": "def"}, {"fullname": "rat.model.Model.prepare_draws_and_dfs", "modulename": "rat.model", "qualname": "Model.prepare_draws_and_dfs", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "device_unconstrained_draws"], "funcdef": "def"}, {"fullname": "rat.model.Model.optimize", "modulename": "rat.model", "qualname": "Model.optimize", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "init", "chains", "retries", "tolerance"], "funcdef": "def"}, {"fullname": "rat.model.Model.sample", "modulename": "rat.model", "qualname": "Model.sample", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "num_draws", "num_warmup", "chains", "init", "step_size"], "funcdef": "def"}, {"fullname": "rat.ops", "modulename": "rat.ops", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Expr", "modulename": "rat.ops", "qualname": "Expr", "type": "class", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Expr.__init__", "modulename": "rat.ops", "qualname": "Expr.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "rat.ops.Expr.code", "modulename": "rat.ops", "qualname": "Expr.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.RealConstant", "modulename": "rat.ops", "qualname": "RealConstant", "type": "class", "doc": "<p>RealConstant(value: float)</p>\n"}, {"fullname": "rat.ops.RealConstant.__init__", "modulename": "rat.ops", "qualname": "RealConstant.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "rat.ops.RealConstant.code", "modulename": "rat.ops", "qualname": "RealConstant.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.IntegerConstant", "modulename": "rat.ops", "qualname": "IntegerConstant", "type": "class", "doc": "<p>IntegerConstant(value: int)</p>\n"}, {"fullname": "rat.ops.IntegerConstant.__init__", "modulename": "rat.ops", "qualname": "IntegerConstant.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "rat.ops.IntegerConstant.code", "modulename": "rat.ops", "qualname": "IntegerConstant.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Index", "modulename": "rat.ops", "qualname": "Index", "type": "class", "doc": "<p>Index(names: Tuple[str], shifts: Tuple[Optional[str]] = (None,), variable: rat.variables.IndexUse = None)</p>\n"}, {"fullname": "rat.ops.Index.__init__", "modulename": "rat.ops", "qualname": "Index.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "names", "shifts", "variable"], "funcdef": "def"}, {"fullname": "rat.ops.Index.shifts", "modulename": "rat.ops", "qualname": "Index.shifts", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Index.variable", "modulename": "rat.ops", "qualname": "Index.variable", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Index.get_key", "modulename": "rat.ops", "qualname": "Index.get_key", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Index.code", "modulename": "rat.ops", "qualname": "Index.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Data", "modulename": "rat.ops", "qualname": "Data", "type": "class", "doc": "<p>Data(name: str, index: rat.ops.Index = None, variable: rat.variables.Data = None)</p>\n"}, {"fullname": "rat.ops.Data.__init__", "modulename": "rat.ops", "qualname": "Data.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "name", "index", "variable"], "funcdef": "def"}, {"fullname": "rat.ops.Data.index", "modulename": "rat.ops", "qualname": "Data.index", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Data.variable", "modulename": "rat.ops", "qualname": "Data.variable", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Data.get_key", "modulename": "rat.ops", "qualname": "Data.get_key", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Data.code", "modulename": "rat.ops", "qualname": "Data.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Param", "modulename": "rat.ops", "qualname": "Param", "type": "class", "doc": "<p>Param(name: str, index: rat.ops.Index = None, lower: rat.ops.Expr = RealConstant(value=-inf), upper: rat.ops.Expr = RealConstant(value=inf), variable: rat.variables.Param = None)</p>\n"}, {"fullname": "rat.ops.Param.__init__", "modulename": "rat.ops", "qualname": "Param.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "name", "index", "lower", "upper", "variable"], "funcdef": "def"}, {"fullname": "rat.ops.Param.index", "modulename": "rat.ops", "qualname": "Param.index", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Param.lower", "modulename": "rat.ops", "qualname": "Param.lower", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Param.upper", "modulename": "rat.ops", "qualname": "Param.upper", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Param.variable", "modulename": "rat.ops", "qualname": "Param.variable", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Param.scalar", "modulename": "rat.ops", "qualname": "Param.scalar", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Param.get_key", "modulename": "rat.ops", "qualname": "Param.get_key", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Param.code", "modulename": "rat.ops", "qualname": "Param.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Distr", "modulename": "rat.ops", "qualname": "Distr", "type": "class", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Distr.__init__", "modulename": "rat.ops", "qualname": "Distr.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "rat.ops.Normal", "modulename": "rat.ops", "qualname": "Normal", "type": "class", "doc": "<p>Normal(variate: rat.ops.Expr, mean: rat.ops.Expr, std: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Normal.__init__", "modulename": "rat.ops", "qualname": "Normal.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "variate", "mean", "std"], "funcdef": "def"}, {"fullname": "rat.ops.Normal.code", "modulename": "rat.ops", "qualname": "Normal.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.BernoulliLogit", "modulename": "rat.ops", "qualname": "BernoulliLogit", "type": "class", "doc": "<p>BernoulliLogit(variate: rat.ops.Expr, logit_p: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.BernoulliLogit.__init__", "modulename": "rat.ops", "qualname": "BernoulliLogit.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "variate", "logit_p"], "funcdef": "def"}, {"fullname": "rat.ops.BernoulliLogit.code", "modulename": "rat.ops", "qualname": "BernoulliLogit.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.LogNormal", "modulename": "rat.ops", "qualname": "LogNormal", "type": "class", "doc": "<p>LogNormal(variate: rat.ops.Expr, mean: rat.ops.Expr, std: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.LogNormal.__init__", "modulename": "rat.ops", "qualname": "LogNormal.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "variate", "mean", "std"], "funcdef": "def"}, {"fullname": "rat.ops.LogNormal.code", "modulename": "rat.ops", "qualname": "LogNormal.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Cauchy", "modulename": "rat.ops", "qualname": "Cauchy", "type": "class", "doc": "<p>Cauchy(variate: rat.ops.Expr, location: rat.ops.Expr, scale: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Cauchy.__init__", "modulename": "rat.ops", "qualname": "Cauchy.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "variate", "location", "scale"], "funcdef": "def"}, {"fullname": "rat.ops.Cauchy.code", "modulename": "rat.ops", "qualname": "Cauchy.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Exponential", "modulename": "rat.ops", "qualname": "Exponential", "type": "class", "doc": "<p>Exponential(variate: rat.ops.Expr, scale: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Exponential.__init__", "modulename": "rat.ops", "qualname": "Exponential.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "variate", "scale"], "funcdef": "def"}, {"fullname": "rat.ops.Exponential.code", "modulename": "rat.ops", "qualname": "Exponential.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Diff", "modulename": "rat.ops", "qualname": "Diff", "type": "class", "doc": "<p>Diff(lhs: rat.ops.Expr, rhs: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Diff.__init__", "modulename": "rat.ops", "qualname": "Diff.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "lhs", "rhs"], "funcdef": "def"}, {"fullname": "rat.ops.Diff.code", "modulename": "rat.ops", "qualname": "Diff.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Sum", "modulename": "rat.ops", "qualname": "Sum", "type": "class", "doc": "<p>Sum(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Sum.__init__", "modulename": "rat.ops", "qualname": "Sum.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.Sum.code", "modulename": "rat.ops", "qualname": "Sum.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Mul", "modulename": "rat.ops", "qualname": "Mul", "type": "class", "doc": "<p>Mul(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Mul.__init__", "modulename": "rat.ops", "qualname": "Mul.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.Mul.lbp", "modulename": "rat.ops", "qualname": "Mul.lbp", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Mul.code", "modulename": "rat.ops", "qualname": "Mul.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Pow", "modulename": "rat.ops", "qualname": "Pow", "type": "class", "doc": "<p>Pow(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Pow.__init__", "modulename": "rat.ops", "qualname": "Pow.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.Pow.lbp", "modulename": "rat.ops", "qualname": "Pow.lbp", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Pow.code", "modulename": "rat.ops", "qualname": "Pow.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Div", "modulename": "rat.ops", "qualname": "Div", "type": "class", "doc": "<p>Div(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Div.__init__", "modulename": "rat.ops", "qualname": "Div.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.Div.code", "modulename": "rat.ops", "qualname": "Div.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Mod", "modulename": "rat.ops", "qualname": "Mod", "type": "class", "doc": "<p>Mod(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Mod.__init__", "modulename": "rat.ops", "qualname": "Mod.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.Mod.code", "modulename": "rat.ops", "qualname": "Mod.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.LogicalOR", "modulename": "rat.ops", "qualname": "LogicalOR", "type": "class", "doc": "<p>LogicalOR(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.LogicalOR.__init__", "modulename": "rat.ops", "qualname": "LogicalOR.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.LogicalOR.code", "modulename": "rat.ops", "qualname": "LogicalOR.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.LogicalAND", "modulename": "rat.ops", "qualname": "LogicalAND", "type": "class", "doc": "<p>LogicalAND(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.LogicalAND.__init__", "modulename": "rat.ops", "qualname": "LogicalAND.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.LogicalAND.code", "modulename": "rat.ops", "qualname": "LogicalAND.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Equality", "modulename": "rat.ops", "qualname": "Equality", "type": "class", "doc": "<p>Equality(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Equality.__init__", "modulename": "rat.ops", "qualname": "Equality.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.Equality.code", "modulename": "rat.ops", "qualname": "Equality.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Inequality", "modulename": "rat.ops", "qualname": "Inequality", "type": "class", "doc": "<p>Inequality(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Inequality.__init__", "modulename": "rat.ops", "qualname": "Inequality.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.Inequality.code", "modulename": "rat.ops", "qualname": "Inequality.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.LessThan", "modulename": "rat.ops", "qualname": "LessThan", "type": "class", "doc": "<p>LessThan(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.LessThan.__init__", "modulename": "rat.ops", "qualname": "LessThan.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.LessThan.code", "modulename": "rat.ops", "qualname": "LessThan.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.LessThanOrEqual", "modulename": "rat.ops", "qualname": "LessThanOrEqual", "type": "class", "doc": "<p>LessThanOrEqual(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.LessThanOrEqual.__init__", "modulename": "rat.ops", "qualname": "LessThanOrEqual.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.LessThanOrEqual.code", "modulename": "rat.ops", "qualname": "LessThanOrEqual.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.GreaterThan", "modulename": "rat.ops", "qualname": "GreaterThan", "type": "class", "doc": "<p>GreaterThan(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.GreaterThan.__init__", "modulename": "rat.ops", "qualname": "GreaterThan.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.GreaterThan.code", "modulename": "rat.ops", "qualname": "GreaterThan.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.GreaterThanOrEqual", "modulename": "rat.ops", "qualname": "GreaterThanOrEqual", "type": "class", "doc": "<p>GreaterThanOrEqual(left: rat.ops.Expr, right: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.GreaterThanOrEqual.__init__", "modulename": "rat.ops", "qualname": "GreaterThanOrEqual.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "left", "right"], "funcdef": "def"}, {"fullname": "rat.ops.GreaterThanOrEqual.code", "modulename": "rat.ops", "qualname": "GreaterThanOrEqual.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.PrefixNegation", "modulename": "rat.ops", "qualname": "PrefixNegation", "type": "class", "doc": "<p>PrefixNegation(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.PrefixNegation.__init__", "modulename": "rat.ops", "qualname": "PrefixNegation.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.PrefixNegation.code", "modulename": "rat.ops", "qualname": "PrefixNegation.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.PrefixLogicalNegation", "modulename": "rat.ops", "qualname": "PrefixLogicalNegation", "type": "class", "doc": "<p>PrefixLogicalNegation(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.PrefixLogicalNegation.__init__", "modulename": "rat.ops", "qualname": "PrefixLogicalNegation.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.PrefixLogicalNegation.code", "modulename": "rat.ops", "qualname": "PrefixLogicalNegation.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Assignment", "modulename": "rat.ops", "qualname": "Assignment", "type": "class", "doc": "<p>Assignment(lhs: rat.ops.Expr, rhs: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Assignment.__init__", "modulename": "rat.ops", "qualname": "Assignment.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "lhs", "rhs"], "funcdef": "def"}, {"fullname": "rat.ops.Assignment.code", "modulename": "rat.ops", "qualname": "Assignment.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Log", "modulename": "rat.ops", "qualname": "Log", "type": "class", "doc": "<p>Log(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Log.__init__", "modulename": "rat.ops", "qualname": "Log.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Log.code", "modulename": "rat.ops", "qualname": "Log.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Exp", "modulename": "rat.ops", "qualname": "Exp", "type": "class", "doc": "<p>Exp(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Exp.__init__", "modulename": "rat.ops", "qualname": "Exp.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Exp.code", "modulename": "rat.ops", "qualname": "Exp.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Abs", "modulename": "rat.ops", "qualname": "Abs", "type": "class", "doc": "<p>Abs(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Abs.__init__", "modulename": "rat.ops", "qualname": "Abs.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Abs.code", "modulename": "rat.ops", "qualname": "Abs.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Floor", "modulename": "rat.ops", "qualname": "Floor", "type": "class", "doc": "<p>Floor(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Floor.__init__", "modulename": "rat.ops", "qualname": "Floor.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Floor.code", "modulename": "rat.ops", "qualname": "Floor.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Ceil", "modulename": "rat.ops", "qualname": "Ceil", "type": "class", "doc": "<p>Ceil(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Ceil.__init__", "modulename": "rat.ops", "qualname": "Ceil.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Ceil.code", "modulename": "rat.ops", "qualname": "Ceil.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Round", "modulename": "rat.ops", "qualname": "Round", "type": "class", "doc": "<p>Round(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Round.__init__", "modulename": "rat.ops", "qualname": "Round.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Round.code", "modulename": "rat.ops", "qualname": "Round.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Sin", "modulename": "rat.ops", "qualname": "Sin", "type": "class", "doc": "<p>Sin(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Sin.__init__", "modulename": "rat.ops", "qualname": "Sin.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Sin.code", "modulename": "rat.ops", "qualname": "Sin.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Cos", "modulename": "rat.ops", "qualname": "Cos", "type": "class", "doc": "<p>Cos(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Cos.__init__", "modulename": "rat.ops", "qualname": "Cos.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Cos.code", "modulename": "rat.ops", "qualname": "Cos.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Tan", "modulename": "rat.ops", "qualname": "Tan", "type": "class", "doc": "<p>Tan(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Tan.__init__", "modulename": "rat.ops", "qualname": "Tan.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Tan.code", "modulename": "rat.ops", "qualname": "Tan.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Arcsin", "modulename": "rat.ops", "qualname": "Arcsin", "type": "class", "doc": "<p>Arcsin(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Arcsin.__init__", "modulename": "rat.ops", "qualname": "Arcsin.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Arcsin.code", "modulename": "rat.ops", "qualname": "Arcsin.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Arccos", "modulename": "rat.ops", "qualname": "Arccos", "type": "class", "doc": "<p>Arccos(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Arccos.__init__", "modulename": "rat.ops", "qualname": "Arccos.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Arccos.code", "modulename": "rat.ops", "qualname": "Arccos.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Arctan", "modulename": "rat.ops", "qualname": "Arctan", "type": "class", "doc": "<p>Arctan(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Arctan.__init__", "modulename": "rat.ops", "qualname": "Arctan.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Arctan.code", "modulename": "rat.ops", "qualname": "Arctan.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Logit", "modulename": "rat.ops", "qualname": "Logit", "type": "class", "doc": "<p>Logit(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.Logit.__init__", "modulename": "rat.ops", "qualname": "Logit.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.Logit.code", "modulename": "rat.ops", "qualname": "Logit.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.InverseLogit", "modulename": "rat.ops", "qualname": "InverseLogit", "type": "class", "doc": "<p>InverseLogit(subexpr: rat.ops.Expr)</p>\n"}, {"fullname": "rat.ops.InverseLogit.__init__", "modulename": "rat.ops", "qualname": "InverseLogit.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "subexpr"], "funcdef": "def"}, {"fullname": "rat.ops.InverseLogit.code", "modulename": "rat.ops", "qualname": "InverseLogit.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.Placeholder", "modulename": "rat.ops", "qualname": "Placeholder", "type": "class", "doc": "<p>Placeholder(name: str, index: Optional[rat.ops.Index], value: float = None)</p>\n"}, {"fullname": "rat.ops.Placeholder.__init__", "modulename": "rat.ops", "qualname": "Placeholder.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "name", "index", "value"], "funcdef": "def"}, {"fullname": "rat.ops.Placeholder.value", "modulename": "rat.ops", "qualname": "Placeholder.value", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.ops.Placeholder.code", "modulename": "rat.ops", "qualname": "Placeholder.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.ops.search_tree", "modulename": "rat.ops", "qualname": "search_tree", "type": "function", "doc": "<p></p>\n", "parameters": ["expr", "types"], "funcdef": "def"}, {"fullname": "rat.parser", "modulename": "rat.parser", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "rat.parser.PrefixOps", "modulename": "rat.parser", "qualname": "PrefixOps", "type": "class", "doc": "<p>A utility class that's used to identify and build prefix-operation expressions.</p>\n"}, {"fullname": "rat.parser.PrefixOps.__init__", "modulename": "rat.parser", "qualname": "PrefixOps.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "rat.parser.PrefixOps.ops", "modulename": "rat.parser", "qualname": "PrefixOps.ops", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.parser.PrefixOps.precedence", "modulename": "rat.parser", "qualname": "PrefixOps.precedence", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.parser.PrefixOps.check", "modulename": "rat.parser", "qualname": "PrefixOps.check", "type": "function", "doc": "<p></p>\n", "parameters": ["tok"], "funcdef": "def"}, {"fullname": "rat.parser.PrefixOps.generate", "modulename": "rat.parser", "qualname": "PrefixOps.generate", "type": "function", "doc": "<p></p>\n", "parameters": ["expr", "tok"], "funcdef": "def"}, {"fullname": "rat.parser.PostfixOps", "modulename": "rat.parser", "qualname": "PostfixOps", "type": "class", "doc": "<p></p>\n"}, {"fullname": "rat.parser.PostfixOps.__init__", "modulename": "rat.parser", "qualname": "PostfixOps.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "rat.parser.PostfixOps.ops", "modulename": "rat.parser", "qualname": "PostfixOps.ops", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.parser.PostfixOps.check", "modulename": "rat.parser", "qualname": "PostfixOps.check", "type": "function", "doc": "<p></p>\n", "parameters": ["tok"], "funcdef": "def"}, {"fullname": "rat.parser.InfixOps", "modulename": "rat.parser", "qualname": "InfixOps", "type": "class", "doc": "<p>A utility class that's used to identify and build binary operation expressions.\nCurrently supported operations are:\n<code>ops.Sum</code>, <code>ops.Diff</code>, <code>ops.Mul</code>, <code>ops.Pow</code>, <code>ops.Mod</code>, <code>ops.Div</code></p>\n"}, {"fullname": "rat.parser.InfixOps.__init__", "modulename": "rat.parser", "qualname": "InfixOps.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "rat.parser.InfixOps.ops", "modulename": "rat.parser", "qualname": "InfixOps.ops", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.parser.InfixOps.precedence", "modulename": "rat.parser", "qualname": "InfixOps.precedence", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.parser.InfixOps.check", "modulename": "rat.parser", "qualname": "InfixOps.check", "type": "function", "doc": "<p></p>\n", "parameters": ["tok"], "funcdef": "def"}, {"fullname": "rat.parser.InfixOps.generate", "modulename": "rat.parser", "qualname": "InfixOps.generate", "type": "function", "doc": "<p></p>\n", "parameters": ["lhs", "rhs", "token"], "funcdef": "def"}, {"fullname": "rat.parser.AssignmentOps", "modulename": "rat.parser", "qualname": "AssignmentOps", "type": "class", "doc": "<p>A utility class that's used to identify and build assignments in statements.\nCurrently supports the following assignment types:\n<code>ops.Assignment</code></p>\n"}, {"fullname": "rat.parser.AssignmentOps.__init__", "modulename": "rat.parser", "qualname": "AssignmentOps.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "rat.parser.AssignmentOps.ops", "modulename": "rat.parser", "qualname": "AssignmentOps.ops", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.parser.AssignmentOps.check", "modulename": "rat.parser", "qualname": "AssignmentOps.check", "type": "function", "doc": "<p></p>\n", "parameters": ["tok"], "funcdef": "def"}, {"fullname": "rat.parser.AssignmentOps.generate", "modulename": "rat.parser", "qualname": "AssignmentOps.generate", "type": "function", "doc": "<p></p>\n", "parameters": ["lhs", "operator", "rhs"], "funcdef": "def"}, {"fullname": "rat.parser.UnaryFunctions", "modulename": "rat.parser", "qualname": "UnaryFunctions", "type": "class", "doc": "<p>A utility class that's used to identify and build unary functions.</p>\n"}, {"fullname": "rat.parser.UnaryFunctions.__init__", "modulename": "rat.parser", "qualname": "UnaryFunctions.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "rat.parser.UnaryFunctions.names", "modulename": "rat.parser", "qualname": "UnaryFunctions.names", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.parser.UnaryFunctions.precedence", "modulename": "rat.parser", "qualname": "UnaryFunctions.precedence", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.parser.UnaryFunctions.check", "modulename": "rat.parser", "qualname": "UnaryFunctions.check", "type": "function", "doc": "<p></p>\n", "parameters": ["tok"], "funcdef": "def"}, {"fullname": "rat.parser.UnaryFunctions.generate", "modulename": "rat.parser", "qualname": "UnaryFunctions.generate", "type": "function", "doc": "<p></p>\n", "parameters": ["subexpr", "func_type"], "funcdef": "def"}, {"fullname": "rat.parser.Distributions", "modulename": "rat.parser", "qualname": "Distributions", "type": "class", "doc": "<p>A utility class that's used to identify and build distributions.\nCurrently supported distributions are:\n<code>ops.Normal</code>, <code>ops.BernoulliLogit</code>, <code>ops.LogNormal</code>, <code>ops.Cauchy</code>, <code>ops.Exponential</code></p>\n"}, {"fullname": "rat.parser.Distributions.__init__", "modulename": "rat.parser", "qualname": "Distributions.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "rat.parser.Distributions.names", "modulename": "rat.parser", "qualname": "Distributions.names", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.parser.Distributions.check", "modulename": "rat.parser", "qualname": "Distributions.check", "type": "function", "doc": "<p></p>\n", "parameters": ["tok"], "funcdef": "def"}, {"fullname": "rat.parser.Distributions.generate", "modulename": "rat.parser", "qualname": "Distributions.generate", "type": "function", "doc": "<p></p>\n", "parameters": ["dist_type", "lhs", "expressions"], "funcdef": "def"}, {"fullname": "rat.parser.ParseError", "modulename": "rat.parser", "qualname": "ParseError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "rat.parser.ParseError.__init__", "modulename": "rat.parser", "qualname": "ParseError.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "message", "code_string", "line_num", "column_num"], "funcdef": "def"}, {"fullname": "rat.parser.Parser", "modulename": "rat.parser", "qualname": "Parser", "type": "class", "doc": "<p>The parser for rat is a modified Pratt parser.\nSince rat programs are defined within the context of data, the parser needs to know\nthe column names of the data.</p>\n"}, {"fullname": "rat.parser.Parser.__init__", "modulename": "rat.parser", "qualname": "Parser.__init__", "type": "function", "doc": "<p>Initialize the parser\n:param tokens: A list of <code>scanner.Token</code>. This should be the output format of <code>scanner.scanner</code>\n:param data_names: A list of data column names\n:param model_string: Optional. The original model code string. If supplied, used to generate detailed errors.</p>\n", "parameters": ["self", "tokens", "data_names", "model_string"], "funcdef": "def"}, {"fullname": "rat.parser.Parser.check_bracket_stack", "modulename": "rat.parser", "qualname": "Parser.check_bracket_stack", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.parser.Parser.peek", "modulename": "rat.parser", "qualname": "Parser.peek", "type": "function", "doc": "<p>k-token lookahead. Returns <code>scanner.NullToken</code> if there are no tokens in the token stack.</p>\n", "parameters": ["self", "k"], "funcdef": "def"}, {"fullname": "rat.parser.Parser.remove", "modulename": "rat.parser", "qualname": "Parser.remove", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "index"], "funcdef": "def"}, {"fullname": "rat.parser.Parser.expect_token", "modulename": "rat.parser", "qualname": "Parser.expect_token", "type": "function", "doc": "<p>Checks if the next token in the token stack is of designated type and value. If not, raise an Exception.\n:param token_types: A list of <code>scanner.Token</code> types or a single <code>scanner.Token</code> type that's allowed.\n:param token_value: A single or a list of allowed token value strings\n:param remove: Boolean, whether to remove the token after checking or not. Defaults to False\n:param lookahead: lookahead. Defaults to 0(immediate token)\n:return: None</p>\n", "parameters": ["self", "token_types", "token_value", "remove", "lookahead"], "funcdef": "def"}, {"fullname": "rat.parser.Parser.expressions", "modulename": "rat.parser", "qualname": "Parser.expressions", "type": "function", "doc": "<p>expressions are used to evaluate repeated, comma-separeted expressions in the form \"expr, expr, expr\"\nIt's primarily used to evaluate subscripts or function arguments. In the case it's evaluating subscripts, it\nwill also return the shift amounts of each subscript.\n:param entry_token_value: A single character which denotes the boundary token that starts the expression\nsequence. For example, \"myFunc(expr1, expr2, expr3)\" would mean the 3-expression sequence is present between the\nparantheses. So the entry token would be \"(\" and exit token \")\".\nFor subscripts, it would be something like \"my_variable[sub_1, shift(sub_2, 1)]. That would mean entry token\n\"[\" and exit token \"]\".\n:param allow_shift: This is for a quick sanity check that checks whether shift() is allowed to be used within\nthe expression sequence.\n:return: A Tuple of length 2, with the first value being a list of expressions, and second value being a Tuple\nof integers denoting shift amounts, if any.</p>\n", "parameters": ["self", "entry_token_value", "allow_shift"], "funcdef": "def"}, {"fullname": "rat.parser.Parser.parse_nud", "modulename": "rat.parser", "qualname": "Parser.parse_nud", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "is_lhs"], "funcdef": "def"}, {"fullname": "rat.parser.Parser.parse_param", "modulename": "rat.parser", "qualname": "Parser.parse_param", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "is_lhs"], "funcdef": "def"}, {"fullname": "rat.parser.Parser.expression", "modulename": "rat.parser", "qualname": "Parser.expression", "type": "function", "doc": "<p>This function is used to evaluate an expression. Please refer to the BNF grammer to see what types of\nrules are being applied.\n:param min_precedence: Minimum precedence value to evaluate\n:return: An <code>ops.Expr</code> object.</p>\n", "parameters": ["self", "min_precedence", "is_lhs"], "funcdef": "def"}, {"fullname": "rat.parser.Parser.statement", "modulename": "rat.parser", "qualname": "Parser.statement", "type": "function", "doc": "<p>Evaluates a single statement. Statements in rat are either assignments or sampling statements. They will get\nresolved into an <code>ops.Assignment</code> or an <code>ops.Distr</code> object.\n:return:</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner", "modulename": "rat.scanner", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "rat.scanner.Token", "modulename": "rat.scanner", "qualname": "Token", "type": "class", "doc": "<p>A token denotes a sequence of input characters, typically demarcated by other characters that represent\nsemantics, most commonly whitespace. Please Refer to individual token types' docs for more information</p>\n"}, {"fullname": "rat.scanner.Token.__init__", "modulename": "rat.scanner", "qualname": "Token.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "line_index", "column_index"], "funcdef": "def"}, {"fullname": "rat.scanner.Token.value", "modulename": "rat.scanner", "qualname": "Token.value", "type": "variable", "doc": "<p>A string containing the input characters</p>\n"}, {"fullname": "rat.scanner.Token.line_index", "modulename": "rat.scanner", "qualname": "Token.line_index", "type": "variable", "doc": "<p>An integer denoting the line number of the Token in the original code string</p>\n"}, {"fullname": "rat.scanner.Token.column_index", "modulename": "rat.scanner", "qualname": "Token.column_index", "type": "variable", "doc": "<p>An integer denoting the start position of the Token in the code line</p>\n"}, {"fullname": "rat.scanner.Token.token_type", "modulename": "rat.scanner", "qualname": "Token.token_type", "type": "variable", "doc": "<p>A string representing the type of token. Set by self.__class__.__name</p>\n"}, {"fullname": "rat.scanner.Identifier", "modulename": "rat.scanner", "qualname": "Identifier", "type": "class", "doc": "<p>The Identifier token represents any alphanumeric string that isn't used as a standalone number.\nThis includes function names, variables, distributions, etc.</p>\n"}, {"fullname": "rat.scanner.Identifier.__init__", "modulename": "rat.scanner", "qualname": "Identifier.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "line_index", "column_index"], "funcdef": "def"}, {"fullname": "rat.scanner.Special", "modulename": "rat.scanner", "qualname": "Special", "type": "class", "doc": "<p>The Special token represents any single characters that indicate change in semantics or control flow.\nExplicitly any single token that has the following values(\"(\", \")\", \",\", \"[\", \"]\", \"~\") are set as Special</p>\n"}, {"fullname": "rat.scanner.Special.__init__", "modulename": "rat.scanner", "qualname": "Special.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "line_index", "column_index"], "funcdef": "def"}, {"fullname": "rat.scanner.IntLiteral", "modulename": "rat.scanner", "qualname": "IntLiteral", "type": "class", "doc": "<p>The IntLiteral token represent integers.</p>\n"}, {"fullname": "rat.scanner.IntLiteral.__init__", "modulename": "rat.scanner", "qualname": "IntLiteral.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "line_index", "column_index"], "funcdef": "def"}, {"fullname": "rat.scanner.RealLiteral", "modulename": "rat.scanner", "qualname": "RealLiteral", "type": "class", "doc": "<p>The RealLiteral token represent real numbers. Currently the regex expression\n^[-]?[0-9]*.?[0-9]+(e[-+]?[0-9]+)?$ is being used to parse real numbers, which allows negative values as well as\nscientific notation.</p>\n"}, {"fullname": "rat.scanner.RealLiteral.__init__", "modulename": "rat.scanner", "qualname": "RealLiteral.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "line_index", "column_index"], "funcdef": "def"}, {"fullname": "rat.scanner.Operator", "modulename": "rat.scanner", "qualname": "Operator", "type": "class", "doc": "<p>The Operator token represent character(s) that represent operators. Explicitly, any single token that has the\nfollowing values(\"=\",\"+\",\"-\",\"*\",\"/\",\"^\",\"%\") are\nset as an Operator.</p>\n"}, {"fullname": "rat.scanner.Operator.__init__", "modulename": "rat.scanner", "qualname": "Operator.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "line_index", "column_index"], "funcdef": "def"}, {"fullname": "rat.scanner.Terminate", "modulename": "rat.scanner", "qualname": "Terminate", "type": "class", "doc": "<p>In rat, all statements are terminated using with ; and not newline.</p>\n"}, {"fullname": "rat.scanner.Terminate.__init__", "modulename": "rat.scanner", "qualname": "Terminate.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "line_index", "column_index"], "funcdef": "def"}, {"fullname": "rat.scanner.NullToken", "modulename": "rat.scanner", "qualname": "NullToken", "type": "class", "doc": "<p>NullToken doesn't represent anything. This is pretty much used in the same context as None.</p>\n"}, {"fullname": "rat.scanner.NullToken.__init__", "modulename": "rat.scanner", "qualname": "NullToken.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.TokenizeError", "modulename": "rat.scanner", "qualname": "TokenizeError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "rat.scanner.TokenizeError.__init__", "modulename": "rat.scanner", "qualname": "TokenizeError.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "message", "code_string", "line_num", "column_num"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner", "modulename": "rat.scanner", "qualname": "Scanner", "type": "class", "doc": "<p></p>\n"}, {"fullname": "rat.scanner.Scanner.__init__", "modulename": "rat.scanner", "qualname": "Scanner.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "model_code"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.scan", "modulename": "rat.scanner", "qualname": "Scanner.scan", "type": "function", "doc": "<p>Entry function of the Scanner class.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.consume", "modulename": "rat.scanner", "qualname": "Scanner.consume", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.reduce_register", "modulename": "rat.scanner", "qualname": "Scanner.reduce_register", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.raise_error", "modulename": "rat.scanner", "qualname": "Scanner.raise_error", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "msg"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.delimeter_state", "modulename": "rat.scanner", "qualname": "Scanner.delimeter_state", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.default_state", "modulename": "rat.scanner", "qualname": "Scanner.default_state", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.identifier_state", "modulename": "rat.scanner", "qualname": "Scanner.identifier_state", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.integer_state", "modulename": "rat.scanner", "qualname": "Scanner.integer_state", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.real_state", "modulename": "rat.scanner", "qualname": "Scanner.real_state", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.real_exponent_state", "modulename": "rat.scanner", "qualname": "Scanner.real_exponent_state", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.scanner.Scanner.operator_state", "modulename": "rat.scanner", "qualname": "Scanner.operator_state", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables", "modulename": "rat.variables", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "rat.variables.Index", "modulename": "rat.variables", "qualname": "Index", "type": "class", "doc": "<p></p>\n"}, {"fullname": "rat.variables.Index.__init__", "modulename": "rat.variables", "qualname": "Index.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "unprocessed_df", "indexed_sets"], "funcdef": "def"}, {"fullname": "rat.variables.Index.incorporate_shifts", "modulename": "rat.variables", "qualname": "Index.incorporate_shifts", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "shifts"], "funcdef": "def"}, {"fullname": "rat.variables.Index.compute_shifted_df", "modulename": "rat.variables", "qualname": "Index.compute_shifted_df", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "df", "shifts"], "funcdef": "def"}, {"fullname": "rat.variables.Index.rebuild_df", "modulename": "rat.variables", "qualname": "Index.rebuild_df", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.Index.get_numpy_indices", "modulename": "rat.variables", "qualname": "Index.get_numpy_indices", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "df"], "funcdef": "def"}, {"fullname": "rat.variables.Index.log_summary", "modulename": "rat.variables", "qualname": "Index.log_summary", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "log_level"], "funcdef": "def"}, {"fullname": "rat.variables.Index.check_and_return_index", "modulename": "rat.variables", "qualname": "Index.check_and_return_index", "type": "function", "doc": "<p>This function checks a given index key is valid in case the Index has different aliases.\nFor example, if we have a parameter 'score' that was subscripted as 'score[home_team, year]' and\n'score[away_team, year]', but was used as 'score[tem, year]', it gets hard to manage what the column names\nshould be. This function tries to resolve them by first checking that index_key is valid, i.e. was declared,\nand returns the default singular column names.\n:param index_key: A tuple of strings, which is retrieved by <code>ops.Index.get_key</code>\n:return: A tuple of strings, which is composed of the columns names of self.df</p>\n", "parameters": ["self", "index_key"], "funcdef": "def"}, {"fullname": "rat.variables.Data", "modulename": "rat.variables", "qualname": "Data", "type": "class", "doc": "<p>Data(name: str, series: pandas.core.series.Series)</p>\n"}, {"fullname": "rat.variables.Data.__init__", "modulename": "rat.variables", "qualname": "Data.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "name", "series"], "funcdef": "def"}, {"fullname": "rat.variables.Data.to_numpy", "modulename": "rat.variables", "qualname": "Data.to_numpy", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.Data.code", "modulename": "rat.variables", "qualname": "Data.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.Param", "modulename": "rat.variables", "qualname": "Param", "type": "class", "doc": "<p>Param(name: str, index: rat.variables.Index = None, lower: float = -inf, upper: float = inf)</p>\n"}, {"fullname": "rat.variables.Param.__init__", "modulename": "rat.variables", "qualname": "Param.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "name", "index", "lower", "upper"], "funcdef": "def"}, {"fullname": "rat.variables.Param.index", "modulename": "rat.variables", "qualname": "Param.index", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.variables.Param.lower", "modulename": "rat.variables", "qualname": "Param.lower", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.variables.Param.upper", "modulename": "rat.variables", "qualname": "Param.upper", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.variables.Param.set_constraints", "modulename": "rat.variables", "qualname": "Param.set_constraints", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "lower", "upper"], "funcdef": "def"}, {"fullname": "rat.variables.Param.scalar", "modulename": "rat.variables", "qualname": "Param.scalar", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.Param.size", "modulename": "rat.variables", "qualname": "Param.size", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.Param.padded_size", "modulename": "rat.variables", "qualname": "Param.padded_size", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.Param.code", "modulename": "rat.variables", "qualname": "Param.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.AssignedParam", "modulename": "rat.variables", "qualname": "AssignedParam", "type": "class", "doc": "<p>AssignedParam(ops_param: None, rhs: None, index: rat.variables.Index = None)</p>\n"}, {"fullname": "rat.variables.AssignedParam.__init__", "modulename": "rat.variables", "qualname": "AssignedParam.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ops_param", "rhs", "index"], "funcdef": "def"}, {"fullname": "rat.variables.AssignedParam.index", "modulename": "rat.variables", "qualname": "AssignedParam.index", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.variables.AssignedParam.size", "modulename": "rat.variables", "qualname": "AssignedParam.size", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.AssignedParam.code", "modulename": "rat.variables", "qualname": "AssignedParam.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.IndexUse", "modulename": "rat.variables", "qualname": "IndexUse", "type": "class", "doc": "<p>IndexUse(names: Tuple[str], df: pandas.core.frame.DataFrame, index: rat.variables.Index, shifts: Tuple[Optional[str]] = None)</p>\n"}, {"fullname": "rat.variables.IndexUse.__init__", "modulename": "rat.variables", "qualname": "IndexUse.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "names", "df", "index", "shifts"], "funcdef": "def"}, {"fullname": "rat.variables.IndexUse.shifts", "modulename": "rat.variables", "qualname": "IndexUse.shifts", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "rat.variables.IndexUse.to_numpy", "modulename": "rat.variables", "qualname": "IndexUse.to_numpy", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "rat.variables.IndexUse.code", "modulename": "rat.variables", "qualname": "IndexUse.code", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.addField("qualname");
            this.addField("fullname");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();