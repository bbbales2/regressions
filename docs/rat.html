<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 9.0.1" />
    <title>rat API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>

<script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    /* Re-invoke MathJax when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => MathJax.typeset()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script>
<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:2.5rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
            <div>

                        <img src="logo.jpg" class="logo" alt="project logo"/>

                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>

                    <h2>Contents</h2>
                    <ul>
  <li><a href="#language">Language</a>
  <ul>
    <li><a href="#anatomy-of-a-rat-program">Anatomy of a Rat (program)</a></li>
    <li><a href="#likelihood">Likelihood</a></li>
    <li><a href="#priors">Priors</a></li>
    <li><a href="#constraints">Constraints</a></li>
    <li><a href="#transformed-parameters">Transformed parameters</a></li>
    <li><a href="#shift-operator">Shift operator</a></li>
    <li><a href="#execution-order">Execution order</a></li>
    <li><a href="#distributions">Distributions</a></li>
    <li><a href="#functions">Functions</a></li>
    <li><a href="#operator-precedence-table">Operator Precedence Table</a></li>
  </ul></li>
  <li><a href="#installation-and-use">Installation and Use</a>
  <ul>
    <li><a href="#command-line-interface">Command line interface</a></li>
  </ul></li>
</ul>


                    <h2>Submodules</h2>
                    <ul>
                            <li><a href="rat/model.html">rat.model</a></li>
                            <li><a href="rat/fit.html">rat.fit</a></li>
                    </ul>

                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="module" href="#model">model</a>
            </li>
            <li>
                    <a class="module" href="#fit">fit</a>
            </li>
    </ul>



                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
rat    </h1>

                        <div class="docstring"><p>Rat is an attempt to build an easy to use regression syntax, particularly
focused on player skill models. It is similar in theme to the many fine
regression packages (lm, lme4, rstanarm, brms, etc.), but tries to take
its own twist on the problem.</p>

<p>Some central Rat features are:</p>

<ol>
<li>Parameters are named explicitly</li>
<li>Parameters are defined by their use</li>
<li>Long-form dataframes are the data structure for everything (data and parameters)</li>
</ol>

<p>Some central technical pieces are:</p>

<ol>
<li>Rat uses a No-U-Turn-Sampler (following implementation in <a href="https://arxiv.org/pdf/1701.02434.pdf">Betancourt</a>)</li>
<li>Rat uses autodiff from <a href="https://github.com/google/jax">jax</a></li>
</ol>

<p>Rat works in a limited language space to keep the backend stuff simple
(no sampling discrete parameters and no loops).</p>

<h1 id="language">Language</h1>

<h2 id="anatomy-of-a-rat-program">Anatomy of a Rat (program)</h2>

<p>There are two full Rat examples included with the repo that are worth glancing at.
The first (<a href="https://github.com/bbbales2/regressions/tree/main/examples/mrp">examples/mrp</a>)
is an MRP example ported from
<a href="https://bookdown.org/jl5522/MRP-case-studies/introduction-to-mrp.html">MRP Case Studies</a>.</p>

<p>The second (<a href="https://github.com/bbbales2/regressions/tree/main/examples/fakeball">examples/fakeball</a>)
is an attempt to simulate some fake basketball-like data and estimate player on-off
effectiveness numbers.</p>

<p>The example folders contain information on how to run these models, but a quick look at
the second model might be useful to see where we're going with all this:</p>

<pre><code># We're modeling whether or not shots were made as a function of the time
# varying skill of the five players playing offense and the five players
# playing defense. `made`, `date`, `o0-o4`, and `d0-d4` come from the input,
# dataframe. o0-o4 and d0-d4 are names of the five players on the floor
# playing offense and defense
made ~ bernoulli_logit(
    offense[o0, date] + offense[o1, date] + offense[o2, date] + offense[o3, date] + offense[o4, date] -
    (defense[d0, date] + defense[d1, date] + defense[d2, date] + defense[d3, date] + defense[d4, date])
);

# A player's skill is a function of their initial skill plus some random
# walk that changes over time
offense[player, date] = offense0[player] + offense_rw[player, date];
defense[player, date] = defense0[player] + defense_rw[player, date];

# Parameters are defined by use -- we need to define offense0 and defense0
# because they are used elsewhere
offense0[player] ~ normal(0.0, tau0_offense);
defense0[player] ~ normal(0.0, tau0_defense);

# This is the random walk -- read on to understand how `shift` actually works
offense_rw[player, date] ~ normal(offense_rw[player, shift(date, 1)], tau_offense);
defense_rw[player, date] ~ normal(defense_rw[player, shift(date, 1)], tau_defense);

# Some parameters have constraints!
tau_offense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);
tau_defense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);
tau0_offense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);
tau0_defense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);
</code></pre>

<p>Assuming we've saved appropriate data in a file <code>shots.csv</code>, then a model like this can
be run on the command-line (or from Python, but the command line is convenient for
this sort of thing):</p>

<pre><code>rat fakeball.rat shots.csv samples
</code></pre>

<p>The output can be extracted and summarized in Python like:</p>

<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn"><a href="rat/fit.html">rat.fit</a></span> <span class="kn">import</span> <span class="n">load</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># Rat fits are serialized as parquet tables in folders</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="s2">&quot;samples&quot;</span><span class="p">)</span>

<span class="c1"># Each parameter is stored in its own table -- these can be joined together</span>
<span class="c1"># or summarized on their own</span>
<span class="n">offense_df</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">draws</span><span class="p">(</span><span class="s2">&quot;offense&quot;</span><span class="p">)</span>

<span class="c1"># In this case we can build a table mapping player, date tuples to parameter</span>
<span class="c1"># summaries</span>
<span class="n">offense_summary_df</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">offense_df</span>
    <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;player&quot;</span><span class="p">,</span> <span class="s2">&quot;date&quot;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">agg</span><span class="p">(</span>
        <span class="n">median</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;offense&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">),</span>
        <span class="n">q10</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;offense&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)),</span>
        <span class="n">q90</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;offense&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)),</span>
    <span class="p">)</span>
<span class="p">)</span>
</code></pre></div>

<h2 id="likelihood">Likelihood</h2>

<p>Every Rat program comes with a dataframe. The dataframe defines the data which
the Rat model fits itself to.</p>

<p>Rat programs are broken up into statements separated by semicolons. There are
two types of statements, sampling statements (those where the lefthand side
and righthand side are separated by <code>~</code>) and assignments (the lefthand side
and righthand side are separated by <code>=</code>).</p>

<p>Sampling statements come in two varieties, likelihoods and priors. Likelihoods
are the sampling statements where the variable name on the left hand side of the
<code>~</code> comes from the input dataframe (and priors are the other ones). This section
discusses the basics of likelihood statements. Priors and assignments are discussed
later (under section <a href="#priors">Priors</a> and <a href="#transformed-parameters">Transformed Parameters</a>).</p>

<p>Assume we have the following dataframe:</p>

<pre><code>    game_id  home_score  away_score home_team away_team  score_diff  year
0         1         117          88       CLE       NYK        29.0  2016
1         2         113         104       POR       UTA         9.0  2016
2         3         100         129       GSW       SAS       -29.0  2016
3         4          96         108       ORL       MIA       -12.0  2016
4         5         130         121       IND       DAL         9.0  2016
5         6         122         117       BOS       BKN         5.0  2016
6         7         109          91       TOR       DET        18.0  2016
7         8          96         107       MIL       CHA       -11.0  2016
8         9         102          98       MEM       MIN         4.0  2016
9        10         102         107       NOP       DEN        -5.0  2016
10       11          97         103       PHI       CLE        -6.0  2016
</code></pre>

<p>The first line of a Rat program modeling this data might be:</p>

<pre><code>score_diff ~ normal(skill[home_team], sigma);
</code></pre>

<p>Because this is a sampling statement (the <code>~</code>) and name on the lefthand side
is in the dataframe, this is a likelihood statement.</p>

<p>This says model <code>score_diff</code> (the score difference between the home and away teams for a
handful of games in the 2016 NBA season) as a normally distributed random variable given
a mean <code>skill[home_team]</code> and standard deviation <code>sigma</code>. There will be one
term in the likelihood for every row in the dataframe (so each row corresponds
to a conditionally independent term).</p>

<p>The other column of the dataframe that is being used is <code>home_team</code>. If we
look back at the dataframe, <code>home_team</code> is a string identifying which NBA
team was playing at home in each game. In the model it appears in brackets
after the variable <code>skill</code> -- in Rat terms <code>home_team</code> <em>subscripts</em> <code>skill</code>.
This means for each row of the input dataframe, take the entry of the variable
skill that corresponds to the value of <code>home_team</code>.</p>

<p>Because <code>skill</code> is subscripted (and is not a column in the dataframe), Rat
infers that it is a parameter in the model. There will be as many unique
elements of <code>skill</code> as there are unique elements of <code>home_team</code>, because
this is exactly how many parameters need to exist to evaluate the likelihood.</p>

<p>Because <code>sigma</code> is not a column in the dataframe, Rat infers it is a parameter.
Because it is not subscripted, Rat infers it is a scalar parameter.</p>

<h2 id="priors">Priors</h2>

<p>Priors in Rat are sampling statements that are not likelihoods (the name on the
left hand side does not appear in the input dataframe). Priors cannot reference
columns of the input dataframe (it's an error).</p>

<p>The above example can be extended to have a prior on <code>skill</code>:</p>

<pre><code>score_diff ~ normal(skill[home_team], sigma);
skill[home_team] ~ normal(0.0, tau);
</code></pre>

<p>The first line defines <code>skill</code> by its use (it is a parameter with as many entries
as there are unique values of <code>home_team</code>). The second line says, for any entry of
skill, use a normal with standard deviation <code>tau</code>. Because <code>tau</code> is not used
anywhere yet, Rat will infer that it is a new scalar random variable.</p>

<p>The <code>home_team</code> subscript on the second line <em>matches</em> the subscript in the original
use. In the example above, this probably seems extraneous, but it is useful in more
complex cases. First consider a two-sided skill model:</p>

<pre><code>score_diff ~ normal(skill[home_team] - skill[away_team], sigma);
skill[team] ~ normal(0.0, tau);
</code></pre>

<p>In this case, <code>skill</code> is subscripted both by <code>home_team</code> and <code>away_team</code> and
there will be as many elements of <code>skill</code> as required in both cases (it's possible
some teams only played away games -- perhaps we're running this regression early in the
year). This leads to the question -- how should the first subscript of <code>skill</code> be
referenced? It is not obvious, and so when the prior is defined, the subscripts
are matched by position and we provide a new name. The first subscript to <code>skill</code>
will be called <code>team</code> for the purposes of defining the prior and handling output. The
subscript values themselves are defined by the use of the <code>skill</code> parameter.</p>

<p>Naming the subscripts with the match is also useful for deeper parameter hierarchies.
For instance, this model may extend over many years, in which case we could write:</p>

<pre><code>score_diff ~ normal(skill[home_team, year] - skill[away_team, year], sigma);
skill[team, year] ~ normal(all_time_skill[team], tau);
</code></pre>

<p><code>skill</code> is now subscripted by two columns of the dataframe in two different ways,
<code>[home_team, year]</code> and <code>[away_team, year]</code>. There will be an element of <code>skill</code>
defined for every combination of home team and year, and away team and year.</p>

<p>The prior for the <code>[team, year]</code> element of <code>skill</code> is now a normal with mean
<code>all_time_skill[team]</code> and standard deviation <code>tau</code>. Because <code>all_time_skill</code>
does not exist and is a subscripted variable, Rat will infer that it is a parameter
with unique elements given by all possible values of teams.</p>

<p>Matching is done by parameter position. If we had swapped the <code>year</code> and <code>team</code>
subscripts in the prior we would still have a valid Rat model, but the elements of the <code>team</code>
subscript would correspond to the unique values of year in the original dataframe!</p>

<p>(Beware this:)</p>

<pre><code>skill[year, team] ~ normal(all_time_skill[team], tau);
</code></pre>

<h2 id="constraints">Constraints</h2>

<p>The model above won't get far without a prior on <code>tau</code>. Because <code>tau</code> is a
standard deviation, it must be constrained to be positive.</p>

<p>Rat adopts a similar constraint syntax to Stan:</p>

<pre><code>score_diff ~ normal(skill[home_team], sigma);
skill[home_team] ~ normal(0.0, tau);
tau&lt;lower = 0.0&gt; ~ normal(0.0, 1.0);
</code></pre>

<p>The constraint goes after the parameter name but before the subscripts. Rat
supports a <code>lower</code>, <code>upper</code> and a combination of the two constraints.</p>

<h2 id="transformed-parameters">Transformed parameters</h2>

<p>Rat may infer that a variable is a parameter by its use, but this parameter
doesn't necessarily need to be a parameter of the joint distribution sampled
with MCMC. Transformed parameters are immutable functions of other parameters
that are set in assignment statements (statements where the left and righthand
side is separated by an <code>=</code>).</p>

<p>One of the basic things transformed parameters let us do is implement a
non-centered parameterization. Internally Rat uses a NUTS sampler. It is useful to
reparameterize hierarchical models for NUTS to avoid
<a href="https://mc-stan.org/users/documentation/case-studies/divergences_and_bias.html">divergences</a>.</p>

<p>The eight schools data is as follows:</p>

<pre><code>    y  sigma  school
0  28     15       1
1   8     10       2
2  -3     16       3
3   7     11       4
4  -1      9       5
5   1     11       6
6  18     10       7
7  12     18       8
</code></pre>

<p>The rat code for the centered eight schools model is the following:</p>

<pre><code>y ~ normal(theta[school], sigma);
theta[school] ~ normal(mu, tau);
mu ~ normal(0, 5);
tau&lt;lower = 0.0&gt; ~ log_normal(0, 1);
</code></pre>

<p><code>y</code> and <code>sigma</code> come from the dataframe. Rat infers <code>theta</code> is a parameter
with one element for each school, and <code>mu</code> and <code>tau</code> are both scalar parameters.</p>

<p>This model is difficult for NUTS to sample. The non-centered eight
schools model is the following: </p>

<pre><code>y ~ normal(theta[school], sigma);
theta[school] = mu + z[school] * tau;
z[school] ~ normal(0, 1);
mu ~ normal(0, 5);
tau&lt;lower = 0.0&gt; ~ log_normal(0, 1);
</code></pre>

<p>The new line of code is the second -- in this case we say the elements of
<code>theta</code> are equal to the expression on the right hand side. Transformed
parameters are immutable, so once they are set they cannot be changed.
Similarly, a transformed parameter cannot be used on the righthand side of
its own assignment.</p>

<p>Variables on the right hand side of an assignment that Rat does not recognize
will be inferred as other parameters. In this case, <code>mu</code>, <code>tau</code>, and <code>z</code>,
the untransformed versions of <code>theta</code>.</p>

<h2 id="shift-operator">Shift operator</h2>

<p>The elements of non-scalar Rat parameters are sorted with respect to the
values of the subscripts (in the order of the subscripts, so the rightmost
subscript is sorted last). Because elements have an order, we can think
about a previous and next element. This is useful for time series models.</p>

<p>Going back to the basketball model, we might be interested in how a team's
skill changes year to year:</p>

<pre><code>score_diff ~ normal(skill[home_team, year] - skill[away_team, year], sigma);
skill[team, year] ~ normal(skill[team, shift(year, 1)], tau);
</code></pre>

<p>The shift of 1 on the <code>skill</code> year subscript means, for the given team, take
the previous year's <code>skill</code> as the mean in the prior for the current year.</p>

<p>Positive shifts mean take previous values of the <code>skill</code> parameter; negative
shifts mean take following values of the <code>skill</code> parameter. Any out of
bounds access on the <code>skill</code> parameter is replaced with a zero.</p>

<p>Multiple variables can be shifted different lengths (though each variable
gets its own shift). The shifts are done only within groups defined by the
unshifted parameters. That is a mouthful, but in terms of basketball example
this looks like:</p>

<table>
<thead>
<tr>
  <th><code>skill[team, year]</code></th>
  <th><code>skill[team, shift(year, 1)]</code></th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>skill[CHA, 2016]</code></td>
  <td><code>0</code></td>
</tr>
<tr>
  <td><code>skill[CHA, 2017]</code></td>
  <td><code>skill[CHA, 2016]</code></td>
</tr>
<tr>
  <td><code>skill[ATL, 2017]</code></td>
  <td><code>0</code></td>
</tr>
</tbody>
</table>

<p>A negative shift produces a different result:</p>

<table>
<thead>
<tr>
  <th><code>skill[team, year]</code></th>
  <th><code>skill[team, shift(year, -1)]</code></th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>skill[CHA, 2016]</code></td>
  <td><code>skill[CHA, 2017]</code></td>
</tr>
<tr>
  <td><code>skill[CHA, 2017]</code></td>
  <td><code>0</code></td>
</tr>
<tr>
  <td><code>skill[ATL, 2017]</code></td>
  <td><code>0</code></td>
</tr>
</tbody>
</table>

<h2 id="execution-order">Execution order</h2>

<p>Rat sorts statements to make sure they are evaluated in an order so that
all transformed parameters are set before they are used. This means the user
does not need to worry about statement order -- just that there are either priors
or assignments for every parameter used in the program.</p>

<h2 id="distributions">Distributions</h2>

<p>$\mathcal{R}$ here means all real numbers and $\mathcal{R}^+$ means real numbers greater than zero.</p>

<table>
<thead>
<tr>
  <th>Distribution</th>
  <th>Constraints</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>y ~ bernoulli_logit(logit_p)</code></td>
  <td>$y = 0$ or $y = 1$, $\text{logit_p} \in \mathcal{R}$</td>
</tr>
<tr>
  <td><code>y ~ cauchy(location, scale)</code></td>
  <td>$y, \text{location} \in \mathcal{R}$, $\text{scale} \in \mathcal{R}^+$</td>
</tr>
<tr>
  <td><code>y ~ exponential(scale)</code></td>
  <td>$y, \text{scale} \in \mathcal{R}^+$</td>
</tr>
<tr>
  <td><code>y ~ log_normal(mu, sigma)</code></td>
  <td>$\text{mu} \in \mathcal{R}$, $y, \text{sigma} \in \mathcal{R}^+$</td>
</tr>
<tr>
  <td><code>y ~ normal(mu, sigma)</code></td>
  <td>$y, \text{mu} \in \mathcal{R}$, $\text{sigma} \in \mathcal{R}^+$</td>
</tr>
</tbody>
</table>

<h2 id="functions">Functions</h2>

<ul>
<li><code>abs(x)</code></li>
<li><code>arccos(x)</code></li>
<li><code>arcsin(x)</code></li>
<li><code>arctan(x)</code></li>
<li><code>ceil(x)</code></li>
<li><code>cos(x)</code></li>
<li><code>exp(x)</code></li>
<li><code>floor(x)</code></li>
<li><code>inverse_logit(x)</code></li>
<li><code>log(x)</code></li>
<li><code>logit(x)</code></li>
<li><code>round(x)</code></li>
<li><code>sin(x)</code></li>
<li><code>tan(x)</code></li>
</ul>

<h2 id="operator-precedence-table">Operator Precedence Table</h2>

<table>
<thead>
<tr>
  <th>Operator</th>
  <th style="text-align:center;">Precedence</th>
</tr>
</thead>
<tbody>
<tr>
  <td>function calls(<code>exp</code>, <code>log</code>, etc.)</td>
  <td style="text-align:center;">100, leftmost derivative</td>
</tr>
<tr>
  <td>prefix negation(<code>-10</code>, <code>-(1+2)</code>, etc.)</td>
  <td style="text-align:center;">50</td>
</tr>
<tr>
  <td><code>^</code></td>
  <td style="text-align:center;">40</td>
</tr>
<tr>
  <td><code>*</code>, <code>/</code>, <code>%</code></td>
  <td style="text-align:center;">30</td>
</tr>
<tr>
  <td><code>+</code>, <code>-</code></td>
  <td style="text-align:center;">10</td>
</tr>
</tbody>
</table>

<h1 id="installation-and-use">Installation and Use</h1>

<p>Rat is only available from Github:</p>

<pre><code>git clone https://github.com/bbbales2/regressions
cd regressions
pip install .
</code></pre>

<h2 id="command-line-interface">Command line interface</h2>

<p>Rat is a Python library, but comes with a helper script <code><a href="">rat</a></code> to quickly compile and
run models.</p>

<p>For example, to fit a model <code>mrp.rat</code> with the data <code>mrp.csv</code> and save the results in
<code>output</code> we can do:</p>

<pre><code>rat mrp.rat mrp.csv output
</code></pre>

<p>Type <code>rat -h</code> for full usage info.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Rat is an attempt to build an easy to use regression syntax, particularly</span>
<span class="sd">focused on player skill models. It is similar in theme to the many fine</span>
<span class="sd">regression packages (lm, lme4, rstanarm, brms, etc.), but tries to take</span>
<span class="sd">its own twist on the problem.</span>

<span class="sd">Some central Rat features are:</span>

<span class="sd">1. Parameters are named explicitly</span>
<span class="sd">2. Parameters are defined by their use</span>
<span class="sd">3. Long-form dataframes are the data structure for everything (data and parameters)</span>

<span class="sd">Some central technical pieces are:</span>

<span class="sd">1. Rat uses a No-U-Turn-Sampler (following implementation in [Betancourt](https://arxiv.org/pdf/1701.02434.pdf))</span>
<span class="sd">2. Rat uses autodiff from [jax](https://github.com/google/jax)</span>

<span class="sd">Rat works in a limited language space to keep the backend stuff simple</span>
<span class="sd">(no sampling discrete parameters and no loops).</span>

<span class="sd"># Language</span>

<span class="sd">## Anatomy of a Rat (program)</span>

<span class="sd">There are two full Rat examples included with the repo that are worth glancing at.</span>
<span class="sd">The first ([examples/mrp](https://github.com/bbbales2/regressions/tree/main/examples/mrp))</span>
<span class="sd">is an MRP example ported from</span>
<span class="sd">[MRP Case Studies](https://bookdown.org/jl5522/MRP-case-studies/introduction-to-mrp.html).</span>

<span class="sd">The second ([examples/fakeball](https://github.com/bbbales2/regressions/tree/main/examples/fakeball))</span>
<span class="sd">is an attempt to simulate some fake basketball-like data and estimate player on-off</span>
<span class="sd">effectiveness numbers.</span>

<span class="sd">The example folders contain information on how to run these models, but a quick look at</span>
<span class="sd">the second model might be useful to see where we&#39;re going with all this:</span>

<span class="sd">```</span>
<span class="sd"># We&#39;re modeling whether or not shots were made as a function of the time</span>
<span class="sd"># varying skill of the five players playing offense and the five players</span>
<span class="sd"># playing defense. `made`, `date`, `o0-o4`, and `d0-d4` come from the input,</span>
<span class="sd"># dataframe. o0-o4 and d0-d4 are names of the five players on the floor</span>
<span class="sd"># playing offense and defense</span>
<span class="sd">made ~ bernoulli_logit(</span>
<span class="sd">    offense[o0, date] + offense[o1, date] + offense[o2, date] + offense[o3, date] + offense[o4, date] -</span>
<span class="sd">    (defense[d0, date] + defense[d1, date] + defense[d2, date] + defense[d3, date] + defense[d4, date])</span>
<span class="sd">);</span>

<span class="sd"># A player&#39;s skill is a function of their initial skill plus some random</span>
<span class="sd"># walk that changes over time</span>
<span class="sd">offense[player, date] = offense0[player] + offense_rw[player, date];</span>
<span class="sd">defense[player, date] = defense0[player] + defense_rw[player, date];</span>

<span class="sd"># Parameters are defined by use -- we need to define offense0 and defense0</span>
<span class="sd"># because they are used elsewhere</span>
<span class="sd">offense0[player] ~ normal(0.0, tau0_offense);</span>
<span class="sd">defense0[player] ~ normal(0.0, tau0_defense);</span>

<span class="sd"># This is the random walk -- read on to understand how `shift` actually works</span>
<span class="sd">offense_rw[player, date] ~ normal(offense_rw[player, shift(date, 1)], tau_offense);</span>
<span class="sd">defense_rw[player, date] ~ normal(defense_rw[player, shift(date, 1)], tau_defense);</span>

<span class="sd"># Some parameters have constraints!</span>
<span class="sd">tau_offense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);</span>
<span class="sd">tau_defense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);</span>
<span class="sd">tau0_offense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);</span>
<span class="sd">tau0_defense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);</span>
<span class="sd">```</span>

<span class="sd">Assuming we&#39;ve saved appropriate data in a file `shots.csv`, then a model like this can</span>
<span class="sd">be run on the command-line (or from Python, but the command line is convenient for</span>
<span class="sd">this sort of thing):</span>

<span class="sd">```</span>
<span class="sd">rat fakeball.rat shots.csv samples</span>
<span class="sd">```</span>

<span class="sd">The output can be extracted and summarized in Python like:</span>

<span class="sd">```python</span>
<span class="sd">from rat.fit import load</span>
<span class="sd">import numpy</span>

<span class="sd"># Rat fits are serialized as parquet tables in folders</span>
<span class="sd">fit = load(&quot;samples&quot;)</span>

<span class="sd"># Each parameter is stored in its own table -- these can be joined together</span>
<span class="sd"># or summarized on their own</span>
<span class="sd">offense_df = fit.draws(&quot;offense&quot;)</span>

<span class="sd"># In this case we can build a table mapping player, date tuples to parameter</span>
<span class="sd"># summaries</span>
<span class="sd">offense_summary_df = (</span>
<span class="sd">    offense_df</span>
<span class="sd">    .groupby([&quot;player&quot;, &quot;date&quot;])</span>
<span class="sd">    .agg(</span>
<span class="sd">        median=(&quot;offense&quot;, numpy.median),</span>
<span class="sd">        q10=(&quot;offense&quot;, lambda x: numpy.quantile(x, 0.1)),</span>
<span class="sd">        q90=(&quot;offense&quot;, lambda x: numpy.quantile(x, 0.9)),</span>
<span class="sd">    )</span>
<span class="sd">)</span>
<span class="sd">```</span>

<span class="sd">## Likelihood</span>

<span class="sd">Every Rat program comes with a dataframe. The dataframe defines the data which</span>
<span class="sd">the Rat model fits itself to.</span>

<span class="sd">Rat programs are broken up into statements separated by semicolons. There are</span>
<span class="sd">two types of statements, sampling statements (those where the lefthand side</span>
<span class="sd">and righthand side are separated by `~`) and assignments (the lefthand side</span>
<span class="sd">and righthand side are separated by `=`).</span>

<span class="sd">Sampling statements come in two varieties, likelihoods and priors. Likelihoods</span>
<span class="sd">are the sampling statements where the variable name on the left hand side of the</span>
<span class="sd">`~` comes from the input dataframe (and priors are the other ones). This section</span>
<span class="sd">discusses the basics of likelihood statements. Priors and assignments are discussed</span>
<span class="sd">later (under section [Priors](#priors) and [Transformed Parameters](#transformed-parameters)).</span>

<span class="sd">Assume we have the following dataframe:</span>

<span class="sd">```</span>
<span class="sd">    game_id  home_score  away_score home_team away_team  score_diff  year</span>
<span class="sd">0         1         117          88       CLE       NYK        29.0  2016</span>
<span class="sd">1         2         113         104       POR       UTA         9.0  2016</span>
<span class="sd">2         3         100         129       GSW       SAS       -29.0  2016</span>
<span class="sd">3         4          96         108       ORL       MIA       -12.0  2016</span>
<span class="sd">4         5         130         121       IND       DAL         9.0  2016</span>
<span class="sd">5         6         122         117       BOS       BKN         5.0  2016</span>
<span class="sd">6         7         109          91       TOR       DET        18.0  2016</span>
<span class="sd">7         8          96         107       MIL       CHA       -11.0  2016</span>
<span class="sd">8         9         102          98       MEM       MIN         4.0  2016</span>
<span class="sd">9        10         102         107       NOP       DEN        -5.0  2016</span>
<span class="sd">10       11          97         103       PHI       CLE        -6.0  2016</span>
<span class="sd">```</span>

<span class="sd">The first line of a Rat program modeling this data might be:</span>

<span class="sd">```</span>
<span class="sd">score_diff ~ normal(skill[home_team], sigma);</span>
<span class="sd">```</span>

<span class="sd">Because this is a sampling statement (the `~`) and name on the lefthand side</span>
<span class="sd">is in the dataframe, this is a likelihood statement.</span>

<span class="sd">This says model `score_diff` (the score difference between the home and away teams for a</span>
<span class="sd">handful of games in the 2016 NBA season) as a normally distributed random variable given</span>
<span class="sd">a mean `skill[home_team]` and standard deviation `sigma`. There will be one</span>
<span class="sd">term in the likelihood for every row in the dataframe (so each row corresponds</span>
<span class="sd">to a conditionally independent term).</span>

<span class="sd">The other column of the dataframe that is being used is `home_team`. If we</span>
<span class="sd">look back at the dataframe, `home_team` is a string identifying which NBA</span>
<span class="sd">team was playing at home in each game. In the model it appears in brackets</span>
<span class="sd">after the variable `skill` -- in Rat terms `home_team` *subscripts* `skill`.</span>
<span class="sd">This means for each row of the input dataframe, take the entry of the variable</span>
<span class="sd">skill that corresponds to the value of `home_team`.</span>

<span class="sd">Because `skill` is subscripted (and is not a column in the dataframe), Rat</span>
<span class="sd">infers that it is a parameter in the model. There will be as many unique</span>
<span class="sd">elements of `skill` as there are unique elements of `home_team`, because</span>
<span class="sd">this is exactly how many parameters need to exist to evaluate the likelihood.</span>

<span class="sd">Because `sigma` is not a column in the dataframe, Rat infers it is a parameter.</span>
<span class="sd">Because it is not subscripted, Rat infers it is a scalar parameter.</span>

<span class="sd">## Priors</span>

<span class="sd">Priors in Rat are sampling statements that are not likelihoods (the name on the</span>
<span class="sd">left hand side does not appear in the input dataframe). Priors cannot reference</span>
<span class="sd">columns of the input dataframe (it&#39;s an error).</span>

<span class="sd">The above example can be extended to have a prior on `skill`:</span>

<span class="sd">```</span>
<span class="sd">score_diff ~ normal(skill[home_team], sigma);</span>
<span class="sd">skill[home_team] ~ normal(0.0, tau);</span>
<span class="sd">```</span>

<span class="sd">The first line defines `skill` by its use (it is a parameter with as many entries</span>
<span class="sd">as there are unique values of `home_team`). The second line says, for any entry of</span>
<span class="sd">skill, use a normal with standard deviation `tau`. Because `tau` is not used</span>
<span class="sd">anywhere yet, Rat will infer that it is a new scalar random variable.</span>

<span class="sd">The `home_team` subscript on the second line *matches* the subscript in the original</span>
<span class="sd">use. In the example above, this probably seems extraneous, but it is useful in more</span>
<span class="sd">complex cases. First consider a two-sided skill model:</span>

<span class="sd">```</span>
<span class="sd">score_diff ~ normal(skill[home_team] - skill[away_team], sigma);</span>
<span class="sd">skill[team] ~ normal(0.0, tau);</span>
<span class="sd">```</span>

<span class="sd">In this case, `skill` is subscripted both by `home_team` and `away_team` and</span>
<span class="sd">there will be as many elements of `skill` as required in both cases (it&#39;s possible</span>
<span class="sd">some teams only played away games -- perhaps we&#39;re running this regression early in the</span>
<span class="sd">year). This leads to the question -- how should the first subscript of `skill` be</span>
<span class="sd">referenced? It is not obvious, and so when the prior is defined, the subscripts</span>
<span class="sd">are matched by position and we provide a new name. The first subscript to `skill`</span>
<span class="sd">will be called `team` for the purposes of defining the prior and handling output. The</span>
<span class="sd">subscript values themselves are defined by the use of the `skill` parameter.</span>

<span class="sd">Naming the subscripts with the match is also useful for deeper parameter hierarchies.</span>
<span class="sd">For instance, this model may extend over many years, in which case we could write:</span>

<span class="sd">```</span>
<span class="sd">score_diff ~ normal(skill[home_team, year] - skill[away_team, year], sigma);</span>
<span class="sd">skill[team, year] ~ normal(all_time_skill[team], tau);</span>
<span class="sd">```</span>

<span class="sd">`skill` is now subscripted by two columns of the dataframe in two different ways,</span>
<span class="sd">`[home_team, year]` and `[away_team, year]`. There will be an element of `skill`</span>
<span class="sd">defined for every combination of home team and year, and away team and year.</span>

<span class="sd">The prior for the `[team, year]` element of `skill` is now a normal with mean</span>
<span class="sd">`all_time_skill[team]` and standard deviation `tau`. Because `all_time_skill`</span>
<span class="sd">does not exist and is a subscripted variable, Rat will infer that it is a parameter</span>
<span class="sd">with unique elements given by all possible values of teams.</span>

<span class="sd">Matching is done by parameter position. If we had swapped the `year` and `team`</span>
<span class="sd">subscripts in the prior we would still have a valid Rat model, but the elements of the `team`</span>
<span class="sd">subscript would correspond to the unique values of year in the original dataframe!</span>

<span class="sd">(Beware this:)</span>

<span class="sd">```</span>
<span class="sd">skill[year, team] ~ normal(all_time_skill[team], tau);</span>
<span class="sd">```</span>

<span class="sd">## Constraints</span>

<span class="sd">The model above won&#39;t get far without a prior on `tau`. Because `tau` is a</span>
<span class="sd">standard deviation, it must be constrained to be positive.</span>

<span class="sd">Rat adopts a similar constraint syntax to Stan:</span>

<span class="sd">```</span>
<span class="sd">score_diff ~ normal(skill[home_team], sigma);</span>
<span class="sd">skill[home_team] ~ normal(0.0, tau);</span>
<span class="sd">tau&lt;lower = 0.0&gt; ~ normal(0.0, 1.0);</span>
<span class="sd">```</span>

<span class="sd">The constraint goes after the parameter name but before the subscripts. Rat</span>
<span class="sd">supports a `lower`, `upper` and a combination of the two constraints.</span>

<span class="sd">## Transformed parameters</span>

<span class="sd">Rat may infer that a variable is a parameter by its use, but this parameter</span>
<span class="sd">doesn&#39;t necessarily need to be a parameter of the joint distribution sampled</span>
<span class="sd">with MCMC. Transformed parameters are immutable functions of other parameters</span>
<span class="sd">that are set in assignment statements (statements where the left and righthand</span>
<span class="sd">side is separated by an `=`).</span>

<span class="sd">One of the basic things transformed parameters let us do is implement a</span>
<span class="sd">non-centered parameterization. Internally Rat uses a NUTS sampler. It is useful to</span>
<span class="sd">reparameterize hierarchical models for NUTS to avoid</span>
<span class="sd">[divergences](https://mc-stan.org/users/documentation/case-studies/divergences_and_bias.html).</span>

<span class="sd">The eight schools data is as follows:</span>
<span class="sd">```</span>
<span class="sd">    y  sigma  school</span>
<span class="sd">0  28     15       1</span>
<span class="sd">1   8     10       2</span>
<span class="sd">2  -3     16       3</span>
<span class="sd">3   7     11       4</span>
<span class="sd">4  -1      9       5</span>
<span class="sd">5   1     11       6</span>
<span class="sd">6  18     10       7</span>
<span class="sd">7  12     18       8</span>
<span class="sd">```</span>

<span class="sd">The rat code for the centered eight schools model is the following:</span>

<span class="sd">```</span>
<span class="sd">y ~ normal(theta[school], sigma);</span>
<span class="sd">theta[school] ~ normal(mu, tau);</span>
<span class="sd">mu ~ normal(0, 5);</span>
<span class="sd">tau&lt;lower = 0.0&gt; ~ log_normal(0, 1);</span>
<span class="sd">```</span>

<span class="sd">`y` and `sigma` come from the dataframe. Rat infers `theta` is a parameter</span>
<span class="sd">with one element for each school, and `mu` and `tau` are both scalar parameters.</span>

<span class="sd">This model is difficult for NUTS to sample. The non-centered eight</span>
<span class="sd">schools model is the following: </span>

<span class="sd">```</span>
<span class="sd">y ~ normal(theta[school], sigma);</span>
<span class="sd">theta[school] = mu + z[school] * tau;</span>
<span class="sd">z[school] ~ normal(0, 1);</span>
<span class="sd">mu ~ normal(0, 5);</span>
<span class="sd">tau&lt;lower = 0.0&gt; ~ log_normal(0, 1);</span>
<span class="sd">```</span>

<span class="sd">The new line of code is the second -- in this case we say the elements of</span>
<span class="sd">`theta` are equal to the expression on the right hand side. Transformed</span>
<span class="sd">parameters are immutable, so once they are set they cannot be changed.</span>
<span class="sd">Similarly, a transformed parameter cannot be used on the righthand side of</span>
<span class="sd">its own assignment.</span>

<span class="sd">Variables on the right hand side of an assignment that Rat does not recognize</span>
<span class="sd">will be inferred as other parameters. In this case, `mu`, `tau`, and `z`,</span>
<span class="sd">the untransformed versions of `theta`.</span>

<span class="sd">## Shift operator</span>

<span class="sd">The elements of non-scalar Rat parameters are sorted with respect to the</span>
<span class="sd">values of the subscripts (in the order of the subscripts, so the rightmost</span>
<span class="sd">subscript is sorted last). Because elements have an order, we can think</span>
<span class="sd">about a previous and next element. This is useful for time series models.</span>

<span class="sd">Going back to the basketball model, we might be interested in how a team&#39;s</span>
<span class="sd">skill changes year to year:</span>

<span class="sd">```</span>
<span class="sd">score_diff ~ normal(skill[home_team, year] - skill[away_team, year], sigma);</span>
<span class="sd">skill[team, year] ~ normal(skill[team, shift(year, 1)], tau);</span>
<span class="sd">```</span>

<span class="sd">The shift of 1 on the `skill` year subscript means, for the given team, take</span>
<span class="sd">the previous year&#39;s `skill` as the mean in the prior for the current year.</span>

<span class="sd">Positive shifts mean take previous values of the `skill` parameter; negative</span>
<span class="sd">shifts mean take following values of the `skill` parameter. Any out of</span>
<span class="sd">bounds access on the `skill` parameter is replaced with a zero.</span>

<span class="sd">Multiple variables can be shifted different lengths (though each variable</span>
<span class="sd">gets its own shift). The shifts are done only within groups defined by the</span>
<span class="sd">unshifted parameters. That is a mouthful, but in terms of basketball example</span>
<span class="sd">this looks like:</span>

<span class="sd">| `skill[team, year]` | `skill[team, shift(year, 1)]` |</span>
<span class="sd">| --------------------------------------------------- |</span>
<span class="sd">| `skill[CHA, 2016]`  | `0`                           |</span>
<span class="sd">| `skill[CHA, 2017]`  | `skill[CHA, 2016]`            |</span>
<span class="sd">| `skill[ATL, 2017]`  | `0`                           |</span>

<span class="sd">A negative shift produces a different result:</span>

<span class="sd">| `skill[team, year]` | `skill[team, shift(year, -1)]` |</span>
<span class="sd">| --------------------------------------------------- |</span>
<span class="sd">| `skill[CHA, 2016]`  | `skill[CHA, 2017]`            |</span>
<span class="sd">| `skill[CHA, 2017]`  | `0`                           |</span>
<span class="sd">| `skill[ATL, 2017]`  | `0`                           |</span>

<span class="sd">## Execution order</span>

<span class="sd">Rat sorts statements to make sure they are evaluated in an order so that</span>
<span class="sd">all transformed parameters are set before they are used. This means the user</span>
<span class="sd">does not need to worry about statement order -- just that there are either priors</span>
<span class="sd">or assignments for every parameter used in the program.</span>

<span class="sd">## Distributions</span>

<span class="sd">$\mathcal{R}$ here means all real numbers and $\mathcal{R}^+$ means real numbers greater than zero.</span>


<span class="sd">| Distribution | Constraints |</span>
<span class="sd">| ---------------------------|</span>
<span class="sd">| `y ~ bernoulli_logit(logit_p)` | $y = 0$ or $y = 1$, $\text{logit_p} \in \mathcal{R}$ |</span>
<span class="sd">| `y ~ cauchy(location, scale)` | $y, \text{location} \in \mathcal{R}$, $\text{scale} \in \mathcal{R}^+$ |</span>
<span class="sd">| `y ~ exponential(scale)` | $y, \text{scale} \in \mathcal{R}^+$ |</span>
<span class="sd">| `y ~ log_normal(mu, sigma)` | $\text{mu} \in \mathcal{R}$, $y, \text{sigma} \in \mathcal{R}^+$ |</span>
<span class="sd">| `y ~ normal(mu, sigma)` | $y, \text{mu} \in \mathcal{R}$, $\text{sigma} \in \mathcal{R}^+$ |</span>

<span class="sd">## Functions</span>

<span class="sd">* `abs(x)`</span>
<span class="sd">* `arccos(x)`</span>
<span class="sd">* `arcsin(x)`</span>
<span class="sd">* `arctan(x)`</span>
<span class="sd">* `ceil(x)`</span>
<span class="sd">* `cos(x)`</span>
<span class="sd">* `exp(x)`</span>
<span class="sd">* `floor(x)`</span>
<span class="sd">* `inverse_logit(x)`</span>
<span class="sd">* `log(x)`</span>
<span class="sd">* `logit(x)`</span>
<span class="sd">* `round(x)`</span>
<span class="sd">* `sin(x)`</span>
<span class="sd">* `tan(x)`</span>

<span class="sd">## Operator Precedence Table</span>

<span class="sd">|  Operator   |   Precedence   |</span>
<span class="sd">|------|:-----:|</span>
<span class="sd">| function calls(`exp`, `log`, etc.) | 100, leftmost derivative  |</span>
<span class="sd">| prefix negation(`-10`, `-(1+2)`, etc.) | 50 |</span>
<span class="sd">| `^`  | 40  |</span>
<span class="sd">| `*`, `/`, `%`  | 30  |</span>
<span class="sd">| `+`, `-`  | 10  |</span>

<span class="sd"># Installation and Use</span>

<span class="sd">Rat is only available from Github:</span>

<span class="sd">```</span>
<span class="sd">git clone https://github.com/bbbales2/regressions</span>
<span class="sd">cd regressions</span>
<span class="sd">pip install .</span>
<span class="sd">```</span>

<span class="sd">## Command line interface</span>

<span class="sd">Rat is a Python library, but comes with a helper script `rat` to quickly compile and</span>
<span class="sd">run models.</span>

<span class="sd">For example, to fit a model `mrp.rat` with the data `mrp.csv` and save the results in</span>
<span class="sd">`output` we can do:</span>

<span class="sd">```</span>
<span class="sd">rat mrp.rat mrp.csv output</span>
<span class="sd">```</span>

<span class="sd">Type `rat -h` for full usage info.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="s2">&quot;fit&quot;</span><span class="p">]</span>

<span class="n">_todo_figure_out_internal_docs</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">---</span>

<span class="s2">## Internals - `rat.variables`, `rat.ops`, `rat.variables.Subscript`, and `rat.variables.SubscriptUse`</span>
<span class="s2">(This portion is for people who want to dig into rat&#39;s source)</span>

<span class="s2">If you look closely at rat&#39;s source, you might notice something weird: There&#39;s a `rat.ops.Param` class and a `rat.variables.Param`. This also goes for `rat.ops.Data`, `rat.ops.Subscript`. `rat.ops` is designated as elements for the nodes of the parse tree that&#39;s generated by the parser. Since rat uses the parse tree to transpile to Python, we need to inject additional information regarding subscripts to the parse tree. This is where `rat.variables` comes into play: they are used to hold information regarding subscripts for a given parameter. I&#39;ll use the [skill model](#subscripts) example to explain:</span>

<span class="s2">The parser converts the skill model above into the following parse tree representations:</span>
<span class="s2">```</span>
<span class="s2">ops.Normal(</span>
<span class="s2">    ops.Data(&quot;score_diff&quot;),</span>
<span class="s2">    ops.Diff(</span>
<span class="s2">        ops.Param(&quot;skills&quot;, ops.Subscript((&quot;home_team&quot;, &quot;year&quot;))),</span>
<span class="s2">        ops.Param(&quot;skills&quot;, ops.Subscript((&quot;away_team&quot;, &quot;year&quot;))),</span>
<span class="s2">    ),</span>
<span class="s2">    ops.Param(&quot;sigma&quot;),</span>
<span class="s2">),</span>
<span class="s2">ops.Normal(</span>
<span class="s2">    ops.Param(&quot;skills&quot;, ops.Subscript((&quot;team&quot;, &quot;year&quot;))),</span>
<span class="s2">    ops.Param(&quot;skills_mu&quot;, ops.Subscript((&quot;year&quot;,))),</span>
<span class="s2">    ops.Param(&quot;tau&quot;),</span>
<span class="s2">),</span>
<span class="s2">ops.Normal(</span>
<span class="s2">    ops.Param(&quot;skills_mu&quot;, ops.Subscript((&quot;year&quot;,))),</span>
<span class="s2">    ops.RealConstant(0.0),</span>
<span class="s2">    ops.RealConstant(1.0),</span>
<span class="s2">),</span>
<span class="s2">ops.Normal(</span>
<span class="s2">    ops.Param(&quot;tau&quot;, lower=ops.RealConstant(0.0)),</span>
<span class="s2">    ops.RealConstant(0.0),</span>
<span class="s2">    ops.RealConstant(1.0),</span>
<span class="s2">),</span>
<span class="s2">ops.Normal(</span>
<span class="s2">    ops.Param(&quot;sigma&quot;, lower=ops.RealConstant(0.0)),</span>
<span class="s2">    ops.RealConstant(0.0),</span>
<span class="s2">    ops.RealConstant(1.0),</span>
<span class="s2">)</span>
<span class="s2">```</span>

<span class="s2">For each parameter we create a `rat.variables.Subscript` object which in essence hold the factors of the subscript. Recall `skills[team, year]` was in fact `skills[union(home_team, away_team), year]`. So we need a parameter for each team-year combination. `rat.variables.Subscript` internally stores a dataframe with columns `team` and `year`, which hold these unique combinations as reference subscripts.</span>

<span class="s2">But we might want to just subscript `home_team` from `team`. That is, we might only want a portion of the subscript. `rat.variables.SubscriptUse` is the object that maps a variable&#39;s subscripts to another variable&#39;s reference subscript(its `rat.variables.Subscript` object). If we just wanted to subscript `home_team` from `team`, it will compare the `home_team` dataframe with `team`&#39;s reference dataframe, and only select the combinations that are necessary.</span>

<span class="s2">---</span>

<span class="s2">## Language function reference</span>
<span class="s2">Below are individual links to supported math functions and distributions</span>

<span class="s2">- **Distributions**</span>
<span class="s2">    - `rat.ops.Normal` : `normal(mu, sigma)`</span>
<span class="s2">    - `rat.ops.BernoulliLogit`, `rat.compiler.bernoulli_logit` : `bernoulli_logit(p)`</span>
<span class="s2">    - `rat.ops.LogNormal`, `rat.compiler.log_normal`  : `log_normal(mu, sigma)`</span>
<span class="s2">    - `rat.ops.Cauchy`  : `cauchy(location, scale)`</span>
<span class="s2">    - `rat.ops.Exponential`  :  `exponential(scale)`</span>
<span class="s2">- **Functions**</span>
<span class="s2">    - `rat.ops.Log`: `log(x)`</span>
<span class="s2">    - `rat.ops.Exp` : `exp(x)`</span>
<span class="s2">    - `rat.ops.Abs` : `abs(x)`</span>
<span class="s2">    - `rat.ops.Floor` : `floor(x)`</span>
<span class="s2">    - `rat.ops.Ceil` : `ceil(x)`</span>
<span class="s2">    - `rat.ops.Round` : `round(x)`</span>
<span class="s2">    - `rat.ops.Sin` : `sin(x)`</span>
<span class="s2">    - `rat.ops.Cos` : `cos(x)`</span>
<span class="s2">    - `rat.ops.Tan` : `tan(x)`</span>
<span class="s2">    - `rat.ops.Arcsin` : `arcsin(x)`</span>
<span class="s2">    - `rat.ops.Arccos` : `arccos(x)`</span>
<span class="s2">    - `rat.ops.Arctan` : `arctan(x)`</span>
<span class="s2">    - `rat.ops.Logit` : `logit(x)`</span>
<span class="s2">    - `rat.ops.InverseLogit` : `inverse_logit(x)`</span>

<span class="s2">&quot;&quot;&quot;</span>
</pre></div>

        </details>

            </section>
                <section id="model">
                                <div class="attr module"><a class="headerlink" href="#model">#&nbsp;&nbsp</a>
<span class="name"><a href="rat/model.html">rat.model</a></span></div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">import</span> <span class="nn">jax.experimental.host_callback</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pandas</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">compiler</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">.scanner</span> <span class="kn">import</span> <span class="n">Scanner</span>
<span class="kn">from</span> <span class="nn">.parser</span> <span class="kn">import</span> <span class="n">Parser</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fit</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">nuts</span>


<span class="k">class</span> <span class="nc">Model</span><span class="p">:</span>
    <span class="n">log_density_jax</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span>
    <span class="n">log_density_jax_no_jac</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">device_data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">]</span>
    <span class="n">device_subscripts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">]</span>
    <span class="n">working_dir</span><span class="p">:</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span>
    <span class="n">compiled_model</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span>

    <span class="k">def</span> <span class="nf">_constrain_and_transform_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained_parameter_vector</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">jacobian_adjustment</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled_model</span><span class="o">.</span><span class="n">constrain_parameters</span><span class="p">(</span><span class="n">unconstrained_parameter_vector</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jacobian_adjustment</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled_model</span><span class="o">.</span><span class="n">transform_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_subscripts</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_log_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_jacobian</span><span class="p">,</span> <span class="n">unconstrained_parameter_vector</span><span class="p">):</span>
        <span class="c1"># Evaluate model log density given model, data, subscripts and unconstrained parameters</span>
        <span class="n">jacobian_adjustment</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constrain_and_transform_parameters</span><span class="p">(</span><span class="n">unconstrained_parameter_vector</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled_model</span><span class="o">.</span><span class="n">evaluate_densities</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_subscripts</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target</span> <span class="o">+</span> <span class="p">(</span><span class="n">jacobian_adjustment</span> <span class="k">if</span> <span class="n">include_jacobian</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_draws_and_dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device_unconstrained_draws</span><span class="p">):</span>
        <span class="n">unconstrained_draws</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">device_unconstrained_draws</span><span class="p">)</span>
        <span class="n">num_draws</span> <span class="o">=</span> <span class="n">unconstrained_draws</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">num_chains</span> <span class="o">=</span> <span class="n">unconstrained_draws</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">constrained_draws</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">constrain_and_transform_parameters_no_pad_jax</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constrain_and_transform_parameters</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">draw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_draws</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_chains</span><span class="p">):</span>
                <span class="n">jacobian_adjustment</span><span class="p">,</span> <span class="n">device_constrained_variables</span> <span class="o">=</span> <span class="n">constrain_and_transform_parameters_no_pad_jax</span><span class="p">(</span>
                    <span class="n">unconstrained_draws</span><span class="p">[</span><span class="n">draw</span><span class="p">,</span> <span class="n">chain</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">device_constrained_variable</span> <span class="ow">in</span> <span class="n">device_constrained_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constrained_draws</span><span class="p">:</span>
                        <span class="n">constrained_draws</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_draws</span><span class="p">,</span> <span class="n">num_chains</span><span class="p">)</span> <span class="o">+</span> <span class="n">device_constrained_variable</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">constrained_draws</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">draw</span><span class="p">,</span> <span class="n">chain</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">device_constrained_variable</span><span class="p">)</span>

        <span class="c1">## This is probably faster than above but uses more device memory</span>
        <span class="c1"># jacobian_adjustment, device_constrained_variables = self._constrain(unconstrained_draws, pad=False)</span>
        <span class="c1"># device_constrained_variables = {k : jax.numpy.array(v) for k, v in device_constrained_variables.items()}</span>
        <span class="c1"># target, device_constrained_variables = jax.vmap(jax.vmap(evaluate_program_with_data))(**device_constrained_variables)</span>

        <span class="c1"># Copy back to numpy arrays</span>
        <span class="n">base_dfs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_variables</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">assigned_parameter_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">subscript</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">base_dfs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">subscript</span><span class="o">.</span><span class="n">base_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_dfs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">constrained_draws</span><span class="p">,</span> <span class="n">base_dfs</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_df</span><span class="p">:</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">model_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parsed_lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ops</span><span class="o">.</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a model from a dataframe (`data_df`) and a model (specified as a string, `model_string`)</span>

<span class="sd">        The parsed_lines argument is for creating a model from an intermediate representation -- likely</span>
<span class="sd">        deprecated soon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_names</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">if</span> <span class="n">model_string</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parsed_lines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only one of model_string and parsed_lines can be non-None&quot;</span><span class="p">)</span>

            <span class="n">parsed_lines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">scanned_lines</span> <span class="o">=</span> <span class="n">Scanner</span><span class="p">(</span><span class="n">model_string</span><span class="p">)</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">scanned_line</span> <span class="ow">in</span> <span class="n">scanned_lines</span><span class="p">:</span>
                <span class="n">parsed_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Parser</span><span class="p">(</span><span class="n">scanned_line</span><span class="p">,</span> <span class="n">data_names</span><span class="p">,</span> <span class="n">model_string</span><span class="p">)</span><span class="o">.</span><span class="n">statement</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parsed_lines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;At least one of model_string or parsed_lines must be non-None&quot;</span><span class="p">)</span>

        <span class="p">(</span>
            <span class="n">data_variables</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_variables</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assigned_parameter_variables</span><span class="p">,</span>
            <span class="n">subscript_use_variables</span><span class="p">,</span>
            <span class="n">model_source_string</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">compiler</span><span class="o">.</span><span class="n">Compiler</span><span class="p">(</span><span class="n">data_df</span><span class="p">,</span> <span class="n">parsed_lines</span><span class="p">,</span> <span class="n">model_string</span><span class="p">)</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">working_dir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;rat.&quot;</span><span class="p">)</span>

        <span class="c1"># Write model source to file and compile and import it</span>
        <span class="n">model_source_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">working_dir</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;model_source.py&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_source_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">model_source_string</span><span class="p">)</span>

        <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="s2">&quot;compiled_model&quot;</span><span class="p">,</span> <span class="n">model_source_file</span><span class="p">)</span>
        <span class="n">compiled_model</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">compiled_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiled_model</span> <span class="o">=</span> <span class="n">compiled_model</span>

        <span class="c1"># Copy data to jax device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">device_put</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="c1"># Copy subscripts to jax device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device_subscripts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">subscript_use</span> <span class="ow">in</span> <span class="n">subscript_use_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device_subscripts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">device_put</span><span class="p">(</span><span class="n">subscript_use</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_density_jax</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_density</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_density_jax_no_jac</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_density</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled_model</span><span class="o">.</span><span class="n">unconstrained_parameter_size</span>

    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">retries</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maximize the log density. `chains` difference optimizations are initialized.</span>

<span class="sd">        An error is thrown if the different solutions are not all within tolerance of the</span>
<span class="sd">        median solution for each parameter. If only one chain is used, the tolerance is</span>
<span class="sd">        ignored.</span>

<span class="sd">        If any optimization fails, retry up to `retries` number of times.</span>

<span class="sd">        Initialize parameters in unconstrained space uniformly [-2, 2].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">negative_log_density</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">log_density_jax_no_jac</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

        <span class="n">grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">negative_log_density</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">grad_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">grad_device_array</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grad_device_array</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">unconstrained_draws</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">chains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">retry</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">retries</span><span class="p">):</span>
                <span class="n">params</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">init</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="n">init</span>

                <span class="n">solution</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">negative_log_density</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">grad_double</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">solution</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
                    <span class="n">unconstrained_draws</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">chain</span><span class="p">]</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">x</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimization failed on chain </span><span class="si">{</span><span class="n">chain</span><span class="si">}</span><span class="s2"> with message: </span><span class="si">{</span><span class="n">solution</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">constrained_draws</span><span class="p">,</span> <span class="n">base_dfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_draws_and_dfs</span><span class="p">(</span><span class="n">unconstrained_draws</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fit</span><span class="o">.</span><span class="n">OptimizationFit</span><span class="o">.</span><span class="n">_from_constrained_variables</span><span class="p">(</span><span class="n">constrained_draws</span><span class="p">,</span> <span class="n">base_dfs</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_draws</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">num_warmup</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">target_acceptance_rate</span><span class="o">=</span><span class="mf">0.85</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample the target log density using NUTS.</span>

<span class="sd">        Sample using `chains` different chains with parameters initialized in unconstrained</span>
<span class="sd">        space [-2, 2]. Use `num_warmup` draws to warmup and collect `num_draws` draws in each</span>
<span class="sd">        chain after warmup.</span>

<span class="sd">        Regardless of the value of `chains`, only one chain is used for warmup.</span>

<span class="sd">        `target_acceptance_rate` is the target acceptance rate for adaptation. Should be less</span>
<span class="sd">        than one and greater than zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Currently only doing warmup on one chain</span>
        <span class="n">initial_position</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">init</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span> <span class="o">-</span> <span class="n">init</span>

        <span class="k">assert</span> <span class="n">target_acceptance_rate</span> <span class="o">&lt;</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="n">target_acceptance_rate</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
        <span class="k">assert</span> <span class="n">num_warmup</span> <span class="o">&gt;</span> <span class="mi">200</span>

        <span class="k">def</span> <span class="nf">negative_log_density</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">log_density_jax</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="n">potential</span> <span class="o">=</span> <span class="n">nuts</span><span class="o">.</span><span class="n">Potential</span><span class="p">(</span><span class="n">negative_log_density</span><span class="p">,</span> <span class="n">chains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

        <span class="c1"># Ordered as (draws, chains, param)</span>
        <span class="n">unconstrained_draws</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_draws</span><span class="p">,</span> <span class="n">chains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">generate_draws</span><span class="p">():</span>
            <span class="n">stage_1_size</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="n">stage_3_size</span> <span class="o">=</span> <span class="mi">50</span>
            <span class="n">stage_2_size</span> <span class="o">=</span> <span class="n">num_warmup</span> <span class="o">-</span> <span class="n">stage_1_size</span> <span class="o">-</span> <span class="n">stage_3_size</span>

            <span class="n">initial_draw</span><span class="p">,</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">diagonal_inverse_metric</span> <span class="o">=</span> <span class="n">nuts</span><span class="o">.</span><span class="n">warmup</span><span class="p">(</span>
                <span class="n">potential</span><span class="p">,</span>
                <span class="n">rng</span><span class="p">,</span>
                <span class="n">initial_position</span><span class="p">,</span>
                <span class="n">target_accept_stat</span><span class="o">=</span><span class="n">target_acceptance_rate</span><span class="p">,</span>
                <span class="n">stage_1_size</span><span class="o">=</span><span class="n">stage_1_size</span><span class="p">,</span>
                <span class="n">stage_2_size</span><span class="o">=</span><span class="n">stage_2_size</span><span class="p">,</span>
                <span class="n">stage_3_size</span><span class="o">=</span><span class="n">stage_3_size</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">nuts</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">potential</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">initial_draw</span><span class="p">,</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">diagonal_inverse_metric</span><span class="p">,</span> <span class="n">num_draws</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">chains</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">generate_draws</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">chain</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
                <span class="n">unconstrained_draws</span><span class="p">[:,</span> <span class="n">chain</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

        <span class="n">constrained_draws</span><span class="p">,</span> <span class="n">base_dfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_draws_and_dfs</span><span class="p">(</span><span class="n">unconstrained_draws</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fit</span><span class="o">.</span><span class="n">SampleFit</span><span class="o">.</span><span class="n">_from_constrained_variables</span><span class="p">(</span><span class="n">constrained_draws</span><span class="p">,</span> <span class="n">base_dfs</span><span class="p">)</span>
</pre></div>

        </details>

    

                </section>
                <section id="fit">
                                <div class="attr module"><a class="headerlink" href="#fit">#&nbsp;&nbsp</a>
<span class="name"><a href="rat/fit.html">rat.fit</a></span></div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">arviz</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pandas</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">constraints</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">model</span>


<span class="k">def</span> <span class="nf">_check_writeable</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Write failed; </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> exists and overwrite is not True&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_write_dict_into_folder</span><span class="p">(</span><span class="n">dfs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dfs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">df_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.parquet&quot;</span><span class="p">)</span>
        <span class="n">_check_writeable</span><span class="p">(</span><span class="n">df_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">df_path</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_read_folder_into_dict</span><span class="p">(</span><span class="n">folder</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s2">/*.parquet&quot;</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="n">dfs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dfs</span>


<span class="k">def</span> <span class="nf">_build_constrained_dfs</span><span class="p">(</span>
    <span class="n">constrained_variables</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">],</span> <span class="n">base_dfs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re-sort parameters stored as dictionary of arrays into dataframes</span>

<span class="sd">    Scalar parameter arrays are expected to have shape (num_draws, num_chains) or (1, num_draws, num_chains)</span>
<span class="sd">    Vector parameter arrays are expected to have shape (size, num_draws, num_chains)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">draw_dfs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">constrained_variables</span><span class="p">:</span>
        <span class="n">constrained_variable</span> <span class="o">=</span> <span class="n">constrained_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrained_variable</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">constrained_variable</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">num_draws</span> <span class="o">=</span> <span class="n">constrained_variable</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">num_chains</span> <span class="o">=</span> <span class="n">constrained_variable</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">base_df</span> <span class="o">=</span> <span class="n">base_dfs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">base_df</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_draws</span> <span class="o">*</span> <span class="n">num_chains</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;chain&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_chains</span><span class="p">),</span> <span class="n">size</span> <span class="o">*</span> <span class="n">num_draws</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;draw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_draws</span><span class="p">),</span> <span class="n">size</span><span class="p">),</span> <span class="n">num_chains</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">constrained_variable</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="n">draw_dfs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>

    <span class="k">return</span> <span class="n">draw_dfs</span>


<span class="k">def</span> <span class="nf">_check_convergence_and_select_one_chain</span><span class="p">(</span><span class="n">draw_dfs</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
    <span class="c1"># Check that all the optimization solutions are vaguely close to each other</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">draw_df</span> <span class="ow">in</span> <span class="n">draw_dfs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">group_columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">draw_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;chain&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">grouped_df</span> <span class="o">=</span> <span class="n">draw_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_columns</span><span class="p">)</span>
            <span class="n">median_df</span> <span class="o">=</span> <span class="n">grouped_df</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">})</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="s2">&quot;median&quot;</span><span class="p">})</span>
            <span class="n">converged_df</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">draw_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">median_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">group_columns</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">absolute_difference</span><span class="o">=</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;median&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">abs</span><span class="p">())</span>
                <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">tolerance</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">()))</span>
                <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">converged</span><span class="o">=</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;absolute_difference&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;tolerance&quot;</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">not_converged</span> <span class="o">=</span> <span class="o">~</span><span class="n">converged_df</span><span class="p">[</span><span class="s2">&quot;converged&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">not_converged</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">converged_df</span><span class="p">[</span><span class="n">not_converged</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Difference optimizations [] didn&#39;t converge to within tolerance&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">draw_df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">median</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">absolute_differences</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">draw_df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">-</span> <span class="n">median</span><span class="p">)</span>
            <span class="n">thresholds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">tolerance</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">absolute_differences</span> <span class="o">&gt;</span> <span class="n">thresholds</span><span class="p">):</span>
                <span class="n">values_string</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
                <span class="n">differences_string</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">difference</span><span class="p">)</span> <span class="k">for</span> <span class="n">difference</span> <span class="ow">in</span> <span class="n">absolute_differences</span><span class="p">)</span>
                <span class="n">thresholds_string</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span> <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;For </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> [</span><span class="si">{</span><span class="n">values_string</span><span class="si">}</span><span class="s2">], absolute differences [</span><span class="si">{</span><span class="n">differences_string</span><span class="si">}</span><span class="s2">] exceed thresholds [</span><span class="si">{</span><span class="n">thresholds_string</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="p">)</span>

    <span class="c1"># Only copy one optimization result</span>
    <span class="n">output_draw_dfs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">draw_df</span> <span class="ow">in</span> <span class="n">draw_dfs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">output_draw_dfs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">draw_df</span><span class="p">[</span><span class="n">draw_df</span><span class="p">[</span><span class="s2">&quot;chain&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">output_draw_dfs</span>


<span class="k">class</span> <span class="nc">Fit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parent class for optimization/MCMC results</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">draw_dfs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">draws</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the draws for given parameter(s) with columns for the</span>
<span class="sd">        subscripts.</span>

<span class="sd">        If multiple parameter names given, outer join the tables for</span>
<span class="sd">        each name and return that result.</span>

<span class="sd">        For optimizations there will only ever be one draw in the</span>
<span class="sd">        results (the optimum).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_dfs</span><span class="p">[</span><span class="n">parameter_names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">draw_dfs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">draw_dfs</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">parameter_name</span> <span class="ow">in</span> <span class="n">parameter_names</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">pandas</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">),</span> <span class="n">draw_dfs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save results to a folder. If overwrite is true, overwrite</span>
<span class="sd">        existing files and folders</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">draws_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;draws&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">draws_folder</span><span class="p">)</span> <span class="ow">and</span> <span class="n">overwrite</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder </span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s2"> already exists and overwrite is not True&quot;</span><span class="p">)</span>
        <span class="n">_write_dict_into_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">draw_dfs</span><span class="p">,</span> <span class="n">draws_folder</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="n">type_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">)</span>
        <span class="n">_check_writeable</span><span class="p">(</span><span class="n">type_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OptimizationFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores optimization results</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draw_dfs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_dfs</span> <span class="o">=</span> <span class="n">draw_dfs</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_constrained_variables</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">constrained_variables</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">],</span> <span class="n">base_dfs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="n">draw_dfs</span> <span class="o">=</span> <span class="n">_build_constrained_dfs</span><span class="p">(</span><span class="n">constrained_variables</span><span class="p">,</span> <span class="n">base_dfs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_check_convergence_and_select_one_chain</span><span class="p">(</span><span class="n">draw_dfs</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">SampleFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores draws from an MCMC calculation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diag_dfs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draw_dfs</span><span class="p">,</span> <span class="n">diag_dfs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_dfs</span> <span class="o">=</span> <span class="n">draw_dfs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diag_dfs</span> <span class="o">=</span> <span class="n">diag_dfs</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_constrained_variables</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">constrained_variables</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">],</span> <span class="n">base_dfs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]):</span>
        <span class="c1"># Unpack draws into dataframes</span>
        <span class="n">draw_dfs</span> <span class="o">=</span> <span class="n">_build_constrained_dfs</span><span class="p">(</span><span class="n">constrained_variables</span><span class="p">,</span> <span class="n">base_dfs</span><span class="p">)</span>
        <span class="n">diag_dfs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">constrained_variable</span> <span class="ow">in</span> <span class="n">constrained_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Compute ess/rhat, must reshape from (draw, chain, param) to (chain, draw, param)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrained_variable</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">arviz_constrained_variable</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">constrained_variable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arviz_constrained_variable</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">constrained_variable</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">x_draws</span> <span class="o">=</span> <span class="n">arviz</span><span class="o">.</span><span class="n">convert_to_dataset</span><span class="p">(</span><span class="n">arviz_constrained_variable</span><span class="p">)</span>
            <span class="n">ess</span> <span class="o">=</span> <span class="n">arviz</span><span class="o">.</span><span class="n">ess</span><span class="p">(</span><span class="n">x_draws</span><span class="p">)[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">rhat</span> <span class="o">=</span> <span class="n">arviz</span><span class="o">.</span><span class="n">rhat</span><span class="p">(</span><span class="n">x_draws</span><span class="p">)[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="n">diag_dfs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_dfs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">ess</span><span class="o">=</span><span class="n">ess</span><span class="p">,</span> <span class="n">rhat</span><span class="o">=</span><span class="n">rhat</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">draw_dfs</span><span class="p">,</span> <span class="n">diag_dfs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get diagnostic dataframe for a given parameter. Diagnostics are currently</span>
<span class="sd">        effective sample size and rhat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">diag_dfs</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the SampleFit object to a folder. If overwrite is true, then overwrite</span>
<span class="sd">        existing files and use existing folders</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SampleFit</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="n">sample_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;SampleFit&quot;</span><span class="p">)</span>
        <span class="n">_write_dict_into_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diag_dfs</span><span class="p">,</span> <span class="n">sample_folder</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">folder</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">OptimizationFit</span><span class="p">,</span> <span class="n">SampleFit</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load an OptimizationFit/SampleFit from the folder in which</span>
<span class="sd">    it was saved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to read </span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s2">, folder doesn&#39;t exist&quot;</span><span class="p">)</span>

    <span class="n">type_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">type_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">type_string</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="n">draws_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;draws&quot;</span><span class="p">)</span>
    <span class="n">draw_dfs</span> <span class="o">=</span> <span class="n">_read_folder_into_dict</span><span class="p">(</span><span class="n">draws_folder</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">type_string</span> <span class="o">==</span> <span class="s2">&quot;OptimizationFit&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">OptimizationFit</span><span class="p">(</span><span class="n">draw_dfs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">type_string</span> <span class="o">==</span> <span class="s2">&quot;SampleFit&quot;</span><span class="p">:</span>
        <span class="n">sample_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;SampleFit&quot;</span><span class="p">)</span>
        <span class="n">diag_dfs</span> <span class="o">=</span> <span class="n">_read_folder_into_dict</span><span class="p">(</span><span class="n">sample_folder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SampleFit</span><span class="p">(</span><span class="n">draw_dfs</span><span class="p">,</span> <span class="n">diag_dfs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized type </span><span class="si">{</span><span class="n">type_string</span><span class="si">}</span><span class="s2"> found in </span><span class="si">{</span><span class="n">type_path</span><span class="si">}</span><span class="s2"> when loading </span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>