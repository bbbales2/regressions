<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 12.1.0"/>
    <title>rat API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;opacity:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .pdoc-alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:1rem center;margin-bottom:1rem;}.pdoc .pdoc-alert > *:last-child{margin-bottom:0;}.pdoc .pdoc-alert-note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc > section:not(.module-info) h1{font-size:1.5rem;font-weight:500;}.pdoc > section:not(.module-info) h2{font-size:1.4rem;font-weight:500;}.pdoc > section:not(.module-info) h3{font-size:1.3rem;font-weight:500;}.pdoc > section:not(.module-info) h4{font-size:1.2rem;}.pdoc > section:not(.module-info) h5{font-size:1.1rem;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(.module-info){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.view-source-toggle-state,.view-source-toggle-state ~ .pdoc-code{display:none;}.view-source-toggle-state:checked ~ .pdoc-code{display:block;}.view-source-button{display:inline-block;float:right;font-size:.75rem;line-height:1.5rem;color:var(--muted);padding:0 .4rem 0 1.3rem;cursor:pointer;text-indent:-2px;}.view-source-button > span{visibility:hidden;}.module-info .view-source-button{float:none;display:flex;justify-content:flex-end;margin:-1.2rem .4rem -.2rem 0;}.view-source-button::before{position:absolute;content:"View Source";display:list-item;list-style-type:disclosure-closed;}.view-source-toggle-state:checked ~ .attr .view-source-button::before,.view-source-toggle-state:checked ~ .view-source-button::before{list-style-type:disclosure-open;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc section:not(.module-info) .docstring{margin-left:clamp(0rem, 5vw - 2rem, 1rem);}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target,.pdoc .pdoc-code > pre > span:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc .pdoc-code > pre > span:target{display:block;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc *{scroll-margin:2rem;}.pdoc .pdoc-code .linenos{user-select:none;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc section, .pdoc .classattr{position:relative;}.pdoc .headerlink{--width:clamp(1rem, 3vw, 2rem);position:absolute;top:0;left:calc(0rem - var(--width));transition:all 100ms ease-in-out;opacity:0;}.pdoc .headerlink::before{content:"#";display:block;text-align:center;width:var(--width);height:2.3rem;line-height:2.3rem;font-size:1.5rem;}.pdoc .attr:hover ~ .headerlink,.pdoc *:target > .headerlink,.pdoc .headerlink:hover{opacity:1;}.pdoc .attr{display:block;margin:.5rem 0 .5rem;padding:.4rem .4rem .4rem 1rem;background-color:var(--accent);overflow-x:auto;}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{background-color:transparent;}.pdoc .param, .pdoc .return-annotation{white-space:pre;}.pdoc .signature.multiline .param{display:block;}.pdoc .signature.condensed .param{display:inline-block;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style><script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    /* Re-invoke MathJax when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => MathJax.typeset()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>
            <img src="logo.jpg" class="logo" alt="project logo"/>

            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>

        <h2>Contents</h2>
        <ul>
  <li><a href="#language">Language</a>
  <ul>
    <li><a href="#learning-by-example">Learning by Example</a></li>
    <li><a href="#learning-by-analogy">Learning by Analogy</a></li>
    <li><a href="#learning-by-actually-how-it-works">Learning by Actually How It Works</a></li>
    <li><a href="#transformed-parameters">Transformed parameters</a></li>
    <li><a href="#constraints">Constraints</a></li>
    <li><a href="#shift-operator">Shift operator</a></li>
    <li><a href="#multiple-input-dataframes">Multiple input dataframes</a></li>
    <li><a href="#sharp-edges-with-renaming">Sharp edges with renaming</a></li>
    <li><a href="#distributions">Distributions</a></li>
    <li><a href="#functions">Functions</a></li>
    <li><a href="#operator-precedence-table">Operator Precedence Table</a></li>
  </ul></li>
  <li><a href="#installation-and-use">Installation and Use</a>
  <ul>
    <li><a href="#command-line-interface">Command line interface</a></li>
  </ul></li>
</ul>


        <h2>Submodules</h2>
        <ul>
                <li><a href="rat/model.html">model</a></li>
                <li><a href="rat/fit.html">fit</a></li>
        </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev" target="_blank">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section class="module-info">
                    <h1 class="modulename">
rat    </h1>

                        <div class="docstring"><p>Rat is an attempt to build an easy to use regression syntax, particularly
focused on player skill models. It is similar in theme to the many fine
regression packages (lm, lme4, rstanarm, brms, etc.), but tries to put
its own twist on the problem. It shares many features with more full featured
statistical packages (Stan, PyMC3, Turing, Bean Machine), but is for a
more constrained problem space than those.</p>

<p>Some central Rat features are:</p>

<ol>
<li>Parameters are named explicitly</li>
<li>Parameters are defined by their use</li>
<li>Long-form dataframes are the data structure for everything (data and parameters)</li>
</ol>

<p>Some central technical pieces are:</p>

<ol>
<li>Rat uses a No-U-Turn-Sampler (following implementation in <a href="https://arxiv.org/pdf/1701.02434.pdf">Betancourt</a>)</li>
<li>Rat uses autodiff from <a href="https://github.com/google/jax">jax</a></li>
</ol>

<p>Rat works in a limited language space to keep the backend stuff simple
(no sampling discrete parameters and no loops).</p>

<h1 id="language">Language</h1>

<h2 id="learning-by-example">Learning by Example</h2>

<p>There are two full Rat examples included with the repo that are worth glancing at.
The first (<a href="https://github.com/bbbales2/regressions/tree/main/examples/mrp">examples/mrp</a>)
is an MRP example ported from
<a href="https://bookdown.org/jl5522/MRP-case-studies/introduction-to-mrp.html">MRP Case Studies</a>.</p>

<p>The second (<a href="https://github.com/bbbales2/regressions/tree/main/examples/fakeball">examples/fakeball</a>)
is an attempt to simulate some fake basketball-like data and estimate player on-off
effectiveness numbers.</p>

<p>The example folders contain information on how to run these models, but let us take
a quick glance at the fakeball example to at least expose ourselves to most of the features
Rat offers:</p>

<pre><code># We're modeling whether or not shots were made as a function of the time
#  varying skill of the five players playing offense and the five players
#  playing defense. `made`, `date`, `o0-o4`, and `d0-d4` come from one of
#  the input dataframes. o0-o4 and d0-d4 are names of the five players on
#  the floor playing offense and defense
made ~ bernoulli_logit(
    offense[o0, date] + offense[o1, date] + offense[o2, date] + offense[o3, date] + offense[o4, date] -
    (defense[d0, date] + defense[d1, date] + defense[d2, date] + defense[d3, date] + defense[d4, date])
);

# Offense and defense are represented as random walks with some initial condition
#  A second dataframe is passed to the program that contains the date for which every
#  player makes their first appearance
offense[player, date] = ifelse(first_appearance[player] == date, offense0[player], offense[player, shift(date, 1)] + epsilon_offense[player, date]);
defense[player, date] = ifelse(first_appearance[player] == date, defense0[player], defense[player, shift(date, 1)] + epsilon_defense[player, date]);

# These are centered parameterizations
offense0[player] ~ normal(0.0, tau0_offense);
defense0[player] ~ normal(0.0, tau0_defense);

epsilon_offense[player, date] ~ normal(0.0, tau_offense);
epsilon_defense[player, date] ~ normal(0.0, tau_defense);

# Some parameters have constraints!
tau_offense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);
tau_defense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);
tau0_offense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);
tau0_defense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);
</code></pre>

<p>Assuming we've saved appropriate data in a file <code>shots.csv</code>, then a model like this can
be run on the command-line (or from Python, but the command line is convenient for
this sort of thing):</p>

<pre><code>rat fakeball.rat samples shots.csv first_appearance.csv
</code></pre>

<p>The output can be extracted and summarized in Python like:</p>

<div class="pdoc-code codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn"><a href="rat/fit.html">rat.fit</a></span> <span class="kn">import</span> <span class="n">load</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># Rat fits are serialized as parquet tables in folders</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="s2">&quot;samples&quot;</span><span class="p">)</span>

<span class="c1"># Each parameter is stored in its own table -- these can be joined together</span>
<span class="c1"># or summarized on their own</span>
<span class="n">offense_df</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">draws</span><span class="p">(</span><span class="s2">&quot;offense&quot;</span><span class="p">)</span>

<span class="c1"># In this case we can build a table mapping player, date tuples to parameter</span>
<span class="c1"># summaries</span>
<span class="n">offense_summary_df</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">offense_df</span>
    <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;player&quot;</span><span class="p">,</span> <span class="s2">&quot;date&quot;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">agg</span><span class="p">(</span>
        <span class="n">median</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;offense&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">),</span>
        <span class="n">q10</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;offense&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)),</span>
        <span class="n">q90</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;offense&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)),</span>
    <span class="p">)</span>
<span class="p">)</span>
</code></pre></div>

<h2 id="learning-by-analogy">Learning by Analogy</h2>

<p>Rat builds on syntax and technology pioneered in a few different areas. To make the
connections clearer, we will call these connections out. Rat should be understood as
its own thing (learning by analogy is likely to be ineffective), but it was also
developed at a certain place and time and we believe the source material is enlightening.</p>

<p>Rat's <em>sampling</em> statements come from Stan:</p>

<pre><code>y' ~ normal(a * x + b, sigma);
</code></pre>

<p>This would compile in a Stan model -- the thing you should notice though is the single
tick mark. In Stan that would mean transpose but in Rat that has to do with
vectorization. In Rat as in Stan, sampling statements increment a hidden unormalized
log density variable (known as <code>target</code> in Stan). The statements themselves do
not actually lead to any sampling.</p>

<p>Rat uses dataframes as input, and by referencing columns of these dataframes Rat
programs can vectorize over them. This comes from the lm, lme4, brms, rstanarm world.</p>

<p>For instance, the above Rat program could be coupled with the dataframe:</p>

<pre><code> y, x
10, 1
15, 2
21, 3
24, 4
</code></pre>

<p>In this case, the sampling statement will accumulate four terms into the unnormalized
log density. In computing each term, the symbols <code>x</code> and <code>y</code> will be substituted with
values from the dataframe.</p>

<p>The same model could also be coupled with the following dataframe:</p>

<pre><code> y, x, sigma
10, 1,   1.1
15, 2,   2.0
21, 3,   1.7
24, 4,   0.9
</code></pre>

<p>In this case, the values for <code>sigma</code> would come from the dataframe as well.</p>

<p>This may lead you to ask, in any case, where do the values for <code>a</code> and <code>b</code> come from
(and <code>sigma</code> itself if we're using the first dataframe)?</p>

<p>We can see in the original sampling statement that there is enough information to
infer what <code>a</code>, <code>b</code>, and <code>sigma</code> are -- they are scalar parameters that we'll need
to do MCMC on.</p>

<p>How about something more complex? Let us estimate a logit scale win probability for a
group of teams based on some win loss data:</p>

<pre><code>made, player
   0,  curry
   0,  curry
   1,  curry
   1,  green
   0,  thompson
   1,  thomspon
</code></pre>

<pre><code>made' ~ bernoulli_logit(skill[player]);
</code></pre>

<p>In this case the syntax suggests that there is one <code>skill</code> parameter for each
player somewhere. Rat treats unresolved parameters like this like functions and
is in this way works similarly to Bean Machine.</p>

<p>This is more or less where learning by analogy ends for Rat</p>

<h2 id="learning-by-actually-how-it-works">Learning by Actually How It Works</h2>

<p>Rat programs are written as a series of unordered <em>statements</em> of which there are
two types, <em>sampling</em> statements and <em>assignment</em> statements.</p>

<p>Sampling statements take the form of two expressions separated by a <code>~</code> and
assignments have a variable on the left hand side of an <code>=</code> and an expression
on the right hand side.</p>

<p>[It would be nice if we could write down our grammar and put it here]</p>

<p>Statements and expressions in Rat are always written in terms of scalars. There
is no concept of vectors exposed in the language (yet).</p>

<p>Vectorization in Rat comes from an understanding of primary variables. In every
statement there will be exactly one primary variable. The rules for identifying
a primary variable are:</p>

<p>The rules for primary variable deduction are as follows (executed in order):</p>

<ol>
<li>Search for all variables in a statement</li>
<li>If there is only one variable, that is the primary variable</li>
<li>If there are multiple variables, then one must be marked with ' to indicate
it is the primary variable.</li>
</ol>

<p>Vectorization proceeds in two directions, depending on if the primary variable
is associated with an input dataframe or not.</p>

<p>If the identifier of the primary variable can be found in one of the input dataframes,
then vectorization for a statement is done by executing that statement across
all rows of the input dataframe with column-values of the input dataframe
exposed as local variables that can be referenced by name in the calculation.</p>

<p>If the identifier of the primary variable is not found in an input dataframe, then it
is understood to be a function. Vectorization is handled by executing the statement
across the domain of the function and exposing the named arguments as local variables.</p>

<p>Function domains for variables not in dataframes are computed from their use. As part
of compiling a Rat program, Rat must compute the smallest function domain for
every variable that allows the program to execute. This is done by repeatedly
running a Rat program, recording what functions are called for what arguments,
and repeating this process until the domains of all functions have stabilized.</p>

<p>It is entirely possible to write infinite recursions that make it impossible for
this calculation to succeed (in which case the compiler should throw an error).</p>

<p>To make this process possible, control flow in Rat cannot depend on non-data variables.</p>

<p>Values for non-primary variables in statements can come from three places (searched in this order):</p>

<ol>
<li>They can be exposed as local variables as part of the primary variable vectorization process</li>
<li>They can come from other input dataframes -- if the identifier matches a column in
another input dataframe then the subscript arguments are used to look up a unique value
(if there is no row or more than one row corresponding to the subscripts and error will
be thrown)</li>
<li>They can come from nowhere (yet)! Variables that cannot be pulled from dataframes
don't need values yet -- the Rat program can compile without them. These values are
exposed by the compiler to the sampler which is then responsible for providing them.
It is on these values that control flow in a Rat program cannot depend (because they
will not be available until after compilation, and Rat needs to know the control
flow at compilation to infer function domains).</li>
</ol>

<p>==================</p>

<p>Rat syntax is built for writing vectorized calculations across dataframes. The idea
is that this is a useful framework for conceptualizing multilevel regressions, and
Rat tries to make it easy to do this in code.</p>

<p>Rat is made of <em>statements</em>. A statement in Rat consists of two <em>expressions</em> (the left hand side
and right hand side expressions) separated by either an <code>~</code> or an <code>=</code> and ending in <code>;</code>.
Those where the lefthand side and righthand side are separated by <code>~</code> are called sampling statements,
and those where the lefthand side and righthand side are separated by <code>=</code> are called assignments.
Expressions are composed of <em>functions</em> and <em>variable references</em> and do not contain any intervening <code>~</code>, <code>=</code>, or
<code>;</code> characters.</p>

<p>A statement can be multiple lines, and any line can end with a <em>comment</em> separated with <code>#</code>.
There are no multiline comments.</p>

<p>For example, this is a valid sampling statement in Rat:</p>

<pre><code>score_diff' ~ normal( # It's a sampling statement!
    skill[home_team], # It's a regression with one group-level intercept!
    sigma);
</code></pre>

<p>Rat syntax vectorizes over dataframes. This means that each statement will produce code
that runs for each row in a dataframe. The dataframe that a statement vectorizes across is
called the <em>primary dataframe</em> -- there is exactly one primary dataframe per statement.</p>

<p>Rat statements resolve their primary dataframes in a process called <em>primary variable deduction</em>.
Every variable (a variable being a named symbol that is not a function) has exactly one dataframe
attached to it. To identify the primary dataframe, rat must identify the primary variable.</p>

<p>The rules for primary variable deduction are as follows (executed in order):</p>

<ol>
<li>There can only be one primary variable in a statement.</li>
<li>If a variable reference is <em>primed</em>, then that variable is the primary variable.</li>
<li>If there is no primed variable references, then all variables with non-empty dataframes are treated as prime.</li>
<li>If there are no variables with non-empty dataframes, the leftmost one is the primary one.</li>
<li>It is an error if anything other than one primary variable is identified.</li>
<li>A <em>parameter</em> can only be used as the primary variable in one statement.</li>
</ol>

<p>A variable reference can be primed if it ends with a <code>'</code>. A variable reference itself
is a variable name, an optional constraint, an optional sequence of <em>subscripts</em>, and an
followed by the optional prime symbol. In the example above, <code>score_diff</code>, <code>skill</code>, and
<code>sigma</code> are variable names. <code>home_team</code> is a subscript. <code>score_diff'</code>, <code>skill[home_team]</code>,
and <code>sigma</code> are the variable references, and <code>score_diff</code> is the primary variable.</p>

<p>Variables are associated with dataframes with the process of <em>variable dataframe deduction</em> (executed in order):</p>

<ol>
<li>Variables with names that match columns in an <em>input dataframe</em> take that input dataframe</li>
<li>If variable names match columns in multiple input dataframes, it is an error</li>
<li>Otherwise, variables references are associated with parameters. The dataframe of the parameter is the minimum
dataframe required to execute all statements it is used in.</li>
</ol>

<p>For the purposes of both dataframe deductions, Rat programs are understood top to bottom.</p>

<p>For the regression above, a suitable example of an input dataframe might be
(the point differentials for a number of NBA games from the 2016 season):</p>

<pre><code>    game_id  home_score  away_score home_team away_team  score_diff  year
0         1         117          88       CLE       NYK        29.0  2016
1         2         113         104       POR       UTA         9.0  2016
2         3         100         129       GSW       SAS       -29.0  2016
3         4          96         108       ORL       MIA       -12.0  2016
4         5         130         121       IND       DAL         9.0  2016
5         6         122         117       BOS       BKN         5.0  2016
6         7         109          91       TOR       DET        18.0  2016
7         8          96         107       MIL       CHA       -11.0  2016
8         9         102          98       MEM       MIN         4.0  2016
9        10         102         107       NOP       DEN        -5.0  2016
10       11          97         103       PHI       CLE        -6.0  2016
</code></pre>

<p>Because <code>score_diff</code> matches a column in this dataframe, assuming there are no
other dataframes, this dataframe becomes the primary dataframe for this statement.
Because <code>skill</code> and <code>sigma</code> do not appear as columns in this dataframe, they
will be parameters.</p>

<p>The statement will <em>execute</em> once for each line of this dataframe. As the statement runs,
it will substitute values from this dataframe into variables and subscripts that match
column names.</p>

<p>In this case, that means there must be a value in <code>skill</code> corresponding to each
of the home teams (<code>CLE, POR, GSW, ORL, IND, BOS, TOR, MIL, MEM, PHI</code>). Because there
is one subscript, the <code>skill</code> dataframe will have one column. The values in that column
will be extended as necessary to allow all the <code>home_team</code> references.</p>

<p>Because <code>sigma</code> has no subscripts, the minimum dataframe necessary to support it is
the empty dataframe.</p>

<p>Execution for a sampling statement means evaluating and accumulating the log density
given by the name of the distribution on the right hand side of the <code>~</code>.</p>

<p>Execution of assignments is described in <a href="#transformed-parameters">Transformed Parameters</a> and
<a href="#shift-operator">Shift operator</a>.</p>

<p>Considering the data, it may seem useful to predict the score differential of an NBA game
in terms of both teams' skills. A suitable model for this would be:</p>

<pre><code>score_diff' ~ normal(skill[home_team] - skill[away_team], sigma);
</code></pre>

<p>In this statement, there is an extra variable reference, <code>skill[away_team]</code>. Because of
this, the <code>skill</code> dataframe will need to be extended to support all the away teams as well
(adding all the teams but <code>CLE</code>, which is already there).</p>

<h2 id="transformed-parameters">Transformed parameters</h2>

<p>Modeling the <code>skill</code> parameter in the model above hierarchically with a non-centered
parameterization will be a good demonstration of assignment statements in Rat. As a reminder,
this sort of parameterization is useful for avoiding <a href="https://mc-stan.org/users/documentation/case-studies/divergences_and_bias.html">divergences</a>,
when doing MCMC using NUTS on multilevel models.</p>

<p>The non-centered parameterization takes the form:</p>

<pre><code>score_diff' ~ normal(skill[home_team] - skill[away_team], sigma);
skill[team]' = skill_z[team] * tau;
skill_z ~ normal(0.0, 1.0);
</code></pre>

<p>For the second statement <code>skill</code> is the primary variable, so the dataframe defined implicitly
in the first statement will be the primary dataframe for the second line. Because of the subscript,
the parameter <code>skill_z</code> will be created with a non-empty dataframe. Because it has no subscript,
the parameter <code>tau</code> is created using the empty dataframe.</p>

<p>The subscript of <code>skill</code> is <em>renamed</em> to <code>team</code> by use as a primary variable. Because the subscript
is referenced by two names in the first statement, its name is ambiguous. Subscripts in a
primary variable reference are <em>renaming subscripts</em>. Because a parameter can only be used
as a primary variable once, this renaming only happens once. The renaming is necessary
for two reasons:</p>

<ol>
<li>Rat needs the subscript to be named for output to work</li>
<li>Creating an underlying parameter <code>skill_z</code> for each <code>skill</code> requires that <code>skill_z</code> be
subscripted by the <code>skill</code> dataframe.</li>
</ol>

<p>The assignment itself works by evaluating the expression on the right hand side and writing
the transformed parameter on the left (and the variable on the left hand side must
be a parameter, not data). Transformed parameters are immutable, so once they are set
they cannot be changed. All uses of a transformed parameter must preceed the assignment. This
may seem non-intuitive coming from other languages, but in Rat parameter use defines the
parameters themselves -- the assignment will simply guarantee that the necessary values
get set. Rat statements will effectively be executed in reverse order as they are written.</p>

<p>In the final statement the prior for <code>skill_z</code> is defined. Because <code>skill_z</code> is the only variable
in the statement, its dataframe will be the primary dataframe (and there is no need to prime it
manually). Because the use uniquely defines a name for the subscript, there is no need to rename it.</p>

<h2 id="constraints">Constraints</h2>

<p>The model above won't get far without a prior on <code>tau</code>. Because <code>tau</code> is a
standard deviation, it must be constrained to be positive.</p>

<p>Rat adopts a similar constraint syntax to Stan:</p>

<pre><code>score_diff' ~ normal(skill[home_team] - skill[away_team], sigma);
skill[team]' = skill_z[team] * tau;
skill_z ~ normal(0.0, 1.0);
tau&lt;lower = 0.0&gt; ~ normal(0.0, 1.0);
</code></pre>

<p>Constraints can only be used on parameters.</p>

<p>The constraint goes after the parameter name but before the subscripts. Rat
supports a <code>lower</code>, <code>upper</code> and a combination of the two constraints.</p>

<h2 id="shift-operator">Shift operator</h2>

<p>The elements of Rat parameters are sorted with respect to the values of the
subscripts. The sorting is done by sorting the columns of the parameter
dataframe. This sorting is done in the order of the subscripts, so the
rightmost subscript is sorted last. The dataframes and parameter values having
a sorted order is covenient for time series data.</p>

<p>Going back to the basketball model, perhaps someone is interested in how a team's
skill changes year to year:</p>

<pre><code>score_diff' ~ normal(skill[home_team, year] - skill[away_team, year], sigma);
skill[team, year]' = skill[team, shift(year, 1)] + skill_z[team] * tau;
skill_z ~ normal(0.0, 1.0);
tau&lt;lower = 0.0&gt; ~ normal(0.0, 1.0);
</code></pre>

<p>The first line still determines what the dataframe for <code>skill</code> will look like,
though now there will be two columns instead of one, with rows corresponding to
the necessary team-year combinations.</p>

<p>The second line is still an assignment, but it is different because the variable
assigned on the left hand side is used on the right hand side. The notation,
<code>skill[team, shift(year, 1)]</code> means, "take the skill corresponding to this
team in the previous year" (the shift behaves like the pandas
<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.shift.html">shift</a>,
where a positive number means shift rows down the dataframe).</p>

<p>This works because:</p>

<ol>
<li>Rat statements are executed across rows of the primary dataframe</li>
<li>The primary dataframe is sorted in ascending order according to its subscripts</li>
<li>The primary dataframe is already defined -- there is not problem of terminating
this recursive statement</li>
<li>Out-of-bounds accesses do not throw errors but instead return zero (the value
zero itself, not the zeroth element of the array)</li>
</ol>

<p>Because of rules 1 and 2, when assigning a variable, it is possible to reference
the parts that have already been computed. Because of rules 3 and 4, there is no
problem with infinite recursions or edge cases.</p>

<p>For performance reasons when using recursive assignments:</p>

<ol>
<li>There can be at most one shifted subscript</li>
<li>The shifted subscript must appear lasts</li>
</ol>

<p>Currently for programmatic reasons, negative shifts are not allowed in recursive
assignments, though the goal is to allow this in the future.</p>

<h3 id="simpler-ways-to-shift">Simpler ways to shift</h3>

<p>The shift operator used in a recursive assignment is the trickiest of the shifts.</p>

<p>The above model can also be written with a centered parameterization:</p>

<pre><code>score_diff' ~ normal(skill[home_team, year] - skill[away_team, year], sigma);
skill[team, year]' ~ normal(skill[team, shift(year, 1)], tau);
tau&lt;lower = 0.0&gt; ~ normal(0.0, 1.0);
</code></pre>

<p>The difference here is that a sampling statement is not an assignment -- the parameters
here are parameters of the log density that the sampler explores. From a programmatic
perspective there is no recursion needed because the values for the parameters come
from somewhere else.</p>

<p>In this case, it is possible to shift on multiple subscripts and the shift can appear
on any subscript. These restrictions also aren't necessarys for non-recursive assignment.</p>

<h3 id="shifts-and-groups">Shifts and groups</h3>

<p>Shifts are done only within groups defined by the unshifted parameters. That is a mouthful,
but in terms of basketball example this looks like:</p>

<table>
<thead>
<tr>
  <th><code>skill[team, year]</code></th>
  <th><code>skill[team, shift(year, 1)]</code></th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>skill[CHA, 2016]</code></td>
  <td><code>0</code></td>
</tr>
<tr>
  <td><code>skill[CHA, 2017]</code></td>
  <td><code>skill[CHA, 2016]</code></td>
</tr>
<tr>
  <td><code>skill[ATL, 2017]</code></td>
  <td><code>0</code></td>
</tr>
</tbody>
</table>

<p>[WARNING: Currently negative shifts are not allowed in recursive assignments]</p>

<p>A negative shift produces a different result:</p>

<table>
<thead>
<tr>
  <th><code>skill[team, year]</code></th>
  <th><code>skill[team, shift(year, -1)]</code></th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>skill[CHA, 2016]</code></td>
  <td><code>skill[CHA, 2017]</code></td>
</tr>
<tr>
  <td><code>skill[CHA, 2017]</code></td>
  <td><code>0</code></td>
</tr>
<tr>
  <td><code>skill[ATL, 2017]</code></td>
  <td><code>0</code></td>
</tr>
</tbody>
</table>

<h2 id="multiple-input-dataframes">Multiple input dataframes</h2>

<p>A Rat program can take in multiple input dataframes. As a part of variable dataframe
deduction, every name will be associated with a dataframe (or an error will be thrown).</p>

<p>In the same way that parameters are handled, non-primary variable values are joined to
primary variables via subscripts. The major difference is that, because Rat allocates
parameter dataframes, it can be careful to avoid duplicate entries. Because dataframes
for data variables come from the outside, this must be verified by the user. It is an
error if rows in a dataframe are referenced in a way that makes them not unique.</p>

<p>As a simple example of using multiple dataframes, consider the eight schools data:</p>

<pre><code>y,sigma,school
28,15,1
8,10,2
-3,16,3
7,11,4
-1,9,5
1,11,6
18,10,7
12,18,8
</code></pre>

<p>Along with the eight schools model:</p>

<pre><code>y' ~ normal(theta[school], sigma);
theta' = mu + z[school] * tau;
z ~ normal(0, 1);
mu ~ normal(0, 5);
tau&lt;lower = 0.0&gt; ~ log_normal(0, 1);
</code></pre>

<p>In this case, it is possible to split the input dataframe in two, with one
dataframe for the <code>y</code> variable and one for <code>sigma</code>.</p>

<pre><code>y,school    sigma,school
28,1        15,1
8,2         10,2
-3,3        16,3
7,4         11,4
-1,5        9,5
1,6         11,6
18,7        10,7
12,8        18,8
</code></pre>

<p>In this case the two dataframes could be joined together on <code>school</code>.</p>

<p>However, if instead these are passed as two separate dataframes to a Rat program, then
they can be recombined in code by replacing:</p>

<pre><code>y' ~ normal(theta[school], sigma);
</code></pre>

<p>with</p>

<pre><code>y' ~ normal(theta[school], sigma[school]);
</code></pre>

<p>The variable <code>sigma</code> uses the second dataframe because there is no <code>sigma</code> in the first,
and the subscript <code>school</code> allows the two sets of data to be joined together. It would be
an error for the subscript <code>school</code> to not be there. In that case the join from <code>sigma</code>
to <code>y</code> would not be unique.</p>

<h2 id="sharp-edges-with-renaming">Sharp edges with renaming</h2>

<p>Subscript values are determined by position, which means it is possible to rename variables
in a very misleading way.</p>

<pre><code>score ~ normal(skill[team, year], sigma);
skill[year, team] ~ normal(all_time_skill[team], tau);
...
</code></pre>

<p>In the second line, the subscript names are reversed, which means that the values of
the <code>year</code> subscript on the second line will be the values of the <code>team</code> subscript on
the first line!</p>

<h2 id="distributions">Distributions</h2>

<p>$\mathcal{R}$ here means all real numbers and $\mathcal{R}^+$ means real numbers greater than zero.</p>

<table>
<thead>
<tr>
  <th>Distribution</th>
  <th>Constraints</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>y ~ bernoulli_logit(logit_p)</code></td>
  <td>$y = 0$ or $y = 1$, $\text{logit_p} \in \mathcal{R}$</td>
</tr>
<tr>
  <td><code>y ~ cauchy(location, scale)</code></td>
  <td>$y, \text{location} \in \mathcal{R}$, $\text{scale} \in \mathcal{R}^+$</td>
</tr>
<tr>
  <td><code>y ~ exponential(scale)</code></td>
  <td>$y, \text{scale} \in \mathcal{R}^+$</td>
</tr>
<tr>
  <td><code>y ~ log_normal(mu, sigma)</code></td>
  <td>$\text{mu} \in \mathcal{R}$, $y, \text{sigma} \in \mathcal{R}^+$</td>
</tr>
<tr>
  <td><code>y ~ normal(mu, sigma)</code></td>
  <td>$y, \text{mu} \in \mathcal{R}$, $\text{sigma} \in \mathcal{R}^+$</td>
</tr>
</tbody>
</table>

<h2 id="functions">Functions</h2>

<ul>
<li><code>abs(x)</code></li>
<li><code>arccos(x)</code></li>
<li><code>arcsin(x)</code></li>
<li><code>arctan(x)</code></li>
<li><code>ceil(x)</code></li>
<li><code>cos(x)</code></li>
<li><code>exp(x)</code></li>
<li><code>floor(x)</code></li>
<li><code>inverse_logit(x)</code></li>
<li><code>log(x)</code></li>
<li><code>logit(x)</code></li>
<li><code>round(x)</code></li>
<li><code>sin(x)</code></li>
<li><code>tan(x)</code></li>
</ul>

<h2 id="operator-precedence-table">Operator Precedence Table</h2>

<table>
<thead>
<tr>
  <th>Operator</th>
  <th style="text-align:center;">Precedence</th>
</tr>
</thead>
<tbody>
<tr>
  <td>function calls(<code>exp</code>, <code>log</code>, etc.)</td>
  <td style="text-align:center;">100, leftmost derivative</td>
</tr>
<tr>
  <td>prefix negation(<code>-10</code>, <code>-(1+2)</code>, etc.)</td>
  <td style="text-align:center;">50</td>
</tr>
<tr>
  <td><code>^</code></td>
  <td style="text-align:center;">40</td>
</tr>
<tr>
  <td><code>*</code>, <code>/</code>, <code>%</code></td>
  <td style="text-align:center;">30</td>
</tr>
<tr>
  <td><code>+</code>, <code>-</code></td>
  <td style="text-align:center;">10</td>
</tr>
<tr>
  <td><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>, <code>==</code></td>
  <td style="text-align:center;">5</td>
</tr>
</tbody>
</table>

<h1 id="installation-and-use">Installation and Use</h1>

<p>Rat is only available from Github, and requires <a href="https://www.rust-lang.org/">Rust</a> to
be installed to work.</p>

<p>First, follow the <a href="https://www.rust-lang.org/tools/install">Rust installation directions</a>.</p>

<p>Secondly, install rat from Github:</p>

<pre><code>git clone https://github.com/bbbales2/regressions
cd regressions
pip install .
</code></pre>

<h2 id="command-line-interface">Command line interface</h2>

<p>Rat is a Python library, but comes with a helper script <code><a href="">rat</a></code> to quickly compile and
run models.</p>

<p>For example, to fit a model <code>mrp.rat</code> with the data <code>mrp.csv</code> and save the results in
<code>output</code> we can do:</p>

<pre><code>rat mrp.rat mrp.csv output
</code></pre>

<p>Type <code>rat -h</code> for full usage info.</p>
</div>

                        <input id="rat-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">

                        <label class="view-source-button" for="rat-view-source"><span>View Source</span></label>

                        <div class="pdoc-code codehilite"><pre><span></span><span id="L-1"><a href="#L-1"><span class="linenos">  1</span></a><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-2"><a href="#L-2"><span class="linenos">  2</span></a>
</span><span id="L-3"><a href="#L-3"><span class="linenos">  3</span></a><span class="sd">Rat is an attempt to build an easy to use regression syntax, particularly</span>
</span><span id="L-4"><a href="#L-4"><span class="linenos">  4</span></a><span class="sd">focused on player skill models. It is similar in theme to the many fine</span>
</span><span id="L-5"><a href="#L-5"><span class="linenos">  5</span></a><span class="sd">regression packages (lm, lme4, rstanarm, brms, etc.), but tries to put</span>
</span><span id="L-6"><a href="#L-6"><span class="linenos">  6</span></a><span class="sd">its own twist on the problem. It shares many features with more full featured</span>
</span><span id="L-7"><a href="#L-7"><span class="linenos">  7</span></a><span class="sd">statistical packages (Stan, PyMC3, Turing, Bean Machine), but is for a</span>
</span><span id="L-8"><a href="#L-8"><span class="linenos">  8</span></a><span class="sd">more constrained problem space than those.</span>
</span><span id="L-9"><a href="#L-9"><span class="linenos">  9</span></a>
</span><span id="L-10"><a href="#L-10"><span class="linenos"> 10</span></a><span class="sd">Some central Rat features are:</span>
</span><span id="L-11"><a href="#L-11"><span class="linenos"> 11</span></a>
</span><span id="L-12"><a href="#L-12"><span class="linenos"> 12</span></a><span class="sd">1. Parameters are named explicitly</span>
</span><span id="L-13"><a href="#L-13"><span class="linenos"> 13</span></a><span class="sd">2. Parameters are defined by their use</span>
</span><span id="L-14"><a href="#L-14"><span class="linenos"> 14</span></a><span class="sd">3. Long-form dataframes are the data structure for everything (data and parameters)</span>
</span><span id="L-15"><a href="#L-15"><span class="linenos"> 15</span></a>
</span><span id="L-16"><a href="#L-16"><span class="linenos"> 16</span></a><span class="sd">Some central technical pieces are:</span>
</span><span id="L-17"><a href="#L-17"><span class="linenos"> 17</span></a>
</span><span id="L-18"><a href="#L-18"><span class="linenos"> 18</span></a><span class="sd">1. Rat uses a No-U-Turn-Sampler (following implementation in [Betancourt](https://arxiv.org/pdf/1701.02434.pdf))</span>
</span><span id="L-19"><a href="#L-19"><span class="linenos"> 19</span></a><span class="sd">2. Rat uses autodiff from [jax](https://github.com/google/jax)</span>
</span><span id="L-20"><a href="#L-20"><span class="linenos"> 20</span></a>
</span><span id="L-21"><a href="#L-21"><span class="linenos"> 21</span></a><span class="sd">Rat works in a limited language space to keep the backend stuff simple</span>
</span><span id="L-22"><a href="#L-22"><span class="linenos"> 22</span></a><span class="sd">(no sampling discrete parameters and no loops).</span>
</span><span id="L-23"><a href="#L-23"><span class="linenos"> 23</span></a>
</span><span id="L-24"><a href="#L-24"><span class="linenos"> 24</span></a><span class="sd"># Language</span>
</span><span id="L-25"><a href="#L-25"><span class="linenos"> 25</span></a>
</span><span id="L-26"><a href="#L-26"><span class="linenos"> 26</span></a><span class="sd">## Learning by Example</span>
</span><span id="L-27"><a href="#L-27"><span class="linenos"> 27</span></a>
</span><span id="L-28"><a href="#L-28"><span class="linenos"> 28</span></a><span class="sd">There are two full Rat examples included with the repo that are worth glancing at.</span>
</span><span id="L-29"><a href="#L-29"><span class="linenos"> 29</span></a><span class="sd">The first ([examples/mrp](https://github.com/bbbales2/regressions/tree/main/examples/mrp))</span>
</span><span id="L-30"><a href="#L-30"><span class="linenos"> 30</span></a><span class="sd">is an MRP example ported from</span>
</span><span id="L-31"><a href="#L-31"><span class="linenos"> 31</span></a><span class="sd">[MRP Case Studies](https://bookdown.org/jl5522/MRP-case-studies/introduction-to-mrp.html).</span>
</span><span id="L-32"><a href="#L-32"><span class="linenos"> 32</span></a>
</span><span id="L-33"><a href="#L-33"><span class="linenos"> 33</span></a><span class="sd">The second ([examples/fakeball](https://github.com/bbbales2/regressions/tree/main/examples/fakeball))</span>
</span><span id="L-34"><a href="#L-34"><span class="linenos"> 34</span></a><span class="sd">is an attempt to simulate some fake basketball-like data and estimate player on-off</span>
</span><span id="L-35"><a href="#L-35"><span class="linenos"> 35</span></a><span class="sd">effectiveness numbers.</span>
</span><span id="L-36"><a href="#L-36"><span class="linenos"> 36</span></a>
</span><span id="L-37"><a href="#L-37"><span class="linenos"> 37</span></a><span class="sd">The example folders contain information on how to run these models, but let us take</span>
</span><span id="L-38"><a href="#L-38"><span class="linenos"> 38</span></a><span class="sd">a quick glance at the fakeball example to at least expose ourselves to most of the features</span>
</span><span id="L-39"><a href="#L-39"><span class="linenos"> 39</span></a><span class="sd">Rat offers:</span>
</span><span id="L-40"><a href="#L-40"><span class="linenos"> 40</span></a>
</span><span id="L-41"><a href="#L-41"><span class="linenos"> 41</span></a><span class="sd">```</span>
</span><span id="L-42"><a href="#L-42"><span class="linenos"> 42</span></a><span class="sd"># We&#39;re modeling whether or not shots were made as a function of the time</span>
</span><span id="L-43"><a href="#L-43"><span class="linenos"> 43</span></a><span class="sd">#  varying skill of the five players playing offense and the five players</span>
</span><span id="L-44"><a href="#L-44"><span class="linenos"> 44</span></a><span class="sd">#  playing defense. `made`, `date`, `o0-o4`, and `d0-d4` come from one of</span>
</span><span id="L-45"><a href="#L-45"><span class="linenos"> 45</span></a><span class="sd">#  the input dataframes. o0-o4 and d0-d4 are names of the five players on</span>
</span><span id="L-46"><a href="#L-46"><span class="linenos"> 46</span></a><span class="sd">#  the floor playing offense and defense</span>
</span><span id="L-47"><a href="#L-47"><span class="linenos"> 47</span></a><span class="sd">made ~ bernoulli_logit(</span>
</span><span id="L-48"><a href="#L-48"><span class="linenos"> 48</span></a><span class="sd">    offense[o0, date] + offense[o1, date] + offense[o2, date] + offense[o3, date] + offense[o4, date] -</span>
</span><span id="L-49"><a href="#L-49"><span class="linenos"> 49</span></a><span class="sd">    (defense[d0, date] + defense[d1, date] + defense[d2, date] + defense[d3, date] + defense[d4, date])</span>
</span><span id="L-50"><a href="#L-50"><span class="linenos"> 50</span></a><span class="sd">);</span>
</span><span id="L-51"><a href="#L-51"><span class="linenos"> 51</span></a>
</span><span id="L-52"><a href="#L-52"><span class="linenos"> 52</span></a><span class="sd"># Offense and defense are represented as random walks with some initial condition</span>
</span><span id="L-53"><a href="#L-53"><span class="linenos"> 53</span></a><span class="sd">#  A second dataframe is passed to the program that contains the date for which every</span>
</span><span id="L-54"><a href="#L-54"><span class="linenos"> 54</span></a><span class="sd">#  player makes their first appearance</span>
</span><span id="L-55"><a href="#L-55"><span class="linenos"> 55</span></a><span class="sd">offense[player, date] = ifelse(first_appearance[player] == date, offense0[player], offense[player, shift(date, 1)] + epsilon_offense[player, date]);</span>
</span><span id="L-56"><a href="#L-56"><span class="linenos"> 56</span></a><span class="sd">defense[player, date] = ifelse(first_appearance[player] == date, defense0[player], defense[player, shift(date, 1)] + epsilon_defense[player, date]);</span>
</span><span id="L-57"><a href="#L-57"><span class="linenos"> 57</span></a>
</span><span id="L-58"><a href="#L-58"><span class="linenos"> 58</span></a><span class="sd"># These are centered parameterizations</span>
</span><span id="L-59"><a href="#L-59"><span class="linenos"> 59</span></a><span class="sd">offense0[player] ~ normal(0.0, tau0_offense);</span>
</span><span id="L-60"><a href="#L-60"><span class="linenos"> 60</span></a><span class="sd">defense0[player] ~ normal(0.0, tau0_defense);</span>
</span><span id="L-61"><a href="#L-61"><span class="linenos"> 61</span></a>
</span><span id="L-62"><a href="#L-62"><span class="linenos"> 62</span></a><span class="sd">epsilon_offense[player, date] ~ normal(0.0, tau_offense);</span>
</span><span id="L-63"><a href="#L-63"><span class="linenos"> 63</span></a><span class="sd">epsilon_defense[player, date] ~ normal(0.0, tau_defense);</span>
</span><span id="L-64"><a href="#L-64"><span class="linenos"> 64</span></a>
</span><span id="L-65"><a href="#L-65"><span class="linenos"> 65</span></a><span class="sd"># Some parameters have constraints!</span>
</span><span id="L-66"><a href="#L-66"><span class="linenos"> 66</span></a><span class="sd">tau_offense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);</span>
</span><span id="L-67"><a href="#L-67"><span class="linenos"> 67</span></a><span class="sd">tau_defense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);</span>
</span><span id="L-68"><a href="#L-68"><span class="linenos"> 68</span></a><span class="sd">tau0_offense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);</span>
</span><span id="L-69"><a href="#L-69"><span class="linenos"> 69</span></a><span class="sd">tau0_defense&lt;lower = 0.0&gt; ~ log_normal(0.0, 0.5);</span>
</span><span id="L-70"><a href="#L-70"><span class="linenos"> 70</span></a><span class="sd">```</span>
</span><span id="L-71"><a href="#L-71"><span class="linenos"> 71</span></a>
</span><span id="L-72"><a href="#L-72"><span class="linenos"> 72</span></a><span class="sd">Assuming we&#39;ve saved appropriate data in a file `shots.csv`, then a model like this can</span>
</span><span id="L-73"><a href="#L-73"><span class="linenos"> 73</span></a><span class="sd">be run on the command-line (or from Python, but the command line is convenient for</span>
</span><span id="L-74"><a href="#L-74"><span class="linenos"> 74</span></a><span class="sd">this sort of thing):</span>
</span><span id="L-75"><a href="#L-75"><span class="linenos"> 75</span></a>
</span><span id="L-76"><a href="#L-76"><span class="linenos"> 76</span></a><span class="sd">```</span>
</span><span id="L-77"><a href="#L-77"><span class="linenos"> 77</span></a><span class="sd">rat fakeball.rat samples shots.csv first_appearance.csv</span>
</span><span id="L-78"><a href="#L-78"><span class="linenos"> 78</span></a><span class="sd">```</span>
</span><span id="L-79"><a href="#L-79"><span class="linenos"> 79</span></a>
</span><span id="L-80"><a href="#L-80"><span class="linenos"> 80</span></a><span class="sd">The output can be extracted and summarized in Python like:</span>
</span><span id="L-81"><a href="#L-81"><span class="linenos"> 81</span></a>
</span><span id="L-82"><a href="#L-82"><span class="linenos"> 82</span></a><span class="sd">```python</span>
</span><span id="L-83"><a href="#L-83"><span class="linenos"> 83</span></a><span class="sd">from rat.fit import load</span>
</span><span id="L-84"><a href="#L-84"><span class="linenos"> 84</span></a><span class="sd">import numpy</span>
</span><span id="L-85"><a href="#L-85"><span class="linenos"> 85</span></a>
</span><span id="L-86"><a href="#L-86"><span class="linenos"> 86</span></a><span class="sd"># Rat fits are serialized as parquet tables in folders</span>
</span><span id="L-87"><a href="#L-87"><span class="linenos"> 87</span></a><span class="sd">fit = load(&quot;samples&quot;)</span>
</span><span id="L-88"><a href="#L-88"><span class="linenos"> 88</span></a>
</span><span id="L-89"><a href="#L-89"><span class="linenos"> 89</span></a><span class="sd"># Each parameter is stored in its own table -- these can be joined together</span>
</span><span id="L-90"><a href="#L-90"><span class="linenos"> 90</span></a><span class="sd"># or summarized on their own</span>
</span><span id="L-91"><a href="#L-91"><span class="linenos"> 91</span></a><span class="sd">offense_df = fit.draws(&quot;offense&quot;)</span>
</span><span id="L-92"><a href="#L-92"><span class="linenos"> 92</span></a>
</span><span id="L-93"><a href="#L-93"><span class="linenos"> 93</span></a><span class="sd"># In this case we can build a table mapping player, date tuples to parameter</span>
</span><span id="L-94"><a href="#L-94"><span class="linenos"> 94</span></a><span class="sd"># summaries</span>
</span><span id="L-95"><a href="#L-95"><span class="linenos"> 95</span></a><span class="sd">offense_summary_df = (</span>
</span><span id="L-96"><a href="#L-96"><span class="linenos"> 96</span></a><span class="sd">    offense_df</span>
</span><span id="L-97"><a href="#L-97"><span class="linenos"> 97</span></a><span class="sd">    .groupby([&quot;player&quot;, &quot;date&quot;])</span>
</span><span id="L-98"><a href="#L-98"><span class="linenos"> 98</span></a><span class="sd">    .agg(</span>
</span><span id="L-99"><a href="#L-99"><span class="linenos"> 99</span></a><span class="sd">        median=(&quot;offense&quot;, numpy.median),</span>
</span><span id="L-100"><a href="#L-100"><span class="linenos">100</span></a><span class="sd">        q10=(&quot;offense&quot;, lambda x: numpy.quantile(x, 0.1)),</span>
</span><span id="L-101"><a href="#L-101"><span class="linenos">101</span></a><span class="sd">        q90=(&quot;offense&quot;, lambda x: numpy.quantile(x, 0.9)),</span>
</span><span id="L-102"><a href="#L-102"><span class="linenos">102</span></a><span class="sd">    )</span>
</span><span id="L-103"><a href="#L-103"><span class="linenos">103</span></a><span class="sd">)</span>
</span><span id="L-104"><a href="#L-104"><span class="linenos">104</span></a><span class="sd">```</span>
</span><span id="L-105"><a href="#L-105"><span class="linenos">105</span></a>
</span><span id="L-106"><a href="#L-106"><span class="linenos">106</span></a><span class="sd">## Learning by Analogy</span>
</span><span id="L-107"><a href="#L-107"><span class="linenos">107</span></a>
</span><span id="L-108"><a href="#L-108"><span class="linenos">108</span></a><span class="sd">Rat builds on syntax and technology pioneered in a few different areas. To make the</span>
</span><span id="L-109"><a href="#L-109"><span class="linenos">109</span></a><span class="sd">connections clearer, we will call these connections out. Rat should be understood as</span>
</span><span id="L-110"><a href="#L-110"><span class="linenos">110</span></a><span class="sd">its own thing (learning by analogy is likely to be ineffective), but it was also</span>
</span><span id="L-111"><a href="#L-111"><span class="linenos">111</span></a><span class="sd">developed at a certain place and time and we believe the source material is enlightening.</span>
</span><span id="L-112"><a href="#L-112"><span class="linenos">112</span></a>
</span><span id="L-113"><a href="#L-113"><span class="linenos">113</span></a><span class="sd">Rat&#39;s *sampling* statements come from Stan:</span>
</span><span id="L-114"><a href="#L-114"><span class="linenos">114</span></a>
</span><span id="L-115"><a href="#L-115"><span class="linenos">115</span></a><span class="sd">```</span>
</span><span id="L-116"><a href="#L-116"><span class="linenos">116</span></a><span class="sd">y&#39; ~ normal(a * x + b, sigma);</span>
</span><span id="L-117"><a href="#L-117"><span class="linenos">117</span></a><span class="sd">```</span>
</span><span id="L-118"><a href="#L-118"><span class="linenos">118</span></a>
</span><span id="L-119"><a href="#L-119"><span class="linenos">119</span></a><span class="sd">This would compile in a Stan model -- the thing you should notice though is the single</span>
</span><span id="L-120"><a href="#L-120"><span class="linenos">120</span></a><span class="sd">tick mark. In Stan that would mean transpose but in Rat that has to do with</span>
</span><span id="L-121"><a href="#L-121"><span class="linenos">121</span></a><span class="sd">vectorization. In Rat as in Stan, sampling statements increment a hidden unormalized</span>
</span><span id="L-122"><a href="#L-122"><span class="linenos">122</span></a><span class="sd">log density variable (known as `target` in Stan). The statements themselves do</span>
</span><span id="L-123"><a href="#L-123"><span class="linenos">123</span></a><span class="sd">not actually lead to any sampling.</span>
</span><span id="L-124"><a href="#L-124"><span class="linenos">124</span></a>
</span><span id="L-125"><a href="#L-125"><span class="linenos">125</span></a><span class="sd">Rat uses dataframes as input, and by referencing columns of these dataframes Rat</span>
</span><span id="L-126"><a href="#L-126"><span class="linenos">126</span></a><span class="sd">programs can vectorize over them. This comes from the lm, lme4, brms, rstanarm world.</span>
</span><span id="L-127"><a href="#L-127"><span class="linenos">127</span></a>
</span><span id="L-128"><a href="#L-128"><span class="linenos">128</span></a><span class="sd">For instance, the above Rat program could be coupled with the dataframe:</span>
</span><span id="L-129"><a href="#L-129"><span class="linenos">129</span></a>
</span><span id="L-130"><a href="#L-130"><span class="linenos">130</span></a><span class="sd">```</span>
</span><span id="L-131"><a href="#L-131"><span class="linenos">131</span></a><span class="sd"> y, x</span>
</span><span id="L-132"><a href="#L-132"><span class="linenos">132</span></a><span class="sd">10, 1</span>
</span><span id="L-133"><a href="#L-133"><span class="linenos">133</span></a><span class="sd">15, 2</span>
</span><span id="L-134"><a href="#L-134"><span class="linenos">134</span></a><span class="sd">21, 3</span>
</span><span id="L-135"><a href="#L-135"><span class="linenos">135</span></a><span class="sd">24, 4</span>
</span><span id="L-136"><a href="#L-136"><span class="linenos">136</span></a><span class="sd">```</span>
</span><span id="L-137"><a href="#L-137"><span class="linenos">137</span></a>
</span><span id="L-138"><a href="#L-138"><span class="linenos">138</span></a><span class="sd">In this case, the sampling statement will accumulate four terms into the unnormalized</span>
</span><span id="L-139"><a href="#L-139"><span class="linenos">139</span></a><span class="sd">log density. In computing each term, the symbols `x` and `y` will be substituted with</span>
</span><span id="L-140"><a href="#L-140"><span class="linenos">140</span></a><span class="sd">values from the dataframe.</span>
</span><span id="L-141"><a href="#L-141"><span class="linenos">141</span></a>
</span><span id="L-142"><a href="#L-142"><span class="linenos">142</span></a><span class="sd">The same model could also be coupled with the following dataframe:</span>
</span><span id="L-143"><a href="#L-143"><span class="linenos">143</span></a>
</span><span id="L-144"><a href="#L-144"><span class="linenos">144</span></a><span class="sd">```</span>
</span><span id="L-145"><a href="#L-145"><span class="linenos">145</span></a><span class="sd"> y, x, sigma</span>
</span><span id="L-146"><a href="#L-146"><span class="linenos">146</span></a><span class="sd">10, 1,   1.1</span>
</span><span id="L-147"><a href="#L-147"><span class="linenos">147</span></a><span class="sd">15, 2,   2.0</span>
</span><span id="L-148"><a href="#L-148"><span class="linenos">148</span></a><span class="sd">21, 3,   1.7</span>
</span><span id="L-149"><a href="#L-149"><span class="linenos">149</span></a><span class="sd">24, 4,   0.9</span>
</span><span id="L-150"><a href="#L-150"><span class="linenos">150</span></a><span class="sd">```</span>
</span><span id="L-151"><a href="#L-151"><span class="linenos">151</span></a>
</span><span id="L-152"><a href="#L-152"><span class="linenos">152</span></a><span class="sd">In this case, the values for `sigma` would come from the dataframe as well.</span>
</span><span id="L-153"><a href="#L-153"><span class="linenos">153</span></a>
</span><span id="L-154"><a href="#L-154"><span class="linenos">154</span></a><span class="sd">This may lead you to ask, in any case, where do the values for `a` and `b` come from</span>
</span><span id="L-155"><a href="#L-155"><span class="linenos">155</span></a><span class="sd">(and `sigma` itself if we&#39;re using the first dataframe)?</span>
</span><span id="L-156"><a href="#L-156"><span class="linenos">156</span></a>
</span><span id="L-157"><a href="#L-157"><span class="linenos">157</span></a><span class="sd">We can see in the original sampling statement that there is enough information to</span>
</span><span id="L-158"><a href="#L-158"><span class="linenos">158</span></a><span class="sd">infer what `a`, `b`, and `sigma` are -- they are scalar parameters that we&#39;ll need</span>
</span><span id="L-159"><a href="#L-159"><span class="linenos">159</span></a><span class="sd">to do MCMC on.</span>
</span><span id="L-160"><a href="#L-160"><span class="linenos">160</span></a>
</span><span id="L-161"><a href="#L-161"><span class="linenos">161</span></a><span class="sd">How about something more complex? Let us estimate a logit scale win probability for a</span>
</span><span id="L-162"><a href="#L-162"><span class="linenos">162</span></a><span class="sd">group of teams based on some win loss data:</span>
</span><span id="L-163"><a href="#L-163"><span class="linenos">163</span></a>
</span><span id="L-164"><a href="#L-164"><span class="linenos">164</span></a><span class="sd">```</span>
</span><span id="L-165"><a href="#L-165"><span class="linenos">165</span></a><span class="sd">made, player</span>
</span><span id="L-166"><a href="#L-166"><span class="linenos">166</span></a><span class="sd">   0,  curry</span>
</span><span id="L-167"><a href="#L-167"><span class="linenos">167</span></a><span class="sd">   0,  curry</span>
</span><span id="L-168"><a href="#L-168"><span class="linenos">168</span></a><span class="sd">   1,  curry</span>
</span><span id="L-169"><a href="#L-169"><span class="linenos">169</span></a><span class="sd">   1,  green</span>
</span><span id="L-170"><a href="#L-170"><span class="linenos">170</span></a><span class="sd">   0,  thompson</span>
</span><span id="L-171"><a href="#L-171"><span class="linenos">171</span></a><span class="sd">   1,  thomspon</span>
</span><span id="L-172"><a href="#L-172"><span class="linenos">172</span></a><span class="sd">```</span>
</span><span id="L-173"><a href="#L-173"><span class="linenos">173</span></a>
</span><span id="L-174"><a href="#L-174"><span class="linenos">174</span></a><span class="sd">```</span>
</span><span id="L-175"><a href="#L-175"><span class="linenos">175</span></a><span class="sd">made&#39; ~ bernoulli_logit(skill[player]);</span>
</span><span id="L-176"><a href="#L-176"><span class="linenos">176</span></a><span class="sd">```</span>
</span><span id="L-177"><a href="#L-177"><span class="linenos">177</span></a>
</span><span id="L-178"><a href="#L-178"><span class="linenos">178</span></a><span class="sd">In this case the syntax suggests that there is one `skill` parameter for each</span>
</span><span id="L-179"><a href="#L-179"><span class="linenos">179</span></a><span class="sd">player somewhere. Rat treats unresolved parameters like this like functions and</span>
</span><span id="L-180"><a href="#L-180"><span class="linenos">180</span></a><span class="sd">is in this way works similarly to Bean Machine.</span>
</span><span id="L-181"><a href="#L-181"><span class="linenos">181</span></a>
</span><span id="L-182"><a href="#L-182"><span class="linenos">182</span></a><span class="sd">This is more or less where learning by analogy ends for Rat</span>
</span><span id="L-183"><a href="#L-183"><span class="linenos">183</span></a>
</span><span id="L-184"><a href="#L-184"><span class="linenos">184</span></a><span class="sd">## Learning by Actually How It Works</span>
</span><span id="L-185"><a href="#L-185"><span class="linenos">185</span></a>
</span><span id="L-186"><a href="#L-186"><span class="linenos">186</span></a><span class="sd">Rat programs are written as a series of unordered *statements* of which there are</span>
</span><span id="L-187"><a href="#L-187"><span class="linenos">187</span></a><span class="sd">two types, *sampling* statements and *assignment* statements.</span>
</span><span id="L-188"><a href="#L-188"><span class="linenos">188</span></a>
</span><span id="L-189"><a href="#L-189"><span class="linenos">189</span></a><span class="sd">Sampling statements take the form of two expressions separated by a `~` and</span>
</span><span id="L-190"><a href="#L-190"><span class="linenos">190</span></a><span class="sd">assignments have a variable on the left hand side of an `=` and an expression</span>
</span><span id="L-191"><a href="#L-191"><span class="linenos">191</span></a><span class="sd">on the right hand side.</span>
</span><span id="L-192"><a href="#L-192"><span class="linenos">192</span></a>
</span><span id="L-193"><a href="#L-193"><span class="linenos">193</span></a><span class="sd">[It would be nice if we could write down our grammar and put it here]</span>
</span><span id="L-194"><a href="#L-194"><span class="linenos">194</span></a>
</span><span id="L-195"><a href="#L-195"><span class="linenos">195</span></a><span class="sd">Statements and expressions in Rat are always written in terms of scalars. There</span>
</span><span id="L-196"><a href="#L-196"><span class="linenos">196</span></a><span class="sd">is no concept of vectors exposed in the language (yet).</span>
</span><span id="L-197"><a href="#L-197"><span class="linenos">197</span></a>
</span><span id="L-198"><a href="#L-198"><span class="linenos">198</span></a><span class="sd">Vectorization in Rat comes from an understanding of primary variables. In every</span>
</span><span id="L-199"><a href="#L-199"><span class="linenos">199</span></a><span class="sd">statement there will be exactly one primary variable. The rules for identifying</span>
</span><span id="L-200"><a href="#L-200"><span class="linenos">200</span></a><span class="sd">a primary variable are:</span>
</span><span id="L-201"><a href="#L-201"><span class="linenos">201</span></a>
</span><span id="L-202"><a href="#L-202"><span class="linenos">202</span></a><span class="sd">The rules for primary variable deduction are as follows (executed in order):</span>
</span><span id="L-203"><a href="#L-203"><span class="linenos">203</span></a>
</span><span id="L-204"><a href="#L-204"><span class="linenos">204</span></a><span class="sd">1. Search for all variables in a statement</span>
</span><span id="L-205"><a href="#L-205"><span class="linenos">205</span></a><span class="sd">2. If there is only one variable, that is the primary variable</span>
</span><span id="L-206"><a href="#L-206"><span class="linenos">206</span></a><span class="sd">3. If there are multiple variables, then one must be marked with &#39; to indicate</span>
</span><span id="L-207"><a href="#L-207"><span class="linenos">207</span></a><span class="sd"> it is the primary variable.</span>
</span><span id="L-208"><a href="#L-208"><span class="linenos">208</span></a>
</span><span id="L-209"><a href="#L-209"><span class="linenos">209</span></a><span class="sd">Vectorization proceeds in two directions, depending on if the primary variable</span>
</span><span id="L-210"><a href="#L-210"><span class="linenos">210</span></a><span class="sd">is associated with an input dataframe or not.</span>
</span><span id="L-211"><a href="#L-211"><span class="linenos">211</span></a>
</span><span id="L-212"><a href="#L-212"><span class="linenos">212</span></a><span class="sd">If the identifier of the primary variable can be found in one of the input dataframes,</span>
</span><span id="L-213"><a href="#L-213"><span class="linenos">213</span></a><span class="sd">then vectorization for a statement is done by executing that statement across</span>
</span><span id="L-214"><a href="#L-214"><span class="linenos">214</span></a><span class="sd">all rows of the input dataframe with column-values of the input dataframe</span>
</span><span id="L-215"><a href="#L-215"><span class="linenos">215</span></a><span class="sd">exposed as local variables that can be referenced by name in the calculation.</span>
</span><span id="L-216"><a href="#L-216"><span class="linenos">216</span></a>
</span><span id="L-217"><a href="#L-217"><span class="linenos">217</span></a><span class="sd">If the identifier of the primary variable is not found in an input dataframe, then it</span>
</span><span id="L-218"><a href="#L-218"><span class="linenos">218</span></a><span class="sd">is understood to be a function. Vectorization is handled by executing the statement</span>
</span><span id="L-219"><a href="#L-219"><span class="linenos">219</span></a><span class="sd">across the domain of the function and exposing the named arguments as local variables.</span>
</span><span id="L-220"><a href="#L-220"><span class="linenos">220</span></a>
</span><span id="L-221"><a href="#L-221"><span class="linenos">221</span></a><span class="sd">Function domains for variables not in dataframes are computed from their use. As part</span>
</span><span id="L-222"><a href="#L-222"><span class="linenos">222</span></a><span class="sd">of compiling a Rat program, Rat must compute the smallest function domain for</span>
</span><span id="L-223"><a href="#L-223"><span class="linenos">223</span></a><span class="sd">every variable that allows the program to execute. This is done by repeatedly</span>
</span><span id="L-224"><a href="#L-224"><span class="linenos">224</span></a><span class="sd">running a Rat program, recording what functions are called for what arguments,</span>
</span><span id="L-225"><a href="#L-225"><span class="linenos">225</span></a><span class="sd">and repeating this process until the domains of all functions have stabilized.</span>
</span><span id="L-226"><a href="#L-226"><span class="linenos">226</span></a>
</span><span id="L-227"><a href="#L-227"><span class="linenos">227</span></a><span class="sd">It is entirely possible to write infinite recursions that make it impossible for</span>
</span><span id="L-228"><a href="#L-228"><span class="linenos">228</span></a><span class="sd">this calculation to succeed (in which case the compiler should throw an error).</span>
</span><span id="L-229"><a href="#L-229"><span class="linenos">229</span></a>
</span><span id="L-230"><a href="#L-230"><span class="linenos">230</span></a><span class="sd">To make this process possible, control flow in Rat cannot depend on non-data variables.</span>
</span><span id="L-231"><a href="#L-231"><span class="linenos">231</span></a>
</span><span id="L-232"><a href="#L-232"><span class="linenos">232</span></a><span class="sd">Values for non-primary variables in statements can come from three places (searched in this order):</span>
</span><span id="L-233"><a href="#L-233"><span class="linenos">233</span></a><span class="sd">1. They can be exposed as local variables as part of the primary variable vectorization process</span>
</span><span id="L-234"><a href="#L-234"><span class="linenos">234</span></a><span class="sd">2. They can come from other input dataframes -- if the identifier matches a column in</span>
</span><span id="L-235"><a href="#L-235"><span class="linenos">235</span></a><span class="sd">  another input dataframe then the subscript arguments are used to look up a unique value</span>
</span><span id="L-236"><a href="#L-236"><span class="linenos">236</span></a><span class="sd">  (if there is no row or more than one row corresponding to the subscripts and error will</span>
</span><span id="L-237"><a href="#L-237"><span class="linenos">237</span></a><span class="sd">  be thrown)</span>
</span><span id="L-238"><a href="#L-238"><span class="linenos">238</span></a><span class="sd">3. They can come from nowhere (yet)! Variables that cannot be pulled from dataframes</span>
</span><span id="L-239"><a href="#L-239"><span class="linenos">239</span></a><span class="sd">  don&#39;t need values yet -- the Rat program can compile without them. These values are</span>
</span><span id="L-240"><a href="#L-240"><span class="linenos">240</span></a><span class="sd">  exposed by the compiler to the sampler which is then responsible for providing them.</span>
</span><span id="L-241"><a href="#L-241"><span class="linenos">241</span></a><span class="sd">  It is on these values that control flow in a Rat program cannot depend (because they</span>
</span><span id="L-242"><a href="#L-242"><span class="linenos">242</span></a><span class="sd">  will not be available until after compilation, and Rat needs to know the control</span>
</span><span id="L-243"><a href="#L-243"><span class="linenos">243</span></a><span class="sd">  flow at compilation to infer function domains).</span>
</span><span id="L-244"><a href="#L-244"><span class="linenos">244</span></a>
</span><span id="L-245"><a href="#L-245"><span class="linenos">245</span></a><span class="sd">==================</span>
</span><span id="L-246"><a href="#L-246"><span class="linenos">246</span></a>
</span><span id="L-247"><a href="#L-247"><span class="linenos">247</span></a><span class="sd">Rat syntax is built for writing vectorized calculations across dataframes. The idea</span>
</span><span id="L-248"><a href="#L-248"><span class="linenos">248</span></a><span class="sd">is that this is a useful framework for conceptualizing multilevel regressions, and</span>
</span><span id="L-249"><a href="#L-249"><span class="linenos">249</span></a><span class="sd">Rat tries to make it easy to do this in code.</span>
</span><span id="L-250"><a href="#L-250"><span class="linenos">250</span></a>
</span><span id="L-251"><a href="#L-251"><span class="linenos">251</span></a><span class="sd">Rat is made of *statements*. A statement in Rat consists of two *expressions* (the left hand side</span>
</span><span id="L-252"><a href="#L-252"><span class="linenos">252</span></a><span class="sd">and right hand side expressions) separated by either an `~` or an `=` and ending in `;`.</span>
</span><span id="L-253"><a href="#L-253"><span class="linenos">253</span></a><span class="sd">Those where the lefthand side and righthand side are separated by `~` are called sampling statements,</span>
</span><span id="L-254"><a href="#L-254"><span class="linenos">254</span></a><span class="sd">and those where the lefthand side and righthand side are separated by `=` are called assignments.</span>
</span><span id="L-255"><a href="#L-255"><span class="linenos">255</span></a><span class="sd">Expressions are composed of *functions* and *variable references* and do not contain any intervening `~`, `=`, or</span>
</span><span id="L-256"><a href="#L-256"><span class="linenos">256</span></a><span class="sd">`;` characters.</span>
</span><span id="L-257"><a href="#L-257"><span class="linenos">257</span></a>
</span><span id="L-258"><a href="#L-258"><span class="linenos">258</span></a><span class="sd">A statement can be multiple lines, and any line can end with a *comment* separated with `#`.</span>
</span><span id="L-259"><a href="#L-259"><span class="linenos">259</span></a><span class="sd">There are no multiline comments.</span>
</span><span id="L-260"><a href="#L-260"><span class="linenos">260</span></a>
</span><span id="L-261"><a href="#L-261"><span class="linenos">261</span></a><span class="sd">For example, this is a valid sampling statement in Rat:</span>
</span><span id="L-262"><a href="#L-262"><span class="linenos">262</span></a><span class="sd">```</span>
</span><span id="L-263"><a href="#L-263"><span class="linenos">263</span></a><span class="sd">score_diff&#39; ~ normal( # It&#39;s a sampling statement!</span>
</span><span id="L-264"><a href="#L-264"><span class="linenos">264</span></a><span class="sd">    skill[home_team], # It&#39;s a regression with one group-level intercept!</span>
</span><span id="L-265"><a href="#L-265"><span class="linenos">265</span></a><span class="sd">    sigma);</span>
</span><span id="L-266"><a href="#L-266"><span class="linenos">266</span></a><span class="sd">```</span>
</span><span id="L-267"><a href="#L-267"><span class="linenos">267</span></a>
</span><span id="L-268"><a href="#L-268"><span class="linenos">268</span></a><span class="sd">Rat syntax vectorizes over dataframes. This means that each statement will produce code</span>
</span><span id="L-269"><a href="#L-269"><span class="linenos">269</span></a><span class="sd">that runs for each row in a dataframe. The dataframe that a statement vectorizes across is</span>
</span><span id="L-270"><a href="#L-270"><span class="linenos">270</span></a><span class="sd">called the *primary dataframe* -- there is exactly one primary dataframe per statement.</span>
</span><span id="L-271"><a href="#L-271"><span class="linenos">271</span></a>
</span><span id="L-272"><a href="#L-272"><span class="linenos">272</span></a><span class="sd">Rat statements resolve their primary dataframes in a process called *primary variable deduction*.</span>
</span><span id="L-273"><a href="#L-273"><span class="linenos">273</span></a><span class="sd">Every variable (a variable being a named symbol that is not a function) has exactly one dataframe</span>
</span><span id="L-274"><a href="#L-274"><span class="linenos">274</span></a><span class="sd">attached to it. To identify the primary dataframe, rat must identify the primary variable.</span>
</span><span id="L-275"><a href="#L-275"><span class="linenos">275</span></a>
</span><span id="L-276"><a href="#L-276"><span class="linenos">276</span></a><span class="sd">The rules for primary variable deduction are as follows (executed in order):</span>
</span><span id="L-277"><a href="#L-277"><span class="linenos">277</span></a>
</span><span id="L-278"><a href="#L-278"><span class="linenos">278</span></a><span class="sd">1. There can only be one primary variable in a statement.</span>
</span><span id="L-279"><a href="#L-279"><span class="linenos">279</span></a><span class="sd">2. If a variable reference is *primed*, then that variable is the primary variable.</span>
</span><span id="L-280"><a href="#L-280"><span class="linenos">280</span></a><span class="sd">3. If there is no primed variable references, then all variables with non-empty dataframes are treated as prime.</span>
</span><span id="L-281"><a href="#L-281"><span class="linenos">281</span></a><span class="sd">4. If there are no variables with non-empty dataframes, the leftmost one is the primary one.</span>
</span><span id="L-282"><a href="#L-282"><span class="linenos">282</span></a><span class="sd">5. It is an error if anything other than one primary variable is identified.</span>
</span><span id="L-283"><a href="#L-283"><span class="linenos">283</span></a><span class="sd">6. A *parameter* can only be used as the primary variable in one statement.</span>
</span><span id="L-284"><a href="#L-284"><span class="linenos">284</span></a>
</span><span id="L-285"><a href="#L-285"><span class="linenos">285</span></a><span class="sd">A variable reference can be primed if it ends with a `&#39;`. A variable reference itself</span>
</span><span id="L-286"><a href="#L-286"><span class="linenos">286</span></a><span class="sd">is a variable name, an optional constraint, an optional sequence of *subscripts*, and an</span>
</span><span id="L-287"><a href="#L-287"><span class="linenos">287</span></a><span class="sd">followed by the optional prime symbol. In the example above, `score_diff`, `skill`, and</span>
</span><span id="L-288"><a href="#L-288"><span class="linenos">288</span></a><span class="sd">`sigma` are variable names. `home_team` is a subscript. `score_diff&#39;`, `skill[home_team]`,</span>
</span><span id="L-289"><a href="#L-289"><span class="linenos">289</span></a><span class="sd">and `sigma` are the variable references, and `score_diff` is the primary variable.</span>
</span><span id="L-290"><a href="#L-290"><span class="linenos">290</span></a>
</span><span id="L-291"><a href="#L-291"><span class="linenos">291</span></a><span class="sd">Variables are associated with dataframes with the process of *variable dataframe deduction* (executed in order):</span>
</span><span id="L-292"><a href="#L-292"><span class="linenos">292</span></a>
</span><span id="L-293"><a href="#L-293"><span class="linenos">293</span></a><span class="sd">1. Variables with names that match columns in an *input dataframe* take that input dataframe</span>
</span><span id="L-294"><a href="#L-294"><span class="linenos">294</span></a><span class="sd">2. If variable names match columns in multiple input dataframes, it is an error</span>
</span><span id="L-295"><a href="#L-295"><span class="linenos">295</span></a><span class="sd">3. Otherwise, variables references are associated with parameters. The dataframe of the parameter is the minimum</span>
</span><span id="L-296"><a href="#L-296"><span class="linenos">296</span></a><span class="sd">dataframe required to execute all statements it is used in.</span>
</span><span id="L-297"><a href="#L-297"><span class="linenos">297</span></a>
</span><span id="L-298"><a href="#L-298"><span class="linenos">298</span></a><span class="sd">For the purposes of both dataframe deductions, Rat programs are understood top to bottom.</span>
</span><span id="L-299"><a href="#L-299"><span class="linenos">299</span></a>
</span><span id="L-300"><a href="#L-300"><span class="linenos">300</span></a><span class="sd">For the regression above, a suitable example of an input dataframe might be</span>
</span><span id="L-301"><a href="#L-301"><span class="linenos">301</span></a><span class="sd">(the point differentials for a number of NBA games from the 2016 season):</span>
</span><span id="L-302"><a href="#L-302"><span class="linenos">302</span></a>
</span><span id="L-303"><a href="#L-303"><span class="linenos">303</span></a><span class="sd">```</span>
</span><span id="L-304"><a href="#L-304"><span class="linenos">304</span></a><span class="sd">    game_id  home_score  away_score home_team away_team  score_diff  year</span>
</span><span id="L-305"><a href="#L-305"><span class="linenos">305</span></a><span class="sd">0         1         117          88       CLE       NYK        29.0  2016</span>
</span><span id="L-306"><a href="#L-306"><span class="linenos">306</span></a><span class="sd">1         2         113         104       POR       UTA         9.0  2016</span>
</span><span id="L-307"><a href="#L-307"><span class="linenos">307</span></a><span class="sd">2         3         100         129       GSW       SAS       -29.0  2016</span>
</span><span id="L-308"><a href="#L-308"><span class="linenos">308</span></a><span class="sd">3         4          96         108       ORL       MIA       -12.0  2016</span>
</span><span id="L-309"><a href="#L-309"><span class="linenos">309</span></a><span class="sd">4         5         130         121       IND       DAL         9.0  2016</span>
</span><span id="L-310"><a href="#L-310"><span class="linenos">310</span></a><span class="sd">5         6         122         117       BOS       BKN         5.0  2016</span>
</span><span id="L-311"><a href="#L-311"><span class="linenos">311</span></a><span class="sd">6         7         109          91       TOR       DET        18.0  2016</span>
</span><span id="L-312"><a href="#L-312"><span class="linenos">312</span></a><span class="sd">7         8          96         107       MIL       CHA       -11.0  2016</span>
</span><span id="L-313"><a href="#L-313"><span class="linenos">313</span></a><span class="sd">8         9         102          98       MEM       MIN         4.0  2016</span>
</span><span id="L-314"><a href="#L-314"><span class="linenos">314</span></a><span class="sd">9        10         102         107       NOP       DEN        -5.0  2016</span>
</span><span id="L-315"><a href="#L-315"><span class="linenos">315</span></a><span class="sd">10       11          97         103       PHI       CLE        -6.0  2016</span>
</span><span id="L-316"><a href="#L-316"><span class="linenos">316</span></a><span class="sd">```</span>
</span><span id="L-317"><a href="#L-317"><span class="linenos">317</span></a>
</span><span id="L-318"><a href="#L-318"><span class="linenos">318</span></a><span class="sd">Because `score_diff` matches a column in this dataframe, assuming there are no</span>
</span><span id="L-319"><a href="#L-319"><span class="linenos">319</span></a><span class="sd">other dataframes, this dataframe becomes the primary dataframe for this statement.</span>
</span><span id="L-320"><a href="#L-320"><span class="linenos">320</span></a><span class="sd">Because `skill` and `sigma` do not appear as columns in this dataframe, they</span>
</span><span id="L-321"><a href="#L-321"><span class="linenos">321</span></a><span class="sd">will be parameters.</span>
</span><span id="L-322"><a href="#L-322"><span class="linenos">322</span></a>
</span><span id="L-323"><a href="#L-323"><span class="linenos">323</span></a><span class="sd">The statement will *execute* once for each line of this dataframe. As the statement runs,</span>
</span><span id="L-324"><a href="#L-324"><span class="linenos">324</span></a><span class="sd">it will substitute values from this dataframe into variables and subscripts that match</span>
</span><span id="L-325"><a href="#L-325"><span class="linenos">325</span></a><span class="sd">column names.</span>
</span><span id="L-326"><a href="#L-326"><span class="linenos">326</span></a>
</span><span id="L-327"><a href="#L-327"><span class="linenos">327</span></a><span class="sd">In this case, that means there must be a value in `skill` corresponding to each</span>
</span><span id="L-328"><a href="#L-328"><span class="linenos">328</span></a><span class="sd">of the home teams (`CLE, POR, GSW, ORL, IND, BOS, TOR, MIL, MEM, PHI`). Because there</span>
</span><span id="L-329"><a href="#L-329"><span class="linenos">329</span></a><span class="sd">is one subscript, the `skill` dataframe will have one column. The values in that column</span>
</span><span id="L-330"><a href="#L-330"><span class="linenos">330</span></a><span class="sd">will be extended as necessary to allow all the `home_team` references.</span>
</span><span id="L-331"><a href="#L-331"><span class="linenos">331</span></a>
</span><span id="L-332"><a href="#L-332"><span class="linenos">332</span></a><span class="sd">Because `sigma` has no subscripts, the minimum dataframe necessary to support it is</span>
</span><span id="L-333"><a href="#L-333"><span class="linenos">333</span></a><span class="sd">the empty dataframe.</span>
</span><span id="L-334"><a href="#L-334"><span class="linenos">334</span></a>
</span><span id="L-335"><a href="#L-335"><span class="linenos">335</span></a><span class="sd">Execution for a sampling statement means evaluating and accumulating the log density</span>
</span><span id="L-336"><a href="#L-336"><span class="linenos">336</span></a><span class="sd">given by the name of the distribution on the right hand side of the `~`.</span>
</span><span id="L-337"><a href="#L-337"><span class="linenos">337</span></a>
</span><span id="L-338"><a href="#L-338"><span class="linenos">338</span></a><span class="sd">Execution of assignments is described in [Transformed Parameters](#transformed-parameters) and</span>
</span><span id="L-339"><a href="#L-339"><span class="linenos">339</span></a><span class="sd">[Shift operator](#shift-operator).</span>
</span><span id="L-340"><a href="#L-340"><span class="linenos">340</span></a>
</span><span id="L-341"><a href="#L-341"><span class="linenos">341</span></a><span class="sd">Considering the data, it may seem useful to predict the score differential of an NBA game</span>
</span><span id="L-342"><a href="#L-342"><span class="linenos">342</span></a><span class="sd">in terms of both teams&#39; skills. A suitable model for this would be:</span>
</span><span id="L-343"><a href="#L-343"><span class="linenos">343</span></a><span class="sd">```</span>
</span><span id="L-344"><a href="#L-344"><span class="linenos">344</span></a><span class="sd">score_diff&#39; ~ normal(skill[home_team] - skill[away_team], sigma);</span>
</span><span id="L-345"><a href="#L-345"><span class="linenos">345</span></a><span class="sd">```</span>
</span><span id="L-346"><a href="#L-346"><span class="linenos">346</span></a>
</span><span id="L-347"><a href="#L-347"><span class="linenos">347</span></a><span class="sd">In this statement, there is an extra variable reference, `skill[away_team]`. Because of</span>
</span><span id="L-348"><a href="#L-348"><span class="linenos">348</span></a><span class="sd">this, the `skill` dataframe will need to be extended to support all the away teams as well</span>
</span><span id="L-349"><a href="#L-349"><span class="linenos">349</span></a><span class="sd">(adding all the teams but `CLE`, which is already there).</span>
</span><span id="L-350"><a href="#L-350"><span class="linenos">350</span></a>
</span><span id="L-351"><a href="#L-351"><span class="linenos">351</span></a><span class="sd">## Transformed parameters</span>
</span><span id="L-352"><a href="#L-352"><span class="linenos">352</span></a>
</span><span id="L-353"><a href="#L-353"><span class="linenos">353</span></a><span class="sd">Modeling the `skill` parameter in the model above hierarchically with a non-centered</span>
</span><span id="L-354"><a href="#L-354"><span class="linenos">354</span></a><span class="sd">parameterization will be a good demonstration of assignment statements in Rat. As a reminder,</span>
</span><span id="L-355"><a href="#L-355"><span class="linenos">355</span></a><span class="sd">this sort of parameterization is useful for avoiding [divergences](https://mc-stan.org/users/documentation/case-studies/divergences_and_bias.html),</span>
</span><span id="L-356"><a href="#L-356"><span class="linenos">356</span></a><span class="sd">when doing MCMC using NUTS on multilevel models.</span>
</span><span id="L-357"><a href="#L-357"><span class="linenos">357</span></a>
</span><span id="L-358"><a href="#L-358"><span class="linenos">358</span></a><span class="sd">The non-centered parameterization takes the form:</span>
</span><span id="L-359"><a href="#L-359"><span class="linenos">359</span></a><span class="sd">```</span>
</span><span id="L-360"><a href="#L-360"><span class="linenos">360</span></a><span class="sd">score_diff&#39; ~ normal(skill[home_team] - skill[away_team], sigma);</span>
</span><span id="L-361"><a href="#L-361"><span class="linenos">361</span></a><span class="sd">skill[team]&#39; = skill_z[team] * tau;</span>
</span><span id="L-362"><a href="#L-362"><span class="linenos">362</span></a><span class="sd">skill_z ~ normal(0.0, 1.0);</span>
</span><span id="L-363"><a href="#L-363"><span class="linenos">363</span></a><span class="sd">```</span>
</span><span id="L-364"><a href="#L-364"><span class="linenos">364</span></a>
</span><span id="L-365"><a href="#L-365"><span class="linenos">365</span></a><span class="sd">For the second statement `skill` is the primary variable, so the dataframe defined implicitly</span>
</span><span id="L-366"><a href="#L-366"><span class="linenos">366</span></a><span class="sd">in the first statement will be the primary dataframe for the second line. Because of the subscript,</span>
</span><span id="L-367"><a href="#L-367"><span class="linenos">367</span></a><span class="sd">the parameter `skill_z` will be created with a non-empty dataframe. Because it has no subscript,</span>
</span><span id="L-368"><a href="#L-368"><span class="linenos">368</span></a><span class="sd">the parameter `tau` is created using the empty dataframe.</span>
</span><span id="L-369"><a href="#L-369"><span class="linenos">369</span></a>
</span><span id="L-370"><a href="#L-370"><span class="linenos">370</span></a><span class="sd">The subscript of `skill` is *renamed* to `team` by use as a primary variable. Because the subscript</span>
</span><span id="L-371"><a href="#L-371"><span class="linenos">371</span></a><span class="sd">is referenced by two names in the first statement, its name is ambiguous. Subscripts in a</span>
</span><span id="L-372"><a href="#L-372"><span class="linenos">372</span></a><span class="sd">primary variable reference are *renaming subscripts*. Because a parameter can only be used</span>
</span><span id="L-373"><a href="#L-373"><span class="linenos">373</span></a><span class="sd">as a primary variable once, this renaming only happens once. The renaming is necessary</span>
</span><span id="L-374"><a href="#L-374"><span class="linenos">374</span></a><span class="sd">for two reasons:</span>
</span><span id="L-375"><a href="#L-375"><span class="linenos">375</span></a><span class="sd">    </span>
</span><span id="L-376"><a href="#L-376"><span class="linenos">376</span></a><span class="sd">1. Rat needs the subscript to be named for output to work</span>
</span><span id="L-377"><a href="#L-377"><span class="linenos">377</span></a><span class="sd">2. Creating an underlying parameter `skill_z` for each `skill` requires that `skill_z` be</span>
</span><span id="L-378"><a href="#L-378"><span class="linenos">378</span></a><span class="sd">subscripted by the `skill` dataframe.</span>
</span><span id="L-379"><a href="#L-379"><span class="linenos">379</span></a>
</span><span id="L-380"><a href="#L-380"><span class="linenos">380</span></a><span class="sd">The assignment itself works by evaluating the expression on the right hand side and writing</span>
</span><span id="L-381"><a href="#L-381"><span class="linenos">381</span></a><span class="sd">the transformed parameter on the left (and the variable on the left hand side must</span>
</span><span id="L-382"><a href="#L-382"><span class="linenos">382</span></a><span class="sd">be a parameter, not data). Transformed parameters are immutable, so once they are set</span>
</span><span id="L-383"><a href="#L-383"><span class="linenos">383</span></a><span class="sd">they cannot be changed. All uses of a transformed parameter must preceed the assignment. This</span>
</span><span id="L-384"><a href="#L-384"><span class="linenos">384</span></a><span class="sd">may seem non-intuitive coming from other languages, but in Rat parameter use defines the</span>
</span><span id="L-385"><a href="#L-385"><span class="linenos">385</span></a><span class="sd">parameters themselves -- the assignment will simply guarantee that the necessary values</span>
</span><span id="L-386"><a href="#L-386"><span class="linenos">386</span></a><span class="sd">get set. Rat statements will effectively be executed in reverse order as they are written.</span>
</span><span id="L-387"><a href="#L-387"><span class="linenos">387</span></a>
</span><span id="L-388"><a href="#L-388"><span class="linenos">388</span></a><span class="sd">In the final statement the prior for `skill_z` is defined. Because `skill_z` is the only variable</span>
</span><span id="L-389"><a href="#L-389"><span class="linenos">389</span></a><span class="sd">in the statement, its dataframe will be the primary dataframe (and there is no need to prime it</span>
</span><span id="L-390"><a href="#L-390"><span class="linenos">390</span></a><span class="sd">manually). Because the use uniquely defines a name for the subscript, there is no need to rename it.</span>
</span><span id="L-391"><a href="#L-391"><span class="linenos">391</span></a>
</span><span id="L-392"><a href="#L-392"><span class="linenos">392</span></a><span class="sd">## Constraints</span>
</span><span id="L-393"><a href="#L-393"><span class="linenos">393</span></a>
</span><span id="L-394"><a href="#L-394"><span class="linenos">394</span></a><span class="sd">The model above won&#39;t get far without a prior on `tau`. Because `tau` is a</span>
</span><span id="L-395"><a href="#L-395"><span class="linenos">395</span></a><span class="sd">standard deviation, it must be constrained to be positive.</span>
</span><span id="L-396"><a href="#L-396"><span class="linenos">396</span></a>
</span><span id="L-397"><a href="#L-397"><span class="linenos">397</span></a><span class="sd">Rat adopts a similar constraint syntax to Stan:</span>
</span><span id="L-398"><a href="#L-398"><span class="linenos">398</span></a>
</span><span id="L-399"><a href="#L-399"><span class="linenos">399</span></a><span class="sd">```</span>
</span><span id="L-400"><a href="#L-400"><span class="linenos">400</span></a><span class="sd">score_diff&#39; ~ normal(skill[home_team] - skill[away_team], sigma);</span>
</span><span id="L-401"><a href="#L-401"><span class="linenos">401</span></a><span class="sd">skill[team]&#39; = skill_z[team] * tau;</span>
</span><span id="L-402"><a href="#L-402"><span class="linenos">402</span></a><span class="sd">skill_z ~ normal(0.0, 1.0);</span>
</span><span id="L-403"><a href="#L-403"><span class="linenos">403</span></a><span class="sd">tau&lt;lower = 0.0&gt; ~ normal(0.0, 1.0);</span>
</span><span id="L-404"><a href="#L-404"><span class="linenos">404</span></a><span class="sd">```</span>
</span><span id="L-405"><a href="#L-405"><span class="linenos">405</span></a>
</span><span id="L-406"><a href="#L-406"><span class="linenos">406</span></a><span class="sd">Constraints can only be used on parameters.</span>
</span><span id="L-407"><a href="#L-407"><span class="linenos">407</span></a>
</span><span id="L-408"><a href="#L-408"><span class="linenos">408</span></a><span class="sd">The constraint goes after the parameter name but before the subscripts. Rat</span>
</span><span id="L-409"><a href="#L-409"><span class="linenos">409</span></a><span class="sd">supports a `lower`, `upper` and a combination of the two constraints.</span>
</span><span id="L-410"><a href="#L-410"><span class="linenos">410</span></a>
</span><span id="L-411"><a href="#L-411"><span class="linenos">411</span></a><span class="sd">## Shift operator</span>
</span><span id="L-412"><a href="#L-412"><span class="linenos">412</span></a>
</span><span id="L-413"><a href="#L-413"><span class="linenos">413</span></a><span class="sd">The elements of Rat parameters are sorted with respect to the values of the</span>
</span><span id="L-414"><a href="#L-414"><span class="linenos">414</span></a><span class="sd">subscripts. The sorting is done by sorting the columns of the parameter</span>
</span><span id="L-415"><a href="#L-415"><span class="linenos">415</span></a><span class="sd">dataframe. This sorting is done in the order of the subscripts, so the</span>
</span><span id="L-416"><a href="#L-416"><span class="linenos">416</span></a><span class="sd">rightmost subscript is sorted last. The dataframes and parameter values having</span>
</span><span id="L-417"><a href="#L-417"><span class="linenos">417</span></a><span class="sd">a sorted order is covenient for time series data.</span>
</span><span id="L-418"><a href="#L-418"><span class="linenos">418</span></a>
</span><span id="L-419"><a href="#L-419"><span class="linenos">419</span></a><span class="sd">Going back to the basketball model, perhaps someone is interested in how a team&#39;s</span>
</span><span id="L-420"><a href="#L-420"><span class="linenos">420</span></a><span class="sd">skill changes year to year:</span>
</span><span id="L-421"><a href="#L-421"><span class="linenos">421</span></a>
</span><span id="L-422"><a href="#L-422"><span class="linenos">422</span></a><span class="sd">```</span>
</span><span id="L-423"><a href="#L-423"><span class="linenos">423</span></a><span class="sd">score_diff&#39; ~ normal(skill[home_team, year] - skill[away_team, year], sigma);</span>
</span><span id="L-424"><a href="#L-424"><span class="linenos">424</span></a><span class="sd">skill[team, year]&#39; = skill[team, shift(year, 1)] + skill_z[team] * tau;</span>
</span><span id="L-425"><a href="#L-425"><span class="linenos">425</span></a><span class="sd">skill_z ~ normal(0.0, 1.0);</span>
</span><span id="L-426"><a href="#L-426"><span class="linenos">426</span></a><span class="sd">tau&lt;lower = 0.0&gt; ~ normal(0.0, 1.0);</span>
</span><span id="L-427"><a href="#L-427"><span class="linenos">427</span></a><span class="sd">```</span>
</span><span id="L-428"><a href="#L-428"><span class="linenos">428</span></a>
</span><span id="L-429"><a href="#L-429"><span class="linenos">429</span></a><span class="sd">The first line still determines what the dataframe for `skill` will look like,</span>
</span><span id="L-430"><a href="#L-430"><span class="linenos">430</span></a><span class="sd">though now there will be two columns instead of one, with rows corresponding to</span>
</span><span id="L-431"><a href="#L-431"><span class="linenos">431</span></a><span class="sd">the necessary team-year combinations.</span>
</span><span id="L-432"><a href="#L-432"><span class="linenos">432</span></a>
</span><span id="L-433"><a href="#L-433"><span class="linenos">433</span></a><span class="sd">The second line is still an assignment, but it is different because the variable</span>
</span><span id="L-434"><a href="#L-434"><span class="linenos">434</span></a><span class="sd">assigned on the left hand side is used on the right hand side. The notation,</span>
</span><span id="L-435"><a href="#L-435"><span class="linenos">435</span></a><span class="sd">`skill[team, shift(year, 1)]` means, &quot;take the skill corresponding to this</span>
</span><span id="L-436"><a href="#L-436"><span class="linenos">436</span></a><span class="sd">team in the previous year&quot; (the shift behaves like the pandas</span>
</span><span id="L-437"><a href="#L-437"><span class="linenos">437</span></a><span class="sd">[shift](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.shift.html),</span>
</span><span id="L-438"><a href="#L-438"><span class="linenos">438</span></a><span class="sd">where a positive number means shift rows down the dataframe).</span>
</span><span id="L-439"><a href="#L-439"><span class="linenos">439</span></a>
</span><span id="L-440"><a href="#L-440"><span class="linenos">440</span></a><span class="sd">This works because:</span>
</span><span id="L-441"><a href="#L-441"><span class="linenos">441</span></a><span class="sd">1. Rat statements are executed across rows of the primary dataframe</span>
</span><span id="L-442"><a href="#L-442"><span class="linenos">442</span></a><span class="sd">2. The primary dataframe is sorted in ascending order according to its subscripts</span>
</span><span id="L-443"><a href="#L-443"><span class="linenos">443</span></a><span class="sd">3. The primary dataframe is already defined -- there is not problem of terminating</span>
</span><span id="L-444"><a href="#L-444"><span class="linenos">444</span></a><span class="sd">this recursive statement</span>
</span><span id="L-445"><a href="#L-445"><span class="linenos">445</span></a><span class="sd">4. Out-of-bounds accesses do not throw errors but instead return zero (the value</span>
</span><span id="L-446"><a href="#L-446"><span class="linenos">446</span></a><span class="sd">zero itself, not the zeroth element of the array)</span>
</span><span id="L-447"><a href="#L-447"><span class="linenos">447</span></a>
</span><span id="L-448"><a href="#L-448"><span class="linenos">448</span></a><span class="sd">Because of rules 1 and 2, when assigning a variable, it is possible to reference</span>
</span><span id="L-449"><a href="#L-449"><span class="linenos">449</span></a><span class="sd">the parts that have already been computed. Because of rules 3 and 4, there is no</span>
</span><span id="L-450"><a href="#L-450"><span class="linenos">450</span></a><span class="sd">problem with infinite recursions or edge cases.</span>
</span><span id="L-451"><a href="#L-451"><span class="linenos">451</span></a>
</span><span id="L-452"><a href="#L-452"><span class="linenos">452</span></a><span class="sd">For performance reasons when using recursive assignments:</span>
</span><span id="L-453"><a href="#L-453"><span class="linenos">453</span></a><span class="sd">1. There can be at most one shifted subscript</span>
</span><span id="L-454"><a href="#L-454"><span class="linenos">454</span></a><span class="sd">2. The shifted subscript must appear lasts</span>
</span><span id="L-455"><a href="#L-455"><span class="linenos">455</span></a>
</span><span id="L-456"><a href="#L-456"><span class="linenos">456</span></a><span class="sd">Currently for programmatic reasons, negative shifts are not allowed in recursive</span>
</span><span id="L-457"><a href="#L-457"><span class="linenos">457</span></a><span class="sd">assignments, though the goal is to allow this in the future.</span>
</span><span id="L-458"><a href="#L-458"><span class="linenos">458</span></a>
</span><span id="L-459"><a href="#L-459"><span class="linenos">459</span></a><span class="sd">### Simpler ways to shift</span>
</span><span id="L-460"><a href="#L-460"><span class="linenos">460</span></a>
</span><span id="L-461"><a href="#L-461"><span class="linenos">461</span></a><span class="sd">The shift operator used in a recursive assignment is the trickiest of the shifts.</span>
</span><span id="L-462"><a href="#L-462"><span class="linenos">462</span></a>
</span><span id="L-463"><a href="#L-463"><span class="linenos">463</span></a><span class="sd">The above model can also be written with a centered parameterization:</span>
</span><span id="L-464"><a href="#L-464"><span class="linenos">464</span></a><span class="sd">```</span>
</span><span id="L-465"><a href="#L-465"><span class="linenos">465</span></a><span class="sd">score_diff&#39; ~ normal(skill[home_team, year] - skill[away_team, year], sigma);</span>
</span><span id="L-466"><a href="#L-466"><span class="linenos">466</span></a><span class="sd">skill[team, year]&#39; ~ normal(skill[team, shift(year, 1)], tau);</span>
</span><span id="L-467"><a href="#L-467"><span class="linenos">467</span></a><span class="sd">tau&lt;lower = 0.0&gt; ~ normal(0.0, 1.0);</span>
</span><span id="L-468"><a href="#L-468"><span class="linenos">468</span></a><span class="sd">```</span>
</span><span id="L-469"><a href="#L-469"><span class="linenos">469</span></a>
</span><span id="L-470"><a href="#L-470"><span class="linenos">470</span></a><span class="sd">The difference here is that a sampling statement is not an assignment -- the parameters</span>
</span><span id="L-471"><a href="#L-471"><span class="linenos">471</span></a><span class="sd">here are parameters of the log density that the sampler explores. From a programmatic</span>
</span><span id="L-472"><a href="#L-472"><span class="linenos">472</span></a><span class="sd">perspective there is no recursion needed because the values for the parameters come</span>
</span><span id="L-473"><a href="#L-473"><span class="linenos">473</span></a><span class="sd">from somewhere else.</span>
</span><span id="L-474"><a href="#L-474"><span class="linenos">474</span></a>
</span><span id="L-475"><a href="#L-475"><span class="linenos">475</span></a><span class="sd">In this case, it is possible to shift on multiple subscripts and the shift can appear</span>
</span><span id="L-476"><a href="#L-476"><span class="linenos">476</span></a><span class="sd">on any subscript. These restrictions also aren&#39;t necessarys for non-recursive assignment.</span>
</span><span id="L-477"><a href="#L-477"><span class="linenos">477</span></a>
</span><span id="L-478"><a href="#L-478"><span class="linenos">478</span></a><span class="sd">### Shifts and groups</span>
</span><span id="L-479"><a href="#L-479"><span class="linenos">479</span></a>
</span><span id="L-480"><a href="#L-480"><span class="linenos">480</span></a><span class="sd">Shifts are done only within groups defined by the unshifted parameters. That is a mouthful,</span>
</span><span id="L-481"><a href="#L-481"><span class="linenos">481</span></a><span class="sd">but in terms of basketball example this looks like:</span>
</span><span id="L-482"><a href="#L-482"><span class="linenos">482</span></a>
</span><span id="L-483"><a href="#L-483"><span class="linenos">483</span></a><span class="sd">| `skill[team, year]` | `skill[team, shift(year, 1)]` |</span>
</span><span id="L-484"><a href="#L-484"><span class="linenos">484</span></a><span class="sd">| --------------------------------------------------- |</span>
</span><span id="L-485"><a href="#L-485"><span class="linenos">485</span></a><span class="sd">| `skill[CHA, 2016]`  | `0`                           |</span>
</span><span id="L-486"><a href="#L-486"><span class="linenos">486</span></a><span class="sd">| `skill[CHA, 2017]`  | `skill[CHA, 2016]`            |</span>
</span><span id="L-487"><a href="#L-487"><span class="linenos">487</span></a><span class="sd">| `skill[ATL, 2017]`  | `0`                           |</span>
</span><span id="L-488"><a href="#L-488"><span class="linenos">488</span></a>
</span><span id="L-489"><a href="#L-489"><span class="linenos">489</span></a><span class="sd">[WARNING: Currently negative shifts are not allowed in recursive assignments]</span>
</span><span id="L-490"><a href="#L-490"><span class="linenos">490</span></a>
</span><span id="L-491"><a href="#L-491"><span class="linenos">491</span></a><span class="sd">A negative shift produces a different result:</span>
</span><span id="L-492"><a href="#L-492"><span class="linenos">492</span></a>
</span><span id="L-493"><a href="#L-493"><span class="linenos">493</span></a><span class="sd">| `skill[team, year]` | `skill[team, shift(year, -1)]` |</span>
</span><span id="L-494"><a href="#L-494"><span class="linenos">494</span></a><span class="sd">| --------------------------------------------------- |</span>
</span><span id="L-495"><a href="#L-495"><span class="linenos">495</span></a><span class="sd">| `skill[CHA, 2016]`  | `skill[CHA, 2017]`            |</span>
</span><span id="L-496"><a href="#L-496"><span class="linenos">496</span></a><span class="sd">| `skill[CHA, 2017]`  | `0`                           |</span>
</span><span id="L-497"><a href="#L-497"><span class="linenos">497</span></a><span class="sd">| `skill[ATL, 2017]`  | `0`                           |</span>
</span><span id="L-498"><a href="#L-498"><span class="linenos">498</span></a>
</span><span id="L-499"><a href="#L-499"><span class="linenos">499</span></a><span class="sd">## Multiple input dataframes</span>
</span><span id="L-500"><a href="#L-500"><span class="linenos">500</span></a>
</span><span id="L-501"><a href="#L-501"><span class="linenos">501</span></a><span class="sd">A Rat program can take in multiple input dataframes. As a part of variable dataframe</span>
</span><span id="L-502"><a href="#L-502"><span class="linenos">502</span></a><span class="sd">deduction, every name will be associated with a dataframe (or an error will be thrown).</span>
</span><span id="L-503"><a href="#L-503"><span class="linenos">503</span></a>
</span><span id="L-504"><a href="#L-504"><span class="linenos">504</span></a><span class="sd">In the same way that parameters are handled, non-primary variable values are joined to</span>
</span><span id="L-505"><a href="#L-505"><span class="linenos">505</span></a><span class="sd">primary variables via subscripts. The major difference is that, because Rat allocates</span>
</span><span id="L-506"><a href="#L-506"><span class="linenos">506</span></a><span class="sd">parameter dataframes, it can be careful to avoid duplicate entries. Because dataframes</span>
</span><span id="L-507"><a href="#L-507"><span class="linenos">507</span></a><span class="sd">for data variables come from the outside, this must be verified by the user. It is an</span>
</span><span id="L-508"><a href="#L-508"><span class="linenos">508</span></a><span class="sd">error if rows in a dataframe are referenced in a way that makes them not unique.</span>
</span><span id="L-509"><a href="#L-509"><span class="linenos">509</span></a>
</span><span id="L-510"><a href="#L-510"><span class="linenos">510</span></a><span class="sd">As a simple example of using multiple dataframes, consider the eight schools data:</span>
</span><span id="L-511"><a href="#L-511"><span class="linenos">511</span></a><span class="sd">```</span>
</span><span id="L-512"><a href="#L-512"><span class="linenos">512</span></a><span class="sd">y,sigma,school</span>
</span><span id="L-513"><a href="#L-513"><span class="linenos">513</span></a><span class="sd">28,15,1</span>
</span><span id="L-514"><a href="#L-514"><span class="linenos">514</span></a><span class="sd">8,10,2</span>
</span><span id="L-515"><a href="#L-515"><span class="linenos">515</span></a><span class="sd">-3,16,3</span>
</span><span id="L-516"><a href="#L-516"><span class="linenos">516</span></a><span class="sd">7,11,4</span>
</span><span id="L-517"><a href="#L-517"><span class="linenos">517</span></a><span class="sd">-1,9,5</span>
</span><span id="L-518"><a href="#L-518"><span class="linenos">518</span></a><span class="sd">1,11,6</span>
</span><span id="L-519"><a href="#L-519"><span class="linenos">519</span></a><span class="sd">18,10,7</span>
</span><span id="L-520"><a href="#L-520"><span class="linenos">520</span></a><span class="sd">12,18,8</span>
</span><span id="L-521"><a href="#L-521"><span class="linenos">521</span></a><span class="sd">```</span>
</span><span id="L-522"><a href="#L-522"><span class="linenos">522</span></a>
</span><span id="L-523"><a href="#L-523"><span class="linenos">523</span></a><span class="sd">Along with the eight schools model:</span>
</span><span id="L-524"><a href="#L-524"><span class="linenos">524</span></a><span class="sd">```</span>
</span><span id="L-525"><a href="#L-525"><span class="linenos">525</span></a><span class="sd">y&#39; ~ normal(theta[school], sigma);</span>
</span><span id="L-526"><a href="#L-526"><span class="linenos">526</span></a><span class="sd">theta&#39; = mu + z[school] * tau;</span>
</span><span id="L-527"><a href="#L-527"><span class="linenos">527</span></a><span class="sd">z ~ normal(0, 1);</span>
</span><span id="L-528"><a href="#L-528"><span class="linenos">528</span></a><span class="sd">mu ~ normal(0, 5);</span>
</span><span id="L-529"><a href="#L-529"><span class="linenos">529</span></a><span class="sd">tau&lt;lower = 0.0&gt; ~ log_normal(0, 1);</span>
</span><span id="L-530"><a href="#L-530"><span class="linenos">530</span></a><span class="sd">```</span>
</span><span id="L-531"><a href="#L-531"><span class="linenos">531</span></a>
</span><span id="L-532"><a href="#L-532"><span class="linenos">532</span></a><span class="sd">In this case, it is possible to split the input dataframe in two, with one</span>
</span><span id="L-533"><a href="#L-533"><span class="linenos">533</span></a><span class="sd">dataframe for the `y` variable and one for `sigma`.</span>
</span><span id="L-534"><a href="#L-534"><span class="linenos">534</span></a>
</span><span id="L-535"><a href="#L-535"><span class="linenos">535</span></a><span class="sd">```</span>
</span><span id="L-536"><a href="#L-536"><span class="linenos">536</span></a><span class="sd">y,school    sigma,school</span>
</span><span id="L-537"><a href="#L-537"><span class="linenos">537</span></a><span class="sd">28,1        15,1</span>
</span><span id="L-538"><a href="#L-538"><span class="linenos">538</span></a><span class="sd">8,2         10,2</span>
</span><span id="L-539"><a href="#L-539"><span class="linenos">539</span></a><span class="sd">-3,3        16,3</span>
</span><span id="L-540"><a href="#L-540"><span class="linenos">540</span></a><span class="sd">7,4         11,4</span>
</span><span id="L-541"><a href="#L-541"><span class="linenos">541</span></a><span class="sd">-1,5        9,5</span>
</span><span id="L-542"><a href="#L-542"><span class="linenos">542</span></a><span class="sd">1,6         11,6</span>
</span><span id="L-543"><a href="#L-543"><span class="linenos">543</span></a><span class="sd">18,7        10,7</span>
</span><span id="L-544"><a href="#L-544"><span class="linenos">544</span></a><span class="sd">12,8        18,8</span>
</span><span id="L-545"><a href="#L-545"><span class="linenos">545</span></a><span class="sd">```</span>
</span><span id="L-546"><a href="#L-546"><span class="linenos">546</span></a>
</span><span id="L-547"><a href="#L-547"><span class="linenos">547</span></a><span class="sd">In this case the two dataframes could be joined together on `school`.</span>
</span><span id="L-548"><a href="#L-548"><span class="linenos">548</span></a>
</span><span id="L-549"><a href="#L-549"><span class="linenos">549</span></a><span class="sd">However, if instead these are passed as two separate dataframes to a Rat program, then</span>
</span><span id="L-550"><a href="#L-550"><span class="linenos">550</span></a><span class="sd">they can be recombined in code by replacing:</span>
</span><span id="L-551"><a href="#L-551"><span class="linenos">551</span></a>
</span><span id="L-552"><a href="#L-552"><span class="linenos">552</span></a><span class="sd">```</span>
</span><span id="L-553"><a href="#L-553"><span class="linenos">553</span></a><span class="sd">y&#39; ~ normal(theta[school], sigma);</span>
</span><span id="L-554"><a href="#L-554"><span class="linenos">554</span></a><span class="sd">```</span>
</span><span id="L-555"><a href="#L-555"><span class="linenos">555</span></a>
</span><span id="L-556"><a href="#L-556"><span class="linenos">556</span></a><span class="sd">with</span>
</span><span id="L-557"><a href="#L-557"><span class="linenos">557</span></a>
</span><span id="L-558"><a href="#L-558"><span class="linenos">558</span></a><span class="sd">```</span>
</span><span id="L-559"><a href="#L-559"><span class="linenos">559</span></a><span class="sd">y&#39; ~ normal(theta[school], sigma[school]);</span>
</span><span id="L-560"><a href="#L-560"><span class="linenos">560</span></a><span class="sd">```</span>
</span><span id="L-561"><a href="#L-561"><span class="linenos">561</span></a>
</span><span id="L-562"><a href="#L-562"><span class="linenos">562</span></a><span class="sd">The variable `sigma` uses the second dataframe because there is no `sigma` in the first,</span>
</span><span id="L-563"><a href="#L-563"><span class="linenos">563</span></a><span class="sd">and the subscript `school` allows the two sets of data to be joined together. It would be</span>
</span><span id="L-564"><a href="#L-564"><span class="linenos">564</span></a><span class="sd">an error for the subscript `school` to not be there. In that case the join from `sigma`</span>
</span><span id="L-565"><a href="#L-565"><span class="linenos">565</span></a><span class="sd">to `y` would not be unique.</span>
</span><span id="L-566"><a href="#L-566"><span class="linenos">566</span></a>
</span><span id="L-567"><a href="#L-567"><span class="linenos">567</span></a><span class="sd">## Sharp edges with renaming</span>
</span><span id="L-568"><a href="#L-568"><span class="linenos">568</span></a>
</span><span id="L-569"><a href="#L-569"><span class="linenos">569</span></a><span class="sd">Subscript values are determined by position, which means it is possible to rename variables</span>
</span><span id="L-570"><a href="#L-570"><span class="linenos">570</span></a><span class="sd">in a very misleading way.</span>
</span><span id="L-571"><a href="#L-571"><span class="linenos">571</span></a>
</span><span id="L-572"><a href="#L-572"><span class="linenos">572</span></a><span class="sd">```</span>
</span><span id="L-573"><a href="#L-573"><span class="linenos">573</span></a><span class="sd">score ~ normal(skill[team, year], sigma);</span>
</span><span id="L-574"><a href="#L-574"><span class="linenos">574</span></a><span class="sd">skill[year, team] ~ normal(all_time_skill[team], tau);</span>
</span><span id="L-575"><a href="#L-575"><span class="linenos">575</span></a><span class="sd">...</span>
</span><span id="L-576"><a href="#L-576"><span class="linenos">576</span></a><span class="sd">```</span>
</span><span id="L-577"><a href="#L-577"><span class="linenos">577</span></a>
</span><span id="L-578"><a href="#L-578"><span class="linenos">578</span></a><span class="sd">In the second line, the subscript names are reversed, which means that the values of</span>
</span><span id="L-579"><a href="#L-579"><span class="linenos">579</span></a><span class="sd">the `year` subscript on the second line will be the values of the `team` subscript on</span>
</span><span id="L-580"><a href="#L-580"><span class="linenos">580</span></a><span class="sd">the first line!</span>
</span><span id="L-581"><a href="#L-581"><span class="linenos">581</span></a>
</span><span id="L-582"><a href="#L-582"><span class="linenos">582</span></a><span class="sd">## Distributions</span>
</span><span id="L-583"><a href="#L-583"><span class="linenos">583</span></a>
</span><span id="L-584"><a href="#L-584"><span class="linenos">584</span></a><span class="sd">$\mathcal{R}$ here means all real numbers and $\mathcal{R}^+$ means real numbers greater than zero.</span>
</span><span id="L-585"><a href="#L-585"><span class="linenos">585</span></a>
</span><span id="L-586"><a href="#L-586"><span class="linenos">586</span></a>
</span><span id="L-587"><a href="#L-587"><span class="linenos">587</span></a><span class="sd">| Distribution | Constraints |</span>
</span><span id="L-588"><a href="#L-588"><span class="linenos">588</span></a><span class="sd">| ---------------------------|</span>
</span><span id="L-589"><a href="#L-589"><span class="linenos">589</span></a><span class="sd">| `y ~ bernoulli_logit(logit_p)` | $y = 0$ or $y = 1$, $\text{logit_p} \in \mathcal{R}$ |</span>
</span><span id="L-590"><a href="#L-590"><span class="linenos">590</span></a><span class="sd">| `y ~ cauchy(location, scale)` | $y, \text{location} \in \mathcal{R}$, $\text{scale} \in \mathcal{R}^+$ |</span>
</span><span id="L-591"><a href="#L-591"><span class="linenos">591</span></a><span class="sd">| `y ~ exponential(scale)` | $y, \text{scale} \in \mathcal{R}^+$ |</span>
</span><span id="L-592"><a href="#L-592"><span class="linenos">592</span></a><span class="sd">| `y ~ log_normal(mu, sigma)` | $\text{mu} \in \mathcal{R}$, $y, \text{sigma} \in \mathcal{R}^+$ |</span>
</span><span id="L-593"><a href="#L-593"><span class="linenos">593</span></a><span class="sd">| `y ~ normal(mu, sigma)` | $y, \text{mu} \in \mathcal{R}$, $\text{sigma} \in \mathcal{R}^+$ |</span>
</span><span id="L-594"><a href="#L-594"><span class="linenos">594</span></a>
</span><span id="L-595"><a href="#L-595"><span class="linenos">595</span></a><span class="sd">## Functions</span>
</span><span id="L-596"><a href="#L-596"><span class="linenos">596</span></a>
</span><span id="L-597"><a href="#L-597"><span class="linenos">597</span></a><span class="sd">* `abs(x)`</span>
</span><span id="L-598"><a href="#L-598"><span class="linenos">598</span></a><span class="sd">* `arccos(x)`</span>
</span><span id="L-599"><a href="#L-599"><span class="linenos">599</span></a><span class="sd">* `arcsin(x)`</span>
</span><span id="L-600"><a href="#L-600"><span class="linenos">600</span></a><span class="sd">* `arctan(x)`</span>
</span><span id="L-601"><a href="#L-601"><span class="linenos">601</span></a><span class="sd">* `ceil(x)`</span>
</span><span id="L-602"><a href="#L-602"><span class="linenos">602</span></a><span class="sd">* `cos(x)`</span>
</span><span id="L-603"><a href="#L-603"><span class="linenos">603</span></a><span class="sd">* `exp(x)`</span>
</span><span id="L-604"><a href="#L-604"><span class="linenos">604</span></a><span class="sd">* `floor(x)`</span>
</span><span id="L-605"><a href="#L-605"><span class="linenos">605</span></a><span class="sd">* `inverse_logit(x)`</span>
</span><span id="L-606"><a href="#L-606"><span class="linenos">606</span></a><span class="sd">* `log(x)`</span>
</span><span id="L-607"><a href="#L-607"><span class="linenos">607</span></a><span class="sd">* `logit(x)`</span>
</span><span id="L-608"><a href="#L-608"><span class="linenos">608</span></a><span class="sd">* `round(x)`</span>
</span><span id="L-609"><a href="#L-609"><span class="linenos">609</span></a><span class="sd">* `sin(x)`</span>
</span><span id="L-610"><a href="#L-610"><span class="linenos">610</span></a><span class="sd">* `tan(x)`</span>
</span><span id="L-611"><a href="#L-611"><span class="linenos">611</span></a>
</span><span id="L-612"><a href="#L-612"><span class="linenos">612</span></a><span class="sd">## Operator Precedence Table</span>
</span><span id="L-613"><a href="#L-613"><span class="linenos">613</span></a>
</span><span id="L-614"><a href="#L-614"><span class="linenos">614</span></a><span class="sd">|  Operator   |   Precedence   |</span>
</span><span id="L-615"><a href="#L-615"><span class="linenos">615</span></a><span class="sd">|------|:-----:|</span>
</span><span id="L-616"><a href="#L-616"><span class="linenos">616</span></a><span class="sd">| function calls(`exp`, `log`, etc.) | 100, leftmost derivative  |</span>
</span><span id="L-617"><a href="#L-617"><span class="linenos">617</span></a><span class="sd">| prefix negation(`-10`, `-(1+2)`, etc.) | 50 |</span>
</span><span id="L-618"><a href="#L-618"><span class="linenos">618</span></a><span class="sd">| `^`  | 40  |</span>
</span><span id="L-619"><a href="#L-619"><span class="linenos">619</span></a><span class="sd">| `*`, `/`, `%`  | 30  |</span>
</span><span id="L-620"><a href="#L-620"><span class="linenos">620</span></a><span class="sd">| `+`, `-`  | 10  |</span>
</span><span id="L-621"><a href="#L-621"><span class="linenos">621</span></a><span class="sd">| `&gt;`, `&lt;`, `&gt;=`, `&lt;=`, `!=`, `==` | 5  |</span>
</span><span id="L-622"><a href="#L-622"><span class="linenos">622</span></a>
</span><span id="L-623"><a href="#L-623"><span class="linenos">623</span></a><span class="sd"># Installation and Use</span>
</span><span id="L-624"><a href="#L-624"><span class="linenos">624</span></a>
</span><span id="L-625"><a href="#L-625"><span class="linenos">625</span></a><span class="sd">Rat is only available from Github, and requires [Rust](https://www.rust-lang.org/) to</span>
</span><span id="L-626"><a href="#L-626"><span class="linenos">626</span></a><span class="sd">be installed to work.</span>
</span><span id="L-627"><a href="#L-627"><span class="linenos">627</span></a>
</span><span id="L-628"><a href="#L-628"><span class="linenos">628</span></a><span class="sd">First, follow the [Rust installation directions](https://www.rust-lang.org/tools/install).</span>
</span><span id="L-629"><a href="#L-629"><span class="linenos">629</span></a>
</span><span id="L-630"><a href="#L-630"><span class="linenos">630</span></a><span class="sd">Secondly, install rat from Github:</span>
</span><span id="L-631"><a href="#L-631"><span class="linenos">631</span></a>
</span><span id="L-632"><a href="#L-632"><span class="linenos">632</span></a><span class="sd">```</span>
</span><span id="L-633"><a href="#L-633"><span class="linenos">633</span></a><span class="sd">git clone https://github.com/bbbales2/regressions</span>
</span><span id="L-634"><a href="#L-634"><span class="linenos">634</span></a><span class="sd">cd regressions</span>
</span><span id="L-635"><a href="#L-635"><span class="linenos">635</span></a><span class="sd">pip install .</span>
</span><span id="L-636"><a href="#L-636"><span class="linenos">636</span></a><span class="sd">```</span>
</span><span id="L-637"><a href="#L-637"><span class="linenos">637</span></a>
</span><span id="L-638"><a href="#L-638"><span class="linenos">638</span></a><span class="sd">## Command line interface</span>
</span><span id="L-639"><a href="#L-639"><span class="linenos">639</span></a>
</span><span id="L-640"><a href="#L-640"><span class="linenos">640</span></a><span class="sd">Rat is a Python library, but comes with a helper script `rat` to quickly compile and</span>
</span><span id="L-641"><a href="#L-641"><span class="linenos">641</span></a><span class="sd">run models.</span>
</span><span id="L-642"><a href="#L-642"><span class="linenos">642</span></a>
</span><span id="L-643"><a href="#L-643"><span class="linenos">643</span></a><span class="sd">For example, to fit a model `mrp.rat` with the data `mrp.csv` and save the results in</span>
</span><span id="L-644"><a href="#L-644"><span class="linenos">644</span></a><span class="sd">`output` we can do:</span>
</span><span id="L-645"><a href="#L-645"><span class="linenos">645</span></a>
</span><span id="L-646"><a href="#L-646"><span class="linenos">646</span></a><span class="sd">```</span>
</span><span id="L-647"><a href="#L-647"><span class="linenos">647</span></a><span class="sd">rat mrp.rat mrp.csv output</span>
</span><span id="L-648"><a href="#L-648"><span class="linenos">648</span></a><span class="sd">```</span>
</span><span id="L-649"><a href="#L-649"><span class="linenos">649</span></a>
</span><span id="L-650"><a href="#L-650"><span class="linenos">650</span></a><span class="sd">Type `rat -h` for full usage info.</span>
</span><span id="L-651"><a href="#L-651"><span class="linenos">651</span></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-652"><a href="#L-652"><span class="linenos">652</span></a>
</span><span id="L-653"><a href="#L-653"><span class="linenos">653</span></a><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="s2">&quot;fit&quot;</span><span class="p">]</span>
</span><span id="L-654"><a href="#L-654"><span class="linenos">654</span></a>
</span><span id="L-655"><a href="#L-655"><span class="linenos">655</span></a><span class="kn">from</span> <span class="nn">.model</span> <span class="kn">import</span> <span class="n">Model</span>
</span><span id="L-656"><a href="#L-656"><span class="linenos">656</span></a><span class="kn">from</span> <span class="nn">.optimizer</span> <span class="kn">import</span> <span class="n">optimize</span>
</span><span id="L-657"><a href="#L-657"><span class="linenos">657</span></a><span class="kn">from</span> <span class="nn">.sampler</span> <span class="kn">import</span> <span class="n">sample</span>
</span><span id="L-658"><a href="#L-658"><span class="linenos">658</span></a>
</span><span id="L-659"><a href="#L-659"><span class="linenos">659</span></a><span class="n">_todo_figure_out_internal_docs</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
</span><span id="L-660"><a href="#L-660"><span class="linenos">660</span></a>
</span><span id="L-661"><a href="#L-661"><span class="linenos">661</span></a><span class="s2">---</span>
</span><span id="L-662"><a href="#L-662"><span class="linenos">662</span></a>
</span><span id="L-663"><a href="#L-663"><span class="linenos">663</span></a><span class="s2">## Internals - `rat.variables`, `rat.ops`, `rat.variables.Subscript`, and `rat.variables.SubscriptUse`</span>
</span><span id="L-664"><a href="#L-664"><span class="linenos">664</span></a><span class="s2">(This portion is for people who want to dig into rat&#39;s source)</span>
</span><span id="L-665"><a href="#L-665"><span class="linenos">665</span></a>
</span><span id="L-666"><a href="#L-666"><span class="linenos">666</span></a><span class="s2">If you look closely at rat&#39;s source, you might notice something weird: There&#39;s a `rat.ops.Param` class and a `rat.variables.Param`. This also goes for `rat.ops.Data`, `rat.ops.Subscript`. `rat.ops` is designated as elements for the nodes of the parse tree that&#39;s generated by the parser. Since rat uses the parse tree to transpile to Python, we need to inject additional information regarding subscripts to the parse tree. This is where `rat.variables` comes into play: they are used to hold information regarding subscripts for a given parameter. I&#39;ll use the [skill model](#subscripts) example to explain:</span>
</span><span id="L-667"><a href="#L-667"><span class="linenos">667</span></a>
</span><span id="L-668"><a href="#L-668"><span class="linenos">668</span></a><span class="s2">The parser converts the skill model above into the following parse tree representations:</span>
</span><span id="L-669"><a href="#L-669"><span class="linenos">669</span></a><span class="s2">```</span>
</span><span id="L-670"><a href="#L-670"><span class="linenos">670</span></a><span class="s2">ops.Normal(</span>
</span><span id="L-671"><a href="#L-671"><span class="linenos">671</span></a><span class="s2">    ops.Data(&quot;score_diff&quot;),</span>
</span><span id="L-672"><a href="#L-672"><span class="linenos">672</span></a><span class="s2">    ops.Diff(</span>
</span><span id="L-673"><a href="#L-673"><span class="linenos">673</span></a><span class="s2">        ops.Param(&quot;skills&quot;, ops.Subscript((&quot;home_team&quot;, &quot;year&quot;))),</span>
</span><span id="L-674"><a href="#L-674"><span class="linenos">674</span></a><span class="s2">        ops.Param(&quot;skills&quot;, ops.Subscript((&quot;away_team&quot;, &quot;year&quot;))),</span>
</span><span id="L-675"><a href="#L-675"><span class="linenos">675</span></a><span class="s2">    ),</span>
</span><span id="L-676"><a href="#L-676"><span class="linenos">676</span></a><span class="s2">    ops.Param(&quot;sigma&quot;),</span>
</span><span id="L-677"><a href="#L-677"><span class="linenos">677</span></a><span class="s2">),</span>
</span><span id="L-678"><a href="#L-678"><span class="linenos">678</span></a><span class="s2">ops.Normal(</span>
</span><span id="L-679"><a href="#L-679"><span class="linenos">679</span></a><span class="s2">    ops.Param(&quot;skills&quot;, ops.Subscript((&quot;team&quot;, &quot;year&quot;))),</span>
</span><span id="L-680"><a href="#L-680"><span class="linenos">680</span></a><span class="s2">    ops.Param(&quot;skills_mu&quot;, ops.Subscript((&quot;year&quot;,))),</span>
</span><span id="L-681"><a href="#L-681"><span class="linenos">681</span></a><span class="s2">    ops.Param(&quot;tau&quot;),</span>
</span><span id="L-682"><a href="#L-682"><span class="linenos">682</span></a><span class="s2">),</span>
</span><span id="L-683"><a href="#L-683"><span class="linenos">683</span></a><span class="s2">ops.Normal(</span>
</span><span id="L-684"><a href="#L-684"><span class="linenos">684</span></a><span class="s2">    ops.Param(&quot;skills_mu&quot;, ops.Subscript((&quot;year&quot;,))),</span>
</span><span id="L-685"><a href="#L-685"><span class="linenos">685</span></a><span class="s2">    ops.RealConstant(0.0),</span>
</span><span id="L-686"><a href="#L-686"><span class="linenos">686</span></a><span class="s2">    ops.RealConstant(1.0),</span>
</span><span id="L-687"><a href="#L-687"><span class="linenos">687</span></a><span class="s2">),</span>
</span><span id="L-688"><a href="#L-688"><span class="linenos">688</span></a><span class="s2">ops.Normal(</span>
</span><span id="L-689"><a href="#L-689"><span class="linenos">689</span></a><span class="s2">    ops.Param(&quot;tau&quot;, lower=ops.RealConstant(0.0)),</span>
</span><span id="L-690"><a href="#L-690"><span class="linenos">690</span></a><span class="s2">    ops.RealConstant(0.0),</span>
</span><span id="L-691"><a href="#L-691"><span class="linenos">691</span></a><span class="s2">    ops.RealConstant(1.0),</span>
</span><span id="L-692"><a href="#L-692"><span class="linenos">692</span></a><span class="s2">),</span>
</span><span id="L-693"><a href="#L-693"><span class="linenos">693</span></a><span class="s2">ops.Normal(</span>
</span><span id="L-694"><a href="#L-694"><span class="linenos">694</span></a><span class="s2">    ops.Param(&quot;sigma&quot;, lower=ops.RealConstant(0.0)),</span>
</span><span id="L-695"><a href="#L-695"><span class="linenos">695</span></a><span class="s2">    ops.RealConstant(0.0),</span>
</span><span id="L-696"><a href="#L-696"><span class="linenos">696</span></a><span class="s2">    ops.RealConstant(1.0),</span>
</span><span id="L-697"><a href="#L-697"><span class="linenos">697</span></a><span class="s2">)</span>
</span><span id="L-698"><a href="#L-698"><span class="linenos">698</span></a><span class="s2">```</span>
</span><span id="L-699"><a href="#L-699"><span class="linenos">699</span></a>
</span><span id="L-700"><a href="#L-700"><span class="linenos">700</span></a><span class="s2">For each parameter we create a `rat.variables.Subscript` object which in essence hold the factors of the subscript. Recall `skills[team, year]` was in fact `skills[union(home_team, away_team), year]`. So we need a parameter for each team-year combination. `rat.variables.Subscript` internally stores a dataframe with columns `team` and `year`, which hold these unique combinations as reference subscripts.</span>
</span><span id="L-701"><a href="#L-701"><span class="linenos">701</span></a>
</span><span id="L-702"><a href="#L-702"><span class="linenos">702</span></a><span class="s2">But we might want to just subscript `home_team` from `team`. That is, we might only want a portion of the subscript. `rat.variables.SubscriptUse` is the object that maps a variable&#39;s subscripts to another variable&#39;s reference subscript(its `rat.variables.Subscript` object). If we just wanted to subscript `home_team` from `team`, it will compare the `home_team` dataframe with `team`&#39;s reference dataframe, and only select the combinations that are necessary.</span>
</span><span id="L-703"><a href="#L-703"><span class="linenos">703</span></a>
</span><span id="L-704"><a href="#L-704"><span class="linenos">704</span></a><span class="s2">---</span>
</span><span id="L-705"><a href="#L-705"><span class="linenos">705</span></a>
</span><span id="L-706"><a href="#L-706"><span class="linenos">706</span></a><span class="s2">## Language function reference</span>
</span><span id="L-707"><a href="#L-707"><span class="linenos">707</span></a><span class="s2">Below are individual links to supported math functions and distributions</span>
</span><span id="L-708"><a href="#L-708"><span class="linenos">708</span></a>
</span><span id="L-709"><a href="#L-709"><span class="linenos">709</span></a><span class="s2">- **Distributions**</span>
</span><span id="L-710"><a href="#L-710"><span class="linenos">710</span></a><span class="s2">    - `rat.ops.Normal` : `normal(mu, sigma)`</span>
</span><span id="L-711"><a href="#L-711"><span class="linenos">711</span></a><span class="s2">    - `rat.ops.BernoulliLogit`, `rat.compiler.bernoulli_logit` : `bernoulli_logit(p)`</span>
</span><span id="L-712"><a href="#L-712"><span class="linenos">712</span></a><span class="s2">    - `rat.ops.LogNormal`, `rat.compiler.log_normal`  : `log_normal(mu, sigma)`</span>
</span><span id="L-713"><a href="#L-713"><span class="linenos">713</span></a><span class="s2">    - `rat.ops.Cauchy`  : `cauchy(location, scale)`</span>
</span><span id="L-714"><a href="#L-714"><span class="linenos">714</span></a><span class="s2">    - `rat.ops.Exponential`  :  `exponential(scale)`</span>
</span><span id="L-715"><a href="#L-715"><span class="linenos">715</span></a><span class="s2">- **Functions**</span>
</span><span id="L-716"><a href="#L-716"><span class="linenos">716</span></a><span class="s2">    - `rat.ops.Log`: `log(x)`</span>
</span><span id="L-717"><a href="#L-717"><span class="linenos">717</span></a><span class="s2">    - `rat.ops.Exp` : `exp(x)`</span>
</span><span id="L-718"><a href="#L-718"><span class="linenos">718</span></a><span class="s2">    - `rat.ops.Abs` : `abs(x)`</span>
</span><span id="L-719"><a href="#L-719"><span class="linenos">719</span></a><span class="s2">    - `rat.ops.Floor` : `floor(x)`</span>
</span><span id="L-720"><a href="#L-720"><span class="linenos">720</span></a><span class="s2">    - `rat.ops.Ceil` : `ceil(x)`</span>
</span><span id="L-721"><a href="#L-721"><span class="linenos">721</span></a><span class="s2">    - `rat.ops.Round` : `round(x)`</span>
</span><span id="L-722"><a href="#L-722"><span class="linenos">722</span></a><span class="s2">    - `rat.ops.Sin` : `sin(x)`</span>
</span><span id="L-723"><a href="#L-723"><span class="linenos">723</span></a><span class="s2">    - `rat.ops.Cos` : `cos(x)`</span>
</span><span id="L-724"><a href="#L-724"><span class="linenos">724</span></a><span class="s2">    - `rat.ops.Tan` : `tan(x)`</span>
</span><span id="L-725"><a href="#L-725"><span class="linenos">725</span></a><span class="s2">    - `rat.ops.Arcsin` : `arcsin(x)`</span>
</span><span id="L-726"><a href="#L-726"><span class="linenos">726</span></a><span class="s2">    - `rat.ops.Arccos` : `arccos(x)`</span>
</span><span id="L-727"><a href="#L-727"><span class="linenos">727</span></a><span class="s2">    - `rat.ops.Arctan` : `arctan(x)`</span>
</span><span id="L-728"><a href="#L-728"><span class="linenos">728</span></a><span class="s2">    - `rat.ops.Logit` : `logit(x)`</span>
</span><span id="L-729"><a href="#L-729"><span class="linenos">729</span></a><span class="s2">    - `rat.ops.InverseLogit` : `inverse_logit(x)`</span>
</span><span id="L-730"><a href="#L-730"><span class="linenos">730</span></a>
</span><span id="L-731"><a href="#L-731"><span class="linenos">731</span></a><span class="s2">&quot;&quot;&quot;</span>
</span></pre></div>


            </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        if (doc.fullname.endsWith(".__init__")) {
                            heading = `<span class="name">${doc.fullname.replace(/\.__init__$/, "")}</span>${doc.signature}`;
                        } else {
                            heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span>${doc.signature}`;
                        }
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>