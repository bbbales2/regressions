from dataclasses import dataclass, field
from enum import Enum
import numpy
import pandas
import pprint
from typing import Dict, Set, Tuple, Iterable

from .exceptions import CompileError


class VariableType(Enum):
    DATA = 1
    PARAM = 2
    ASSIGNED_PARAM = 3


@dataclass()
class TableRecord:
    """
    A record within the SymbolTable

    name: Tame of the variable
    variable_type: The type of the variable(VariableType). Data, Param, or Assigned Param
    subscripts: If subscripts exist, the "true" subscript set of the variable. All subscripts aliases effectively
    point to one or more columns of the input dataframe. Those columns of the input dataframe are the true subscripts
    of the variable. If the variable has 2 subscripts, it is stored as {(column_1, column_2), ...}
    shifts: set of shift combinations used for this parameter. For example, param[shift(sub_1, 1), sub_2] would be saved
    as (1, 0)
    subscript_alias: This is the "fake" subscript names, declared by the user for the variable. These values are used
    as column names of the base dataframe
    constraint_lower: value of the lower constraint
    constraint_upper: value of the upper constraint
    base_df: the calculated base dataframe. This is generated by `SymbolTable.build_base_dataframes()` and shouldn't be set
    by the programmer.
    pad_needed: true if a padding is needed for the variable
    unconstrained_vector_start_index: For parameters, the start index of the unconstrained parameter vector. Generated
    by `SymbolTable.build_base_dataframes()`.
    unconstrained_vector_end_index: For parameters, the end index of the unconstrained parameter vector. Generated by
    `SymbolTable.build_base_dataframes()`.
    """

    name: str
    variable_type: VariableType
    base_df: pandas.DataFrame

    source_name: str = field(default=None)
    subscripts_rename: Tuple[str] = field(default=None)

    constraint_lower: float = field(default=float("-inf"))
    constraint_upper: float = field(default=float("inf"))
    pad_needed: bool = field(default=False)

    unconstrained_vector_start_index: int = field(default=None, init=False)
    unconstrained_vector_end_index: int = field(default=None, init=False)

    @property
    def subscripts(self):
        if self.subscripts_rename is None:
            if self.base_df is None:
                return ()
            else:
                return tuple(self.base_df.columns)
        else:
            return self.subscripts_rename
    
    def set_subscript_names(self, subscript_rename : Tuple[str]):
        if self.subscripts_rename is None:
            self.subscripts_rename = subscript_rename
            self.base_df.columns = self.subscripts
        else:
            if subscript_rename != self.subscripts_rename:
                raise AttributeError("Internal compiler error: If there are multiple renames, the rename values must match")

    def add_rows_from_dataframe(self, new_rows_df : pandas.DataFrame):
        """
        Add rows to the base_df
        """
        if self.base_df is None:
            combined_df = new_rows_df
        else:
            combined_df = pandas.DataFrame(
                numpy.concatenate([self.base_df.values, new_rows_df.values]),
                columns = self.base_df.columns
            )

        self.base_df = (
            combined_df
            .drop_duplicates()
            .sort_values(list(combined_df.columns))
            .reset_index(drop=True)
        )

    def set_constraints(self, constraint_lower : float, constraint_upper : float):
        if self.constraint_lower != float("-inf") or self.constraint_upper != float("inf"):
            if self.constraint_lower != constraint_lower or self.constraint_upper != constraint_upper:
                raise AttributeError("Internal compiler error: Once changed from defaults, constraints must match")
        else:
            self.constraint_lower = constraint_lower
            self.constraint_upper = constraint_upper

class SymbolTable:
    def __init__(self, data_df):
        """
        symbol_dict: The internal dictionary that represents the symbol table. Key values are variable names.
        unconstrained_param_count: the length of the required unconstrained parameter vector.
        data_df: the input data dataframe
        generated_subscript_dict: Dictionary which maps subscript keys to indices.
        """
        self.symbol_dict: Dict[str, TableRecord] = {}
        self.unconstrained_param_count: int = 0  # length of the unconstrained parameter vector
        self.data_df = data_df.copy()

        # Convert all integer columns to a type that supports NA
        for column in self.data_df.columns:
            if pandas.api.types.is_integer_dtype(self.data_df[column].dtype):
                self.data_df[column] = self.data_df[column].astype(pandas.Int64Dtype())

        self.generated_subscript_dict: Dict[str, numpy.ndarray] = {}
        self.generated_subscript_count = 0
        self.first_in_group_indicator: Dict[str, numpy.ndarray] = {}

        self._unique_number = 0

    def get_unique_number(self):
        self._unique_number += 1
        return self._unique_number

    def upsert(
        self,
        variable_name: str,
        variable_type: VariableType = None,
        subscripts: Tuple[str] = None,
        subscript_alias: Tuple[str] = tuple(),
        constraint_lower: float = float("-inf"),
        constraint_upper: float = float("inf"),
        pad_needed: bool = None,
    ):
        """
        Upsert(update or create) a record within the symbol table. The 6 arguments of this functions should be the only
        fields of the record that the programmer should provide; other fields are generated automatically by
        `build_base_dataframes()`.
        """
        if variable_name not in self.symbol_dict:
            if variable_type == VariableType.DATA:
                base_df = self.data_df
            else:
                base_df = None

            # Insert if new
            self.symbol_dict[variable_name] = TableRecord(
                variable_name,
                variable_type,
                base_df,
            )

    def __contains__(self, name : str) -> bool:
        return name in self.symbol_dict

    def lookup(self, variable_name: str) -> TableRecord:
        """
        Dictionary indexing
        """
        return self.symbol_dict[variable_name]

    def iter_records(self):
        for name, record in self.symbol_dict.items():
            yield name, record

    def build_base_dataframes(self, data_df: pandas.DataFrame):
        """
        Builds the base dataframes for parameters from the current symbol table.
        Also resets any generated subscript indices
        """
        self.generated_subscript_dict = {}
        self.generated_subscript_count = 0

        current_index = 0
        for variable_name, record in self.symbol_dict.items():
            if not record.variable_type:
                error_msg = f"Fatal internal error - variable type information for '{variable_name}' not present within the symbol table. Aborting compilation."
                raise CompileError(error_msg)

            # Allocate space on unconstrained parameter vector for parameters
            if record.variable_type == VariableType.PARAM:
                if len(record.subscripts) > 0:
                    nrows = record.base_df.shape[0]
                    # base_df["__index"] = pd.Series(range(current_index, current_index + nrows))
                else:
                    nrows = 1

                record.unconstrained_vector_start_index = current_index
                record.unconstrained_vector_end_index = current_index + nrows - 1
                current_index += nrows

        self.unconstrained_param_count = current_index

    def get_subscript_key(
        self,
        primary_variable_name: str,
        target_variable_name: str,
        target_variable_subscripts: Tuple[str],
        shifts: Tuple[int],
    ):
        primary_variable = self.lookup(primary_variable_name)
        target_variable = self.lookup(target_variable_name)

        shifts_by_subscript_name = {
            name: shift for name, shift in zip(target_variable_subscripts, shifts)
        }

        target_variable.base_df

        shift_subscripts = []
        shift_values = []
        grouping_subscripts = []
        for column in primary_variable.base_df.columns:
            if column in shifts_by_subscript_name:
                shift = shifts_by_subscript_name[column]
            else:
                shift = 0

            if shift == 0:
                grouping_subscripts.append(column)
            else:
                shift_subscripts.append(column)
                shift_values.append(shift)
        
        primary_base_df = primary_variable.base_df.copy()

        if len(grouping_subscripts) > 0:
            grouped_df = primary_base_df.groupby(grouping_subscripts)
        else:
            grouped_df = primary_base_df

        for column, shift in zip(shift_subscripts, shift_values):
            shifted_column = grouped_df[column].shift(shift).reset_index(drop=True)
            primary_base_df[column] = shifted_column

        target_base_df = target_variable.base_df.copy()
        target_base_df.columns = list(target_variable_subscripts)

        target_base_df["__in_dataframe_index"] = pandas.Series(range(target_base_df.shape[0]), dtype = pandas.Int64Dtype())

        key_name = f"subscript__{self.generated_subscript_count}"
        self.generated_subscript_count += 1

        self.generated_subscript_dict[key_name] = (
            primary_base_df
            .merge(target_base_df, on=target_variable_subscripts, how="left")
            ["__in_dataframe_index"]
            # NAs correspond to out of bounds accesses -- those should map 
            # to zero (and any parameter that needs to do out of bounds
            # accesses will have zeros allocated for the last element)
            .fillna(target_base_df.shape[0])
            .astype(int)
            .to_numpy()
        )

        # If this is a recursively assigned parameter and there are groupings then we'll
        # need to generate some special values for the jax.lax.scan recursive assignment
        # implementation
        if (
            len(grouping_subscripts) > 0 and
            (primary_variable_name == target_variable_name) and
            (target_variable.variable_type == VariableType.ASSIGNED_PARAM)
        ):
            self.first_in_group_indicator[primary_variable_name] = (~primary_base_df.duplicated(subset=grouping_subscripts)).to_numpy()

        return key_name

    def __str__(self):
        return pprint.pformat(self.symbol_dict)
